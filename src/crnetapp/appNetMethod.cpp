/* Creature3D - Online Game Engine, Copyright (C) 2005 Wucaihua(26756325@qq.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
*/
#include <rbody/Creature3D/CreBody.h>
#include <rbody/Mesh.h>
#include <shellapi.h>
#include <CREncapsulation/crStartHandler.h>
#include <CRNetApp/appNetMethod.h>
#include <CRNetApp/appNetStartLoader.h>
#include <CRNetApp/appMsg.h>
#include <CRNetApp/appDataClass.h>
#include <CRNetApp/appNetLogic.h>
#include <CRCore/crArgumentParser.h>
#include <CRCore/crWidgetNode.h>
#include <CRNet/crNetWorkUpdater.h>
#include <CREncapsulation/crLoader.h>
#include <CRNetApp/appNetLoader.h>
#include <CRNetApp/appNetPackets.h>
#include <CRCore/thread/crThread.h>
#include <CRIOManager/crFileUtils.h>
//#include "rcfg/ConfigScriptOO.h"
//#include <sys/stat.h>
#include <CRNetApp/appNetPackets2.h>
#include <CRNetApp/appNetCallbacks.h>
#include <CRNetApp/appGlobalHandle.h>
#include <CRPhysics/crViewMatterObject.h>
#include <CRProducer/crKeyboardMouseHandle.h>
#include <CREncapsulation/crSceneManager.h>
#include <CRProducer/crViewer.h>
//#include <CRAL/crSoundState.h>
#include <CRPhysics/crBodyCaseMatterObject.h>
#include <CRCore/crEffectSequenceManager.h>
//#include <CRParticle/crEffectParticleManager.h>
#include <CRCore/crSequence.h>
#include <CRIOManager/crConvertUTF.h>
#include <CRCore/crLightSource.h>
#include <CRCore/crLightSourceManager.h>
#include <CRNetApp/appNetCallbacks.h>
#include <CREncapsulation/crGameDices.h>
#include <CRNetApp/appLoginStartLoader.h>
#include <CREncapsulation/crNodeCallbacks.h>
#include <CRUtil/crAcceptGIVisitor.h>
#include <CRIOManager/crReadFile.h>
#include <CRNetApp/appNodeCallbacks.h>
#include <CRProducer/crSceneHandler.h>
#include <CREncapsulation/crDataClass.h>
#include <CREncapsulation/crNodeVisitors.h>
#include <CRDownload/CRDownload.h>
#include <CRNetApp/appDBQuery2.h>
#include <CRNetApp/appDBUpdate2.h>
#include <CRDataBase/crDataBaseManager.h>
#include <CRCore/crBlockDetectThread.h>
#include <CRSound/crSoundSystem.h>
#include <CRCore/crStatistics.h>
#include <CRParticle/crParticleSystemUpdater.h>
#include <CRCore/crLightSourceManager.h>
#include <sys/stat.h>
#include <psapi.h>  
#pragma comment(lib, "psapi.lib")
using namespace CRCore;
using namespace CRNet;
using namespace CRGUI;
using namespace CRNetApp;
using namespace CRPhysics;
using namespace CRProducer;
//using namespace CRAL;
using namespace CREncapsulation;
using namespace CRProducer;
using namespace CRParticle;
using namespace rbody;
using namespace CRIOManager;
using namespace CRUtil;
using namespace CRDownload;
using namespace CRUI;
using namespace CRDataBase;
using namespace CRSound;
using namespace CRParticle;
///////////////////////////////////////////
////
////crRoleEventContainerMethod
////
///////////////////////////////////////////
//crRoleEventContainerMethod::crRoleEventContainerMethod(){}
//crRoleEventContainerMethod::crRoleEventContainerMethod(const crRoleEventContainerMethod& handle):
//crBaseEventContainerMethod(handle)
//{
//}
//void crRoleEventContainerMethod::inputParam(int i, void *param)
//{
//	crBaseEventContainerMethod::inputParam(i,param);
//}
//
//void crRoleEventContainerMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRoleEventContainerMethod::operator()(crHandle &handle)
//{//由role来处理用户交互事件, QuickKeyMap快捷键
//	if(m_this && LOINT64(m_param)==WCH_EXCEVENT)
//	{
//		CRCore::ScopedLock<CRCore::crMutex> lock(m_eventListBufMutex);
//		m_eventListMutex.lock();
//		int hparam = HIINT64(m_param);
//		m_param = NULL;
//		m_eventList_buf.swap(m_eventList);
//		m_eventListMutex.unlock();
//
//		//crRole* role = crMyPlayerData::getInstance()->getCurrentRole();
//		//if(role && m_this == role->getRelNode())
//		{
//			//crInstanceItem *item = NULL;
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->getParam(WCHDATA_Item,param);
//			crInstanceItem *item = ((crInstanceItem*)param);
//			if(item && item->getDataClass() && crMyPlayerData::getInstance()->ifItemIsMe(item))
//			{
//				crData *itemData = item->getDataClass();
//				void *param;
//				itemData->getParam(WCHDATA_QuickKeyVec,param);
//				QuickKeyVec quickKeyVec = *(QuickKeyVec *)param;
//				itemData->getParam(WCHDATA_QuickList,param);
//				QuickList quickList = *(QuickList *)param;
//				_crInt64 _param;
//				_crInt32 _msg;
//				_crInt16 _key;
//				QuickKeyVec::iterator qkitr;
//				QuickList::iterator qItr;
//				bool found;
//				for( EventList::iterator itr = m_eventList_buf.begin();
//					itr != m_eventList_buf.end();
//					++itr )
//				{
//					_param = *itr;
//					if(!quickKeyVec.empty() && !quickList.empty())
//					{
//						_msg = LOINT64(_param);
//						if(HIINT32(_msg)==crGUIEventAdapter::KEYDOWN)
//						{
//							_key = LOINT32(_msg);
//							for( qkitr = quickKeyVec.begin();
//								qkitr != quickKeyVec.end();
//								++qkitr )
//							{
//								if(qkitr->first == _key)
//								{
//									found = false;
//									for(qItr = quickList.begin(); qItr != quickList.end(); ++qItr)
//									{
//										if(qItr->first == qkitr->second)
//										{
//											item->doEvent(WCH_QuickKeyPressed,MAKEINT64(qItr->second,NULL));
//											found = true;
//											break;
//										}
//									}
//									if(found) break;
//								}
//							}
//						}
//					}
//					item->doEvent(LOINT64(_param),MAKEINT64(HIINT64(_param),hparam));
//				}
//			}
//		}
//		if(!m_eventList_buf.empty()) m_eventList_buf.clear();
//	}
//}
///////////////////////////////////////////
////
////crSelectRolesEventMethod
////
///////////////////////////////////////////
//crSelectRolesEventMethod::crSelectRolesEventMethod():
//m_param(0L){}
//crSelectRolesEventMethod::crSelectRolesEventMethod(const crSelectRolesEventMethod& handle):
//crMethod(handle),
//m_param(0L)
//{
//}
//void crSelectRolesEventMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == NULL)
//		{
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crMatrixTransform*)param;
//		break;
//	case 2:
//		{
//			m_param = param==NULL?NULL:*(_crInt64*)param;
//		}
//		break;
//	}
//}
//
//void crSelectRolesEventMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crSelectRolesEventMethod::operator()(crHandle &handle)
//{
//	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
//	if(role)
//	{
//		crNode *node = role->getRelNode();
//		if(node) node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE),m_param);
//	}
//	//_crInt32 lparam = LOINT64(m_param);
//	//_crInt16 hlparam = HIINT32(lparam);
//	//if(hlparam == crGUIEventAdapter::MOVE)
//	//{//判断是否要移动相机
//	//	_crInt32 hparam = HIINT64(m_param);
//	//	crGUIEventAdapter *ea = (crGUIEventAdapter *)hparam;
//	//	float x = ea->getXnormalized();
//	//	float y = ea->getYnormalized();
//	//	unsigned char cameraMove = crCameraData::None;
//	//	if(equivalent(x,-1.0f,m_delta))
//	//	{
//	//		cameraMove |= crCameraData::MoveLeft;
//	//	}
//	//	else if(equivalent(x,1.0f,m_delta))
//	//	{
//	//		cameraMove |= crCameraData::MoveRight;
//	//	}
//	//	if(equivalent(y,-1.0f,m_delta))
//	//	{
//	//		cameraMove |= crCameraData::MoveUp;
//	//	}
//	//	else if(equivalent(y,1.0f,m_delta))
//	//	{
//	//		cameraMove |= crCameraData::MoveDown;
//	//	}
//	//	crData *data = m_this->getDataClass();
//	//	data->inputParam(WCHDATA_CameraMove,&cameraMove);
//	//}
//}
/////////////////////////////////////////
//
//crQuickKeyPressedMethod
//
/////////////////////////////////////////
crQuickKeyPressedMethod::crQuickKeyPressedMethod():
m_itemid(0)
{
}

crQuickKeyPressedMethod::crQuickKeyPressedMethod(const crQuickKeyPressedMethod& handle):
crMethod(handle),
m_itemid(0)
{
}

void crQuickKeyPressedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_itemid = LOINT64(param64);
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crQuickKeyPressedMethod::addParam(int i, const std::string& str)
{
}

void crQuickKeyPressedMethod::operator()(crHandle &handle)
{
	{
		ref_ptr<crItemChild> itemChild = m_this->findChildItem(m_itemid);
		if(itemChild.valid() && itemChild->isLoaded())
		{
			crInstanceItem* item = itemChild->getInstanceItem();
			crData *itemData = item->getDataClass();
			void *param;
			itemData->getParam(WCHDATA_DataType,param);
			unsigned char dataType = *(unsigned char *)param;
			crData *thisData = m_this->getDataClass();
			if(dataType == DT_Thing || dataType == DT_AttackThing)
			{
				m_this->doEvent(WCH_NetUseThing,MAKEINT64(item,NULL));
			}
			else if(dataType == DT_Skill)
			{
				//thisData->inputParam(WCHDATA_AboutToUseItemID,&m_itemid);
				//crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
				//bindview->showCursor("UseSkill");
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_AboutToUseItemID,param);
				int *id = (int *)param;
				if(*id != m_itemid)
				{
					*id = m_itemid;
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(*id);

					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvAboutToUseItemID,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			else if(dataType == DT_Attack)
			{
				thisData->inputParam(WCHDATA_CurrentAttackID,&m_itemid);
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_AboutToUseItemID,param);
				int *id = (int *)param;
				if(*id != 0)
				{
					*id = 0;
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(*id);

					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvAboutToUseItemID,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crInitNetMethod
//
/////////////////////////////////////////
crInitNetMethod::crInitNetMethod(){}
crInitNetMethod::crInitNetMethod(const crInitNetMethod& handle):
crMethod(handle)
{
}
void crInitNetMethod::inputParam(int i, void *param)
{
}

void crInitNetMethod::addParam(int i, const std::string& str)
{
}

void crInitNetMethod::operator()(crHandle &handle)
{
	//开启网络线程
	CRNet::crNetBridge::initializeGame("CSMServer", 1, "Client.log" );
	//CRNetApp::registerNetPacket();
	CRNet::crNetWorkUpdater::getInstance()->start();
}
/////////////////////////////////////////
//
//crFiniNetMethod
//
/////////////////////////////////////////
crFiniNetMethod::crFiniNetMethod(){}
crFiniNetMethod::crFiniNetMethod(const crFiniNetMethod& handle):
crMethod(handle)
{
}
void crFiniNetMethod::inputParam(int i, void *param)
{
}

void crFiniNetMethod::addParam(int i, const std::string& str)
{
}

void crFiniNetMethod::operator()(crHandle &handle)
{
	//关闭网络线程
	CRNet::crNetWorkReconnecter::getInstance()->clear();
	CRNet::crNetWorkUpdater::getInstance()->clear();
	CRNet::crNetBridge::shutdownGame();

	CRNet::crNetContainer::getInstance()->clear();
	//CRCore::crBrain::getInstance()->clear();
	//CRAL::crSoundManager::instance()->loadSound("script/sound0.cfg");
	//crBrain::getInstance()->pushInstance(CRAL::crSoundManager::instance());
}
/////////////////////////////////////////
//
//crConnectToLoginServerNewMethod
//
/////////////////////////////////////////
crConnectToLoginServerNewMethod::crConnectToLoginServerNewMethod(){}
crConnectToLoginServerNewMethod::crConnectToLoginServerNewMethod(const crConnectToLoginServerNewMethod& handle):
crMethod(handle),
m_userNameWidget(handle.m_userNameWidget),
m_userPasswordWidget(handle.m_userPasswordWidget)
{
}
void crConnectToLoginServerNewMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crConnectToLoginServerNewMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	}
}

void crConnectToLoginServerNewMethod::operator()(crHandle &handle)
{
	bool sucess = false;
	{
		int serverid = 1;
		CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
		std::string file = "Client.cfg";
		rcfg::ConfigScript cfg_script;
		if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
		{
			CRCore::notify(CRCore::FATAL)<<"crConnectToLoginServerNewMethod(): file open error,"<<file<<std::endl;
			handle.outputParam(0,&sucess);
			return;
		}
		std::string keyStr = "LoginConnectServer";
		std::string callback = "LoginConnectServer";
		std::string serverName = "LoginConnectServer";
		std::string serverPassword = "LoginConnectServer";
		std::string ip;
		int port = DEFAULTPORT;
		int bufSizeScale = 1;
		std::set<int> ServerIDSet;
		std::vector<int> RndIDVec;
		std::set<int>::iterator sitr;
		int i = 0;
		int serverCount = crGlobalHandle::gData()->gLoginConnectCount();
		for(i=1; i<=serverCount; i++)
		{
			ServerIDSet.insert(i);
		}
		CRCore::rangei rnd;
		while(!ServerIDSet.empty())
		{
			rnd.set(0,ServerIDSet.size()-1);
			int id = rnd.get_random();
			i = 0;
			for(  sitr = ServerIDSet.begin();
				sitr != ServerIDSet.end() && i<id;
				++sitr );

			RndIDVec.push_back(*sitr);
			ServerIDSet.erase(sitr);
		}
		for( std::vector<int>::iterator itr = RndIDVec.begin(); 
			itr != RndIDVec.end();
			++itr )
		{
			serverid = *itr;
			keyStr = "LoginConnectServer" + crArgumentParser::appItoa(serverid);
			cfg_script.Push(keyStr);
			cfg_script.Get("NetCallbackString", callback);
			cfg_script.Get("ServerName", serverName);
			cfg_script.Get("ServerPassword", serverPassword);
			cfg_script.Get("IP", ip);
			cfg_script.Get("Port", port);
			cfg_script.Get("BufSizeScale", bufSizeScale);
			if (!cfg_script.Pop())
				CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;

			netConductor->init(port);
			netConductor->setNetType(CRNetApp::GameClient_Login);
			netConductor->setName("GameClient_Login");
			netConductor->setEnableCook(true);
			crBlockDetectThread::getInstance()->pause();
			int code = 0;
			if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
				code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale);
			else
				code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale,10);
			crBlockDetectThread::getInstance()->resume();
			if(code<=0)
			{
				switch (code)
				{
				case 0:
					//无法创建客户端
					CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
					break;
				case -1:
					//超出服务器连接人数限制
					CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
					break;
				case -2:
					//同名客户端已经存在
					CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
					break;
				case -3:
					//要求连接的服务端名字与本服务器名不同
					CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
					break;
				case -4:
					//服务器密码不正确
					CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
					break;
				default:
					CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
				}
				//可在此处doModal一个error对话框
			}
			else
			{
				sucess = true;
				break;
			}
		}
		if(sucess)
		{
			CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
			//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;
		}
	}
	handle.outputParam(0,&sucess);
}
/////////////////////////////////////////
//
//crLoginMethod
//
/////////////////////////////////////////
crLoginMethod::crLoginMethod(){}
crLoginMethod::crLoginMethod(const crLoginMethod& handle):
	crMethod(handle),
	m_userNameWidget(handle.m_userNameWidget),
	m_userPasswordWidget(handle.m_userPasswordWidget)
{
}
void crLoginMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crLoginMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	}
}
void crLoginMethod::operator()(crHandle &handle)
{
	std::string userName;
	std::string userPassword;
	crCanvasNode *canvas = m_this->getParentCanvas();

	ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userNameWidget));
	if(nameWidget.valid())
	{
		userName = crArgumentParser::trim(const_cast<char *>(nameWidget->getUTF8String().c_str()));
	}
	ref_ptr<crEditWidgetNode> passwordWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userPasswordWidget));
	if(passwordWidget.valid())
	{
		userPassword = crArgumentParser::trim(const_cast<char *>(passwordWidget->getUTF8String().c_str()));
		passwordWidget->clearString();
	}

	if(userName.empty()||userPassword.empty())
	{
		CRCore::notify(CRCore::FATAL)<<"Name或者Password不能为空"<<std::endl;
		return;
	}
	crLoginPacket packet;
	crLoginPacket::buildRequestPacket(packet,userName,userPassword);
	CRNet::crNetConductor* netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crRegisterAccountMethod
//
/////////////////////////////////////////
crRegisterAccountMethod::crRegisterAccountMethod(){}
crRegisterAccountMethod::crRegisterAccountMethod(const crRegisterAccountMethod& handle):
	crMethod(handle),
	m_userNameWidget(handle.m_userNameWidget),
	m_userPasswordWidget(handle.m_userPasswordWidget),
	m_password2Widget(handle.m_password2Widget),
	m_emailWidget(handle.m_emailWidget),
	m_cdkeyWidget(handle.m_cdkeyWidget)
{
}
void crRegisterAccountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crRegisterAccountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	case 2:
		m_password2Widget = str;
		break;
	case 3:
		m_emailWidget = str;
		break;
	case 4:
		m_cdkeyWidget = str;
		break;
	}
}
void crRegisterAccountMethod::operator()(crHandle &handle)
{		
	std::string userName;
	std::string userPassword;
	crCanvasNode *canvas = m_this->getParentCanvas();

	ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userNameWidget));
	if(nameWidget.valid())
	{
		userName = nameWidget->getUTF8String();
	}
	ref_ptr<crEditWidgetNode> passwordWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userPasswordWidget));
	if(passwordWidget.valid())
	{
		userPassword = passwordWidget->getUTF8String();
		passwordWidget->clearString();
	}
	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	std::wstring notice;
	if(userName.empty()||userPassword.empty())
	{
		/*CRCore::notify(CRCore::FATAL)<<"Name或者Password不能为空"<<std::endl;
		if(noticeText)
		{
		notice = L"帐号或者密码不能为空";
		noticeText->setText(notice.c_str());
		noticeText->setVisiable(true);
		}*/
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1,NULL));
		return;
	}
	ref_ptr<crEditWidgetNode> password2Widget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password2Widget));
	if(password2Widget.valid())
	{
		std::string password2 = password2Widget->getUTF8String();
		password2Widget->clearString();
		if(password2.compare(userPassword) != 0)
		{
			/*if(noticeText)
			{
			notice = L"2次输入密码不一致";
			noticeText->setText(notice.c_str());
			noticeText->setVisiable(true);
			}*/
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2,NULL));
			return;
		}
	}
	ref_ptr<crEditWidgetNode> emailWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_emailWidget));
	std::string email;
	if(emailWidget.valid())
	{
		email = emailWidget->getUTF8String();
		if(email.empty())
		{
			/*if(noticeText)
			{
			notice = L"Email不能为空";
			noticeText->setText(notice.c_str());
			noticeText->setVisiable(true);
			}*/
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(3,NULL));
			return;
		}
		else if(email.find('@')==std::string::npos)
		{
			//if(noticeText)
			//{
			//	notice = L"请输入正确的Email";
			//	noticeText->setText(notice.c_str());
			//	noticeText->setVisiable(true);
			//}
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(4,NULL));
			return;
		}
	}
	ref_ptr<crEditWidgetNode> codeWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_cdkeyWidget));
	std::string code;
	if(codeWidget.valid())
	{
		code = codeWidget->getUTF8String();
		if(code.empty())
		{
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(31,NULL));
			return;
		}
		else if(code.size()<10)
		{
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(32,NULL));
			return;
		}
	}
	std::string nickname,relname;
	crRegisterAccountPacket packet;
	crRegisterAccountPacket::buildRequestPacket(packet,userName,userPassword,email,nickname,relname,0,code);
	CRNet::crNetConductor* netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crConnectToLoginServerNew2Method
//
/////////////////////////////////////////
crConnectToLoginServerNew2Method::crConnectToLoginServerNew2Method():
m_serverCount(1){}
crConnectToLoginServerNew2Method::crConnectToLoginServerNew2Method(const crConnectToLoginServerNew2Method& handle):
crMethod(handle),
m_userNameWidget(handle.m_userNameWidget),
m_userPasswordWidget(handle.m_userPasswordWidget),
m_serverCount(handle.m_serverCount),
m_password2Widget(handle.m_password2Widget),
m_emailWidget(handle.m_emailWidget)
{
}
void crConnectToLoginServerNew2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crConnectToLoginServerNew2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	case 2:
		m_serverCount = atoi(str.c_str());
		break;
	case 3:
		m_password2Widget = str;
		break;
	case 4:
		m_emailWidget = str;
		break;
	}
}

void crConnectToLoginServerNew2Method::operator()(crHandle &handle)
{
	bool sucess = false;
	{
		std::string userName;
		std::string userPassword;
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();

		ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userNameWidget));
		if(nameWidget.valid())
		{
			userName = nameWidget->getUTF8String();
		}
		ref_ptr<crEditWidgetNode> passwordWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userPasswordWidget));
		if(passwordWidget.valid())
		{
			userPassword = passwordWidget->getUTF8String();
		}
		//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
		std::wstring notice;
		if(userName.empty()||userPassword.empty())
		{
			//CRCore::notify(CRCore::FATAL)<<"Name或者Password不能为空"<<std::endl;
			//if(noticeText)
			//{
			//	notice = L"帐号或者密码不能为空";
			//	noticeText->setText(notice.c_str());
			//	noticeText->setVisiable(true);
			//}
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1,NULL));
			handle.outputParam(0,&sucess);
			return;
		}
		ref_ptr<crEditWidgetNode> password2Widget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password2Widget));
		if(password2Widget.valid())
		{
			std::string password2 = password2Widget->getUTF8String();
			if(password2.compare(userPassword) != 0)
			{
				/*if(noticeText)
				{
				notice = L"2次输入密码不一致";
				noticeText->setText(notice.c_str());
				noticeText->setVisiable(true);
				}*/
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2,NULL));
				handle.outputParam(0,&sucess);
				return;
			}
		}
		ref_ptr<crEditWidgetNode> emailWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_emailWidget));
		std::string email;
		if(emailWidget.valid())
		{
			email = emailWidget->getUTF8String();
			if(email.empty())
			{
				/*if(noticeText)
				{
				notice = L"Email不能为空";
				noticeText->setText(notice.c_str());
				noticeText->setVisiable(true);
				}*/
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(3,NULL));
				handle.outputParam(0,&sucess);
				return;
			}
			else if(email.find('@')==std::string::npos)
			{
				/*if(noticeText)
				{
				notice = L"请输入正确的Email";
				noticeText->setText(notice.c_str());
				noticeText->setVisiable(true);
				}*/
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(4,NULL));
				handle.outputParam(0,&sucess);
				return;
			}
		}

		std::string keyStr = "LoginConnectServer" + crArgumentParser::appItoa(1);
		std::string callback = "LoginConnectServer";
		std::string serverName = keyStr;
		std::string serverPassword = keyStr;
		std::string ip;
		int port = DEFAULTPORT;
		int bufSizeScale = 1;

		std::string file = "Client.cfg";
		rcfg::ConfigScript cfg_script;
		if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
		{
			CRCore::notify(CRCore::FATAL)<<"crConnectToLoginServerNew2Method(): file open error,"<<file<<std::endl;
			return;
		}
		cfg_script.Push(keyStr);
		cfg_script.Get("NetCallbackString", callback);
		cfg_script.Get("ServerName", serverName);
		cfg_script.Get("ServerPassword", serverPassword);
		cfg_script.Get("IP", ip);
		cfg_script.Get("Port", port);
		cfg_script.Get("BufSizeScale", bufSizeScale);
		if (!cfg_script.Pop())
			CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;

		CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
		netConductor->init(port);
		netConductor->setNetType(CRNetApp::GameClient_Login);
		netConductor->setName("GameClient_Login");
		netConductor->setEnableCook(true);
		crBlockDetectThread::getInstance()->pause();
		int code = 0;
		if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
			code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale);
		else
			code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale,10);
		crBlockDetectThread::getInstance()->resume();
		if(code<=0)
		{
			switch (code)
			{
			case 0:
				//无法创建客户端
				CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
				break;
			case -1:
				//超出服务器连接人数限制
				CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
				break;
			case -2:
				//同名客户端已经存在
				CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
				break;
			case -3:
				//要求连接的服务端名字与本服务器名不同
				CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
				break;
			case -4:
				//服务器密码不正确
				CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
				break;
			default:
				CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
			}
			//可在此处doModal一个error对话框
			sucess = false;
			handle.outputParam(0,&sucess);
			return;
		}
		CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
		//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;

		std::string nickname,relname,code1;
		crRegisterAccountPacket packet;
		crRegisterAccountPacket::buildRequestPacket(packet,userName,userPassword,email,nickname,relname,0,code1);
		netConductor->getNetManager()->sendPacket("all",packet);
		sucess = true;
	}
	handle.outputParam(0,&sucess);
}
///////////////////////////////////////////
////
////crConnectToDownloadServerMethod
////
///////////////////////////////////////////
//crConnectToDownloadServerMethod::crConnectToDownloadServerMethod():
//	m_flg(0)
//{
//}
//crConnectToDownloadServerMethod::crConnectToDownloadServerMethod(const crConnectToDownloadServerMethod& handle):
//crMethod(handle),
//m_flg(handle.m_flg)
//{
//}
//void crConnectToDownloadServerMethod::inputParam(int i, void *param)
//{
//}
//void crConnectToDownloadServerMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_flg = (char)(atoi(str.c_str()));
//		break;
//	}
//}
//void crConnectToDownloadServerMethod::operator()(crHandle &handle)
//{
//	bool sucess = false;
//	std::string keyStr = "DownloadConnectServer1";
//	std::string callback = "DownloadConnectServer";
//	std::string serverName = keyStr;
//	std::string serverPassword = keyStr;
//	std::string ip;
//	int port = DEFAULTPORT;
//	int bufSizeScale = 1;
//
//	//const std::string& userName = crMyPlayerData::getInstance()->getPlayerName();
//	int playerid = crMyPlayerData::getInstance()->getPlayerID();
//
//	std::string file = "Client.cfg";
//	rcfg::ConfigScript cfg_script;
//	if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
//	{
//		CRCore::notify(CRCore::FATAL)<<"crConnectToDownloadServerMethod(): file open error,"<<file<<std::endl;
//		handle.outputParam(0,&sucess);
//		return;
//	}
//
//	int servercount = 1;
//	cfg_script.Get("DownloadConnectServerCount", servercount);
//	int serverid = CRCore::rangei(1,servercount).get_random();
//    keyStr = "DownloadConnectServer" + crArgumentParser::appItoa(serverid);
//
//	cfg_script.Push(keyStr);
//	cfg_script.Get("NetCallbackString", callback);
//	cfg_script.Get("ServerName", serverName);
//	cfg_script.Get("ServerPassword", serverPassword);
//	cfg_script.Get("IP", ip);
//	cfg_script.Get("Port", port);
//	cfg_script.Get("BufSizeScale", bufSizeScale);
//	if (!cfg_script.Pop())
//		CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;
//
//	CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
//	netConductor->init(port);
//	netConductor->setNetType(CRNetApp::GameClient_Download);
//	netConductor->setName("GameClient_Download");
//	netConductor->setEnableCook(true);
//	crBlockDetectThread::getInstance()->pause();
//	int code = 0;
//	if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
//		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale);
//	else
//		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,10);
//	//int code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,5);
//	crBlockDetectThread::getInstance()->resume();
//	if(code<=0)
//	{
//		switch (code)
//		{
//		case 0:
//			//无法创建客户端
//			CRCore::notify(CRCore::FATAL)<<"无法连接至"<<serverName<<std::endl;
//			break;
//		case -1:
//			//超出服务器连接人数限制
//			CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
//			break;
//		case -2:
//			//同名客户端已经存在
//			CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
//			break;
//		case -3:
//			//要求连接的服务端名字与本服务器名不同
//			CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
//			break;
//		case -4:
//			//服务器密码不正确
//			CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
//			break;
//		default:
//			CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
//		}
//		//可在此处doModal一个error对话框
//		handle.outputParam(0,&sucess);
//		return;
//	}
//	CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
//	//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;
//
//	crLoginDownloadPacket packet;
//	//crLoginDownloadPacket::s_success = 0;
//	crLoginDownloadPacket::buildRequestPacket(packet,m_flg);
//	netConductor->getNetManager()->sendPacket("all",packet);
//	//int waittime = 0;
//	//while(crLoginDownloadPacket::s_success==0 && waittime<10000)
//	//{
//	//	CRCore::crThread::sleep(100);
//	//	waittime += 100;
//	//}
//	//sucess = crLoginDownloadPacket::s_success>0;
//	sucess = true;
//	handle.outputParam(0,&sucess);
//}
///////////////////////////////////////////
////
////crDisconnectDownloadServerMethod
////
///////////////////////////////////////////
//crDisconnectDownloadServerMethod::crDisconnectDownloadServerMethod(){}
//crDisconnectDownloadServerMethod::crDisconnectDownloadServerMethod(const crDisconnectDownloadServerMethod& handle):
//crMethod(handle)
//{
//}
//void crDisconnectDownloadServerMethod::inputParam(int i, void *param)
//{
//}
//void crDisconnectDownloadServerMethod::addParam(int i, const std::string& str)
//{
//}
//void crDisconnectDownloadServerMethod::operator()(crHandle &handle)
//{
//	crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Download);
//}
///////////////////////////////////////////
////
////crLoginGameDownloadServerMethod
////
///////////////////////////////////////////
//crLoginGameDownloadServerMethod::crLoginGameDownloadServerMethod(){}
//crLoginGameDownloadServerMethod::crLoginGameDownloadServerMethod(const crLoginGameDownloadServerMethod& handle):
//crMethod(handle)
//{
//}
//void crLoginGameDownloadServerMethod::inputParam(int i, void *param)
//{
//}
//void crLoginGameDownloadServerMethod::addParam(int i, const std::string& str)
//{
//}
//void crLoginGameDownloadServerMethod::operator()(crHandle &handle)
//{
//	crLoginDownloadPacket packet;
//	//crLoginDownloadPacket::s_success = 0;
//	crLoginDownloadPacket::buildRequestPacket(packet);
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	netConductor->getNetManager()->sendPacket("all",packet);
//	//int waittime = 0;
//	//while(crLoginDownloadPacket::s_success==0 && waittime<10000)
//	//{
//	//	CRCore::crThread::sleep(100);
//	//	waittime += 100;
//	//}
//	//bool sucess = crLoginDownloadPacket::s_success>0;
//	//handle.outputParam(0,&sucess);
//}
/////////////////////////////////////////
//
//crLoginGameSceneMethod
//
/////////////////////////////////////////
crLoginGameSceneMethod::crLoginGameSceneMethod(){}
crLoginGameSceneMethod::crLoginGameSceneMethod(const crLoginGameSceneMethod& handle):
crMethod(handle)
{
}
void crLoginGameSceneMethod::inputParam(int i, void *param)
{
}
void crLoginGameSceneMethod::addParam(int i, const std::string& str)
{
}
void crLoginGameSceneMethod::operator()(crHandle &handle)
{
	//crQuerySceneInfoData *sceneInfo = crMyPlayerData::getInstance()->getSceneInfoData();
	//if(sceneInfo)
	//{
	//	crMyPlayerData::getInstance()->setLoginGameSceneMode(0);
	//	crLoginScenePacket packet;
	//	crLoginScenePacket::buildRequestPacket(packet,sceneInfo->getSceneID());
	//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	//	netConductor->getNetManager()->sendPacket("all",packet);
	//}
}
/////////////////////////////////////////
//
//crLoginGameScene2Method
//
/////////////////////////////////////////
crLoginGameScene2Method::crLoginGameScene2Method(){}
crLoginGameScene2Method::crLoginGameScene2Method(const crLoginGameScene2Method& handle):
	crMethod(handle)
{
}
void crLoginGameScene2Method::inputParam(int i, void *param)
{
}

void crLoginGameScene2Method::addParam(int i, const std::string& str)
{
}

void crLoginGameScene2Method::operator()(crHandle &handle)
{
	//crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	//if(room)
	//{
	//	crWaitNetReturnStreamLogic::getLock();
	//	crMyPlayerData::getInstance()->setLoginGameSceneMode(1);
	//	crLoginScenePacket packet;
	//	crLoginScenePacket::buildRequestPacket(packet,room->getSceneID());
	//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	//	netConductor->getNetManager()->sendPacket("all",packet);
	//}
}
/////////////////////////////////////////
//
//crDisconnectGameServerMethod
//
/////////////////////////////////////////
crDisconnectGameServerMethod::crDisconnectGameServerMethod(){}
crDisconnectGameServerMethod::crDisconnectGameServerMethod(const crDisconnectGameServerMethod& handle):
crMethod(handle)
{
}
void crDisconnectGameServerMethod::inputParam(int i, void *param)
{
}
void crDisconnectGameServerMethod::addParam(int i, const std::string& str)
{
}
void crDisconnectGameServerMethod::operator()(crHandle &handle)
{
	crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Game);
}
/////////////////////////////////////////
//
//crLoginChatMethod
//
/////////////////////////////////////////
crLoginChatMethod::crLoginChatMethod():
m_serverid(1){}
crLoginChatMethod::crLoginChatMethod(const crLoginChatMethod& handle):
crMethod(handle),
m_serverid(handle.m_serverid)
{
}
void crLoginChatMethod::inputParam(int i, void *param)
{
}

void crLoginChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_serverid = atoi(str.c_str());
		break;
	}
}

void crLoginChatMethod::operator()(crHandle &handle)
{
	bool sucess = false;
	std::string keyStr = "ChatConnectServer" + crArgumentParser::appItoa(m_serverid);
	std::string callback = "ChatConnectServer";
	std::string serverName = keyStr;
	std::string serverPassword = keyStr;
	std::string ip;
	int port = DEFAULTPORT;
    int bufSizeScale = 1;

	//const std::string& userName = crMyPlayerData::getInstance()->getPlayerName();
	int playerid = crMyPlayerData::getInstance()->getPlayerID();
	std::string file = "Client.cfg";
	rcfg::ConfigScript cfg_script;
	if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
	{
		CRCore::notify(CRCore::FATAL)<<"crLoginChatMethod(): file open error,"<<file<<std::endl;
		handle.outputParam(0,&sucess);
		return;
	}
	cfg_script.Push(keyStr);
	cfg_script.Get("NetCallbackString", callback);
	cfg_script.Get("ServerName", serverName);
	cfg_script.Get("ServerPassword", serverPassword);
	cfg_script.Get("IP", ip);
	cfg_script.Get("Port", port);
	cfg_script.Get("BufSizeScale", bufSizeScale);

	if (!cfg_script.Pop())
		CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;

	CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
	netConductor->init(port);
	netConductor->setNetType(CRNetApp::GameClient_Chat);
	netConductor->setName("GameClient_Chat");
	netConductor->setEnableCook(true);
	crBlockDetectThread::getInstance()->pause();
	int code = 0;
	if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale);
	else
		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,10);
	//int code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,5);
	crBlockDetectThread::getInstance()->resume();
	if(code<=0)
	{
		switch (code)
		{
		case 0:
			//无法创建客户端
			CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
			break;
		case -1:
			//超出服务器连接人数限制
			CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
			break;
		case -2:
			//同名客户端已经存在
			CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
			break;
		case -3:
			//要求连接的服务端名字与本服务器名不同
			CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
			break;
		case -4:
			//服务器密码不正确
			CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
			break;
		default:
			CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
		}
		//可在此处doModal一个error对话框
		sucess = false;
		handle.outputParam(0,&sucess);
		return;
	}
	CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
	//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;

	//crLoginChatPacket packet;
	//crLoginChatPacket::s_success = 0;
	//crLoginChatPacket::buildRequestPacket(packet);
	//netConductor->getNetManager()->sendPacket("all",packet);
	//int waittime = 0;
	//while(crLoginChatPacket::s_success==0 && waittime<10000)
	//{
	//	CRCore::crThread::sleep(100);
	//	waittime += 100;
	//}
	//sucess = crLoginChatPacket::s_success>0;

	crLoginChatPacket packet;
	crLoginChatPacket::buildRequestPacket(packet);
	netConductor->getNetManager()->sendPacket("all",packet);
	sucess = true;
	handle.outputParam(0,&sucess);
}

/////////////////////////////////////////
//
//crRecvChatFriendListMethod
//
/////////////////////////////////////////
crRecvChatFriendListMethod::crRecvChatFriendListMethod(){}
crRecvChatFriendListMethod::crRecvChatFriendListMethod(const crRecvChatFriendListMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvChatFriendListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvChatFriendListMethod::addParam(int i, const std::string& str)
{
}

void crRecvChatFriendListMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
		crNetChatData *netChatData = myPlayerData->getMyChatData();
		if(!netChatData)
		{
			netChatData = new crNetChatData;
			myPlayerData->setMyChatData(netChatData);
		}

		netChatData->clearFriendMap();
		CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
		if(stream)
		{
			crNetChatData::crChatFriend *chatFriend;
			while(!stream->eof())
			{
				chatFriend = new crNetChatData::crChatFriend;
				chatFriend->setID(stream->_readInt());
				chatFriend->setPlayerID(stream->_readInt());
				chatFriend->setColumnName(stream->_readString());
                chatFriend->setRemark(stream->_readString());
				chatFriend->setFriendChatState(stream->_readChar());
				chatFriend->setNickName(stream->_readString());

				netChatData->insertFriend(chatFriend);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvChatGroupListMethod
//
/////////////////////////////////////////
crRecvChatGroupListMethod::crRecvChatGroupListMethod(){}
crRecvChatGroupListMethod::crRecvChatGroupListMethod(const crRecvChatGroupListMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvChatGroupListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvChatGroupListMethod::addParam(int i, const std::string& str)
{
}

void crRecvChatGroupListMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
		crNetChatData *netChatData = myPlayerData->getMyChatData();
		if(!netChatData)
		{
			netChatData = new crNetChatData;
			myPlayerData->setMyChatData(netChatData);
		}

		netChatData->clearGroupMap();
		CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
		if(stream)
		{
			crNetChatData::crChatGroup *chatGroup;
			while(!stream->eof())
			{
				chatGroup = new crNetChatData::crChatGroup;
				chatGroup->setID(stream->_readInt());
				chatGroup->setGroupID(stream->_readInt());
				chatGroup->setGroupRemark(stream->_readString());
				chatGroup->setGroupName(stream->_readString());
				chatGroup->setCreator(stream->_readInt());
				chatGroup->setManager1(stream->_readInt());
				chatGroup->setManager2(stream->_readInt());
				chatGroup->setManager3(stream->_readInt());

				netChatData->insertChatGroup(chatGroup);
			}
		}
	}
}

/////////////////////////////////////////
//
//crRecvChatGroupMemberListMethod
//
/////////////////////////////////////////
crRecvChatGroupMemberListMethod::crRecvChatGroupMemberListMethod(){}
crRecvChatGroupMemberListMethod::crRecvChatGroupMemberListMethod(const crRecvChatGroupMemberListMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvChatGroupMemberListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvChatGroupMemberListMethod::addParam(int i, const std::string& str)
{
}

void crRecvChatGroupMemberListMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
		crNetChatData *netChatData = myPlayerData->getMyChatData();
		if(netChatData)
		{
			CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
			if(stream)
			{
				int playergroupid = stream->_readInt();
                crNetChatData::crChatGroup *chatGroup = netChatData->getChatGroup(playergroupid);
				if(chatGroup)
				{
					crNetChatData::crChatGroupMember *member;
					while(!stream->eof())
					{
						member = new crNetChatData::crChatGroupMember;
						member->setMemberID(stream->_readInt());
						member->setPlayerID(stream->_readInt());
						member->setMemberName(stream->_readString());
						member->setMemberRemark(stream->_readString());
						member->setMemberChatState(stream->_readChar());
						member->setNickName(stream->_readString());

						chatGroup->insertMember(member);
					}
				}
			}
		}
	}
}

///////////////////////////////////////////
////
////crChatDataTransferEndMethod
////
///////////////////////////////////////////
//crChatDataTransferEndMethod::crChatDataTransferEndMethod(){}
//crChatDataTransferEndMethod::crChatDataTransferEndMethod(const crChatDataTransferEndMethod& handle):
//crMethod(handle)
//{
//}
//void crChatDataTransferEndMethod::inputParam(int i, void *param)
//{
//}
//
//void crChatDataTransferEndMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_stageName = str;
//		break;
//	case 1:
//		m_friendTreeElementName = str;
//		break;
//	case 2:
//		m_groupTreeElementName = str;
//		break;
//	}
//}
//
//void crChatDataTransferEndMethod::operator()(crHandle &handle)
//{
//	crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
//	crNetChatData *netChatData = myPlayerData->getMyChatData();
//	if(netChatData)
//	{
//		crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
//		if(stage)
//		{
//			crTreeElement *friendTreeElement = dynamic_cast<crTreeElement *>(stage->getElement(m_friendTreeElementName));
//			if(friendTreeElement)
//			{
//				friendTreeElement->lockTree();
//				ref_ptr<crTreeNode> treeRoot = friendTreeElement->getTreeRootNode();
//				treeRoot->removeAllChild();
//
//				netChatData->lockFriendMap();
//				std::string columnName;
//				std::multimap<std::string, crNetChatData::crChatFriend *> columnChatFriend;
//				crNetChatData::FriendMap &friendMap = netChatData->getFriendMap();
//				for( crNetChatData::FriendMap::iterator itr = friendMap.begin();
//					itr != friendMap.end();
//					++itr )
//				{
//					columnName = itr->second->getColumnName();
//					if(columnName.empty())
//						columnName = "我的好友";
//					columnChatFriend.insert(std::make_pair(columnName,itr->second.get()));
//				}
//				netChatData->unlockFriendMap();
//
//				ref_ptr<crTreeNode> treeNode1,treeNode2;
//				std::string currentColumn;
//				std::string friendTitle;
//				for( std::multimap<std::string, crNetChatData::crChatFriend *>::iterator itr = columnChatFriend.begin();
//					itr != columnChatFriend.end();
//					++itr )
//				{
//					if(currentColumn.compare(itr->first)!=0)
//					{
//						currentColumn = itr->first;
//						treeNode1 = new crTreeNode;
//						treeNode1->setTitle(columnName);
//						treeRoot->addChild(treeNode1.get());
//
//						treeNode1->expand();
//						treeNode1->setRowHeight(treeRoot->getRowHeight());
//						treeNode1->setColumnOffset(treeRoot->getColumnOffset());
//						treeNode1->setElementWidth(treeRoot->getElementWidth());
//						treeNode1->setTextAttribute(crTextAttribute::getTextAttribute("default"));
//					}
//					
//					treeNode2 = new crTreeNode;
//					friendTitle = itr->second->getNickName();
//					if(friendTitle.empty())
//					{
//						friendTitle = CRCore::crArgumentParser::appItoa(itr->second->getPlayerID());
//					}
//					treeNode2->setTitle(friendTitle);
//					treeNode2->setData(itr->second);
//					treeNode1->addChild(treeNode2.get());
//
//					treeNode2->setRowHeight(treeRoot->getRowHeight());
//					treeNode2->setColumnOffset(treeRoot->getColumnOffset());
//					treeNode2->setElementWidth(treeRoot->getElementWidth());
//					switch(itr->second->getFriendChatState())
//					{
//					case crNetChatData::OffLine:
//                        treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOffLine"));
//						break;
//					case crNetChatData::OnLine:
//						treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOnLine"));
//						break;
//					}
//				}
//				friendTreeElement->unlockTree();
//				friendTreeElement->updateData();
//			}
//
//			crTreeElement *groupTreeElement = dynamic_cast<crTreeElement *>(stage->getElement(m_groupTreeElementName));
//			if(groupTreeElement)
//			{
//				groupTreeElement->lockTree();
//				ref_ptr<crTreeNode> treeRoot = groupTreeElement->getTreeRootNode();
//                treeRoot->removeAllChild();
//
//				netChatData->lockGroupMap();
//				ref_ptr<crTreeNode> treeNode1,treeNode2;
//				std::string groupTitle;
//				std::string memberTitle;
//				char membertype = 0;//0表示普通，1表示群主，2表示管理员
//				crNetChatData::ChatGroupMap &chatGroupMap = netChatData->getChatGroupMap();
//				for( crNetChatData::ChatGroupMap::iterator itr = chatGroupMap.begin();
//					itr != chatGroupMap.end();
//					++itr )
//				{
//					groupTitle = itr->second->getGroupName();
//					treeNode1 = new crTreeNode;
//					treeNode1->setTitle(groupTitle);
//					treeNode1->setData(itr->second.get());
//					treeRoot->addChild(treeNode1.get());
//
//					treeNode1->expand();
//					treeNode1->setRowHeight(treeRoot->getRowHeight());
//					treeNode1->setColumnOffset(treeRoot->getColumnOffset());
//					treeNode1->setElementWidth(treeRoot->getElementWidth());
//					treeNode1->setTextAttribute(crTextAttribute::getTextAttribute("default"));
//
//					itr->second->lockMemberMap();
//					crNetChatData::crChatGroup::ChatMemberMap &memberMap = itr->second->getMemberMap();
//					for( crNetChatData::crChatGroup::ChatMemberMap::iterator mitr = memberMap.begin();
//						 mitr != memberMap.end();
//						 ++mitr )
//					{
//						treeNode2 = new crTreeNode;
//						memberTitle = mitr->second->getMemberName();
//						if(memberTitle.empty())
//						{
//							memberTitle = mitr->second->getNickName();
//							if(memberTitle.empty())
//							    memberTitle = CRCore::crArgumentParser::appItoa(mitr->second->getPlayerID());
//						}
//						treeNode2->setTitle(memberTitle);
//						treeNode2->setData(mitr->second.get());
//						treeNode1->addChild(treeNode2.get());
//
//						treeNode2->setRowHeight(treeRoot->getRowHeight());
//						treeNode2->setColumnOffset(treeRoot->getColumnOffset());
//						treeNode2->setElementWidth(treeRoot->getElementWidth());
//
//						switch(mitr->second->getMemberChatState())
//						{
//						case crNetChatData::OffLine:
//							treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOffLine"));
//							break;
//						case crNetChatData::OnLine:
//							treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOnLine"));
//							break;
//						}
//
//						membertype = 0;
//						if(mitr->second->getPlayerID() == itr->second->getCreator())
//						{
//                            membertype = 1;
//						}
//						else if(mitr->second->getPlayerID() == itr->second->getManager1())
//						{
//                            membertype = 2;
//						}
//						else if(mitr->second->getPlayerID() == itr->second->getManager2())
//						{
//                            membertype = 2;
//						}
//						if(mitr->second->getPlayerID() == itr->second->getManager3())
//						{
//                            membertype = 2;
//						}
//
//						if(membertype == 1)
//						{//群主treeNode2显示属性设置
//
//						}
//						else if(membertype == 2)
//						{//群管理员treeNode2显示属性设置
//
//						}
//					}
//					itr->second->unlockMemberMap();
//				}
//				netChatData->unlockGroupMap();
//
//				groupTreeElement->unlockTree();
//				groupTreeElement->updateData();
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crRecvChatStateChangeMethod
//
/////////////////////////////////////////
crRecvChatStateChangeMethod::crRecvChatStateChangeMethod(){}
crRecvChatStateChangeMethod::crRecvChatStateChangeMethod(const crRecvChatStateChangeMethod& handle):
crMethod(handle),
m_chatMain(handle.m_chatMain),
m_friendTreeElement(handle.m_friendTreeElement),
m_chatGroup(handle.m_chatGroup),
m_groupTreeElement(handle.m_groupTreeElement)
{
}
void crRecvChatStateChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvChatStateChangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatMain = str;
		break;
	case 1:
		m_friendTreeElement = str;
		break;
	case 2:
		m_chatGroup = str;
		break;
	case 3:
		m_groupTreeElement = str;
		break;
	}
}

void crRecvChatStateChangeMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		int senderid = m_stream->_readInt();
		int recvid = m_stream->_readInt();
		char chatState = m_stream->_readUChar();
		std::string nickName = m_stream->_readString();
		crNetChatData *myChatData = crMyPlayerData::getInstance()->getMyChatData();
		if(myChatData)
		{
			crNetChatData::crChatFriend *chatFriend;
			crNetChatData::crChatGroupMember *chatMember;

			chatFriend = myChatData->getFriend(senderid);
			if(chatFriend)
			{
				crImageStage *chatMain = cr2DStageManager::getInstance()->findStage(m_chatMain);
				if(chatMain && chatMain->getShow())
				{
					crTreeElement *friendTree = dynamic_cast<crTreeElement *>(chatMain->getElement(m_friendTreeElement));
					if(friendTree)
					{
						friendTree->lockTree();
						std::string columnName = chatFriend->getColumnName();
						if(columnName.empty())
						{
							columnName = "我的好友";
						}
						crTreeNode *columnNode = friendTree->getTreeRootNode()->findChild(columnName);
						if(columnNode)
						{
							crTreeNode *treeNode2 = columnNode->findChildByData(chatFriend);
							if(treeNode2)
							{
								bool needRedraw = false;
								if(nickName.compare(chatFriend->getNickName())!=0)
								{
								    treeNode2->setTitle(nickName);
									needRedraw = true;
								}
								if(chatState != chatFriend->getFriendChatState())
								{
									if(!chatFriend->getHasNewMsg())
									{
										switch(chatState)
										{
										case crNetChatData::OffLine:
											treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("Black15"));
											break;
										case crNetChatData::OnLine:
											treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("Red15"));
											break;
										}
										needRedraw = true;
									}
								}
								if(needRedraw)
								{
									chatMain->setNeedReDraw();
								}
							}
						}
					    friendTree->unlockTree();
					}
				}
				chatFriend->setFriendChatState((crNetChatData::ChatState)chatState);
				chatFriend->setNickName(nickName);
			}
			myChatData->lockGroupMap();
			crNetChatData::ChatGroupMap &chatGroupMap = myChatData->getChatGroupMap();
			for( crNetChatData::ChatGroupMap::iterator cgitr = chatGroupMap.begin();
				cgitr != chatGroupMap.end();
				cgitr++ )
			{
				chatMember = cgitr->second->getMember(senderid);
				if(chatMember)
				{
					chatMember->setMemberChatState(chatState);
					chatMember->setNickName(nickName);
				}
			}
			myChatData->unlockGroupMap();
		}
	}
}
/////////////////////////////////////////
//
//crBuildFriendTreeMethod
//
/////////////////////////////////////////
crBuildFriendTreeMethod::crBuildFriendTreeMethod(){}
crBuildFriendTreeMethod::crBuildFriendTreeMethod(const crBuildFriendTreeMethod& handle):
crMethod(handle)
{
}
void crBuildFriendTreeMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_friendTreeElement = (CRGUI::crTreeElement*)param;
}

void crBuildFriendTreeMethod::addParam(int i, const std::string& str)
{
}

void crBuildFriendTreeMethod::operator()(crHandle &handle)
{
	crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
	crNetChatData *netChatData = myPlayerData->getMyChatData();
	if(netChatData && m_friendTreeElement.valid())
	{
		m_friendTreeElement->lockTree();
		ref_ptr<crTreeNode> treeRoot = m_friendTreeElement->getTreeRootNode();
		treeRoot->removeAllChild();

		netChatData->lockFriendMap();
		std::string columnName;
		std::multimap<std::string, crNetChatData::crChatFriend *> columnChatFriend;
		crNetChatData::FriendMap &friendMap = netChatData->getFriendMap();
		for( crNetChatData::FriendMap::iterator itr = friendMap.begin();
			itr != friendMap.end();
			++itr )
		{
			columnName = itr->second->getColumnName();
			if(columnName.empty())
				columnName = "我的好友";
			columnChatFriend.insert(std::make_pair(columnName,itr->second.get()));
		}
		netChatData->unlockFriendMap();

		ref_ptr<crTreeNode> treeNode1,treeNode2;
		std::string currentColumn;
		std::string friendTitle;
		for( std::multimap<std::string, crNetChatData::crChatFriend *>::iterator itr = columnChatFriend.begin();
			itr != columnChatFriend.end();
			++itr )
		{
			if(currentColumn.compare(itr->first)!=0)
			{
				currentColumn = itr->first;
				treeNode1 = new crTreeNode;
				treeNode1->setTitle(columnName);
				treeRoot->addChild(treeNode1.get());

				treeNode1->expand();
				treeNode1->setRowHeight(treeRoot->getRowHeight());
				treeNode1->setColumnOffset(treeRoot->getColumnOffset());
				treeNode1->setElementWidth(treeRoot->getElementWidth());
				treeNode1->setTextAttribute(crTextAttribute::getTextAttribute("Red15"));
			}

			treeNode2 = new crTreeNode;
			friendTitle = itr->second->getNickName();
			if(friendTitle.empty())
			{
				friendTitle = CRCore::crArgumentParser::appItoa(itr->second->getPlayerID());
			}
			treeNode2->setTitle(friendTitle);
			treeNode2->setData(itr->second);
			treeNode1->addChild(treeNode2.get());

			treeNode2->setRowHeight(treeRoot->getRowHeight());
			treeNode2->setColumnOffset(treeRoot->getColumnOffset());
			treeNode2->setElementWidth(treeRoot->getElementWidth());
			if(itr->second->getHasNewMsg())
			{
                treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("Blue15"));
			}
			else
			{
				switch(itr->second->getFriendChatState())
				{
				case crNetChatData::OffLine:
					treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("Black15"));
					break;
				case crNetChatData::OnLine:
					treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("Red15"));
					break;
				}
			}
		}
		m_friendTreeElement->unlockTree();
		m_friendTreeElement->updateData();
	}
}
/////////////////////////////////////////
//
//crBuildGroupTreeMethod
//
/////////////////////////////////////////
crBuildGroupTreeMethod::crBuildGroupTreeMethod(){}
crBuildGroupTreeMethod::crBuildGroupTreeMethod(const crBuildGroupTreeMethod& handle):
crMethod(handle)
{
}
void crBuildGroupTreeMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_groupTreeElement = (CRGUI::crTreeElement*)param;
}

void crBuildGroupTreeMethod::addParam(int i, const std::string& str)
{
}

void crBuildGroupTreeMethod::operator()(crHandle &handle)
{
	crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
	crNetChatData *netChatData = myPlayerData->getMyChatData();
	if(netChatData && m_groupTreeElement.valid())
	{
		m_groupTreeElement->lockTree();
		ref_ptr<crTreeNode> treeRoot = m_groupTreeElement->getTreeRootNode();
		treeRoot->removeAllChild();

		netChatData->lockGroupMap();
		ref_ptr<crTreeNode> treeNode1,treeNode2;
		std::string groupTitle;
		std::string memberTitle;
		char membertype = 0;//0表示普通，1表示群主，2表示管理员
		crNetChatData::ChatGroupMap &chatGroupMap = netChatData->getChatGroupMap();
		for( crNetChatData::ChatGroupMap::iterator itr = chatGroupMap.begin();
			itr != chatGroupMap.end();
			++itr )
		{
			groupTitle = itr->second->getGroupName();
			treeNode1 = new crTreeNode;
			treeNode1->setTitle(groupTitle);
			treeNode1->setData(itr->second.get());
			treeRoot->addChild(treeNode1.get());

			treeNode1->expand();
			treeNode1->setRowHeight(treeRoot->getRowHeight());
			treeNode1->setColumnOffset(treeRoot->getColumnOffset());
			treeNode1->setElementWidth(treeRoot->getElementWidth());
			treeNode1->setTextAttribute(crTextAttribute::getTextAttribute("default"));

			itr->second->lockMemberMap();
			crNetChatData::crChatGroup::ChatMemberMap &memberMap = itr->second->getMemberMap();
			for( crNetChatData::crChatGroup::ChatMemberMap::iterator mitr = memberMap.begin();
				mitr != memberMap.end();
				++mitr )
			{
				treeNode2 = new crTreeNode;
				memberTitle = mitr->second->getMemberName();
				if(memberTitle.empty())
				{
					memberTitle = mitr->second->getNickName();
					if(memberTitle.empty())
						memberTitle = CRCore::crArgumentParser::appItoa(mitr->second->getPlayerID());
				}
				treeNode2->setTitle(memberTitle);
				treeNode2->setData(mitr->second.get());
				treeNode1->addChild(treeNode2.get());

				treeNode2->setRowHeight(treeRoot->getRowHeight());
				treeNode2->setColumnOffset(treeRoot->getColumnOffset());
				treeNode2->setElementWidth(treeRoot->getElementWidth());

				switch(mitr->second->getMemberChatState())
				{
				case crNetChatData::OffLine:
					treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOffLine"));
					break;
				case crNetChatData::OnLine:
					treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOnLine"));
					break;
				}

				membertype = 0;
				if(mitr->second->getPlayerID() == itr->second->getCreator())
				{
					membertype = 1;
				}
				else if(mitr->second->getPlayerID() == itr->second->getManager1())
				{
					membertype = 2;
				}
				else if(mitr->second->getPlayerID() == itr->second->getManager2())
				{
					membertype = 2;
				}
				if(mitr->second->getPlayerID() == itr->second->getManager3())
				{
					membertype = 2;
				}

				if(membertype == 1)
				{//群主treeNode2显示属性设置

				}
				else if(membertype == 2)
				{//群管理员treeNode2显示属性设置

				}
			}
			itr->second->unlockMemberMap();
		}
		netChatData->unlockGroupMap();

		m_groupTreeElement->unlockTree();
		m_groupTreeElement->updateData();
	}
}

/////////////////////////////////////////
//
//crInfoTextMethod
//
/////////////////////////////////////////
crInfoTextMethod::crInfoTextMethod():m_flg(0){}
crInfoTextMethod::crInfoTextMethod(const crInfoTextMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_infoTextElement(handle.m_infoTextElement),
m_infoText(handle.m_infoText),
m_flg(handle.m_flg)
{
}
void crInfoTextMethod::inputParam(int i, void *param)
{
}

void crInfoTextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_infoTextElement = str;
		break;
	case 2:
		m_infoText = str;
		break;
	case 3:
		m_flg = atoi(str.c_str());
		break;
	}
}

void crInfoTextMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(stage)
	{
		crStaticTextBoxElement *infoElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_infoTextElement));
		if(infoElement)
		{
			if(m_flg==1)
				infoElement->setStringArrayByString(m_infoText);
			else
				infoElement->addString(m_infoText);
			//CRCore::notify(CRCore::ALWAYS)<<"crInfoTextMethod "<<m_infoText<<std::endl;

			stage->setNeedReDraw();
		}
	}
}

/////////////////////////////////////////
//
//crConnectToLoginServer2Method
//
/////////////////////////////////////////
crConnectToLoginServer2Method::crConnectToLoginServer2Method():
m_serverid(1){}
crConnectToLoginServer2Method::crConnectToLoginServer2Method(const crConnectToLoginServer2Method& handle):
crMethod(handle),
m_serverid(handle.m_serverid)
{
}
void crConnectToLoginServer2Method::inputParam(int i, void *param)
{
}

void crConnectToLoginServer2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 1:
		m_serverid = atoi(str.c_str());
		break;
	}
}

void crConnectToLoginServer2Method::operator()(crHandle &handle)
{
	bool sucess = false;
	std::string keyStr = "LoginConnectServer" + crArgumentParser::appItoa(m_serverid);
	std::string callback = "LoginConnectServer";
	std::string serverName = keyStr;
	std::string serverPassword = keyStr;
	std::string ip;
	int port = DEFAULTPORT;
	int bufSizeScale = 1;

	std::string file = "Client.cfg";
	rcfg::ConfigScript cfg_script;
	if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
	{
		CRCore::notify(CRCore::FATAL)<<"crConnectToLoginServer2Method(): file open error,"<<file<<std::endl;
		handle.outputParam(0,&sucess);
		return;
	}
	cfg_script.Push(keyStr);
	cfg_script.Get("NetCallbackString", callback);
	cfg_script.Get("ServerName", serverName);
	cfg_script.Get("ServerPassword", serverPassword);
	cfg_script.Get("IP", ip);
	cfg_script.Get("Port", port);
	cfg_script.Get("BufSizeScale", bufSizeScale);
	if (!cfg_script.Pop())
		CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;

	CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
	netConductor->init(port);
	netConductor->setNetType(CRNetApp::GameClient_Login);
	netConductor->setName("GameClient_Login");
	netConductor->setEnableCook(true);
	crBlockDetectThread::getInstance()->pause();
	int code = 0;
	if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale);
	else
		code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale,10);
	//int code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,0,serverName,serverPassword,port,bufSizeScale,5);
	crBlockDetectThread::getInstance()->resume();
	if(code<=0)
	{
		switch (code)
		{
		case 0:
			//无法创建客户端
			CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
			break;
		case -1:
			//超出服务器连接人数限制
			CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
			break;
		case -2:
			//同名客户端已经存在
			CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
			break;
		case -3:
			//要求连接的服务端名字与本服务器名不同
			CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
			break;
		case -4:
			//服务器密码不正确
			CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
			break;
		default:
			CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
		}
		//可在此处doModal一个error对话框
		sucess = false;
		handle.outputParam(0,&sucess);
		return;
	}
	CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
	//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;

	sucess = true;
	handle.outputParam(0,&sucess);
}

///////////////////////////////////////////
////
////crRegisterAccountMethod
////
///////////////////////////////////////////
//crRegisterAccountMethod::crRegisterAccountMethod(){}
//crRegisterAccountMethod::crRegisterAccountMethod(const crRegisterAccountMethod& handle):
//crMethod(handle),
//m_userNameElement(handle.m_userNameElement),
//m_userPasswordElement(handle.m_userPasswordElement)
//{
//}
//void crRegisterAccountMethod::inputParam(int i, void *param)
//{
//	if(i==0)
//		m_element = (CRGUI::crElement*)param;
//}
//
//void crRegisterAccountMethod::addParam(int i, const std::string& str)
//
//{
//	switch(i) 
//	{
//	case 0:
//		m_userNameElement = str;
//		break;
//	case 1:
//		m_userPasswordElement = str;
//		break;
//	}
//}
//
//void crRegisterAccountMethod::operator()(crHandle &handle)
//{
//	if(m_element.valid())
//	{
//		crImageStage *stage = m_element->getParentStage();
//		if(!stage) return;
//
//		std::string userName,userPassword;
//		crEditBoxElement *name_element = dynamic_cast<crEditBoxElement *>(stage->getElement(m_userNameElement));
//		if(name_element)
//		{
//			userName = name_element->getStringArrayInString();
//		}
//		crEditBoxElement *password_element = dynamic_cast<crEditBoxElement *>(stage->getElement(m_userPasswordElement));
//		if(password_element)
//		{
//			userPassword = password_element->getStringArrayInString();
//		}
//		std::string email,relname;
//		crRegisterAccountPacket packet;
//		crRegisterAccountPacket::buildRequestPacket(packet,userName,userPassword,email,userName,relname,0);
//		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
//		netConductor->getNetManager()->sendPacket("all",packet);
//
//		int waittime = 0;
//		while(crRegisterAccountPacket::s_success==0 && waittime<10000)
//		{
//			CRCore::crThread::sleep(100);
//			waittime += 100;
//		}
//		bool sucess = crRegisterAccountPacket::s_success>0;
//		handle.outputParam(0,&sucess);
//		CRNet::crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Login);
//	}
//}

/////////////////////////////////////////
//
//crQueryOnlinePlayerListMethod
//
/////////////////////////////////////////
crQueryOnlinePlayerListMethod::crQueryOnlinePlayerListMethod(){}
crQueryOnlinePlayerListMethod::crQueryOnlinePlayerListMethod(const crQueryOnlinePlayerListMethod& handle):
crMethod(handle)
{
}
void crQueryOnlinePlayerListMethod::inputParam(int i, void *param)
{
}

void crQueryOnlinePlayerListMethod::addParam(int i, const std::string& str)
{
}

void crQueryOnlinePlayerListMethod::operator()(crHandle &handle)
{
	crQueryOnlinePlayerListPacket packet;
	crQueryOnlinePlayerListPacket::buildRequestPacket(packet,0,100);
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
	netConductor->getNetManager()->sendPacket("all",packet);
}

/////////////////////////////////////////
//
//crOnlinePlayerListMethod
//
/////////////////////////////////////////
crOnlinePlayerListMethod::crOnlinePlayerListMethod(){}
crOnlinePlayerListMethod::crOnlinePlayerListMethod(const crOnlinePlayerListMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crOnlinePlayerListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crOnlinePlayerListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crOnlinePlayerListMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(!stage || !m_stream.valid()) return;

	crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
	if(columnListElement)
	{
		columnListElement->clearData();
		short count = m_stream->_readShort();
		int id;
		std::string nickName;
		std::string address;
		crColumnNode *columnNode;
		for(int i = 0; i<count; i++)
		{
            id = m_stream->_readInt();
			nickName = m_stream->_readString();
			address = m_stream->_readString();
			columnNode = new crColumnNode;
			columnNode->addTitle(CRCore::crArgumentParser::appItoa(id));
			columnNode->addTitle(nickName);
			columnNode->addTitle(address);
			
			columnListElement->addData(columnNode);
		}
		columnListElement->updateData();
	}
}

/////////////////////////////////////////
//
//crAddChatFriendMethod
//
/////////////////////////////////////////
crAddChatFriendMethod::crAddChatFriendMethod(){}
crAddChatFriendMethod::crAddChatFriendMethod(const crAddChatFriendMethod& handle):
crMethod(handle),
m_columnListElement(handle.m_columnListElement)
{
}
void crAddChatFriendMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crAddChatFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListElement = str;
		break;
	}
}

void crAddChatFriendMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
		if(columnListElement)
		{
			int i = columnListElement->getSelect() - 1;
			if(i>=0)
			{
				crColumnNode *selectNode = columnListElement->getData(i);
				if(selectNode)
				{
					std::string id;
					selectNode->getTitle(0,id);
					int playerid = atoi(id.c_str());
					bool found = false;
					crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
					if(netChatData)
					{
						found = netChatData->getFriend(playerid) != NULL;
					}
					if(!found)
					{
						crAddChatFriendPacket packet;
						crAddChatFriendPacket::buildRequestPacket(packet,playerid);
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crInsertToChatFriendTreeMethod
//
/////////////////////////////////////////
crInsertToChatFriendTreeMethod::crInsertToChatFriendTreeMethod():
m_playerid(0){}
crInsertToChatFriendTreeMethod::crInsertToChatFriendTreeMethod(const crInsertToChatFriendTreeMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_friendTreeElementName(handle.m_friendTreeElementName),
m_playerid(0)
{
}
void crInsertToChatFriendTreeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerid = LOINT64(param64);
		}
		else
		{
			m_playerid = 0;
		}
		break;
	}
}

void crInsertToChatFriendTreeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_friendTreeElementName = str;
		break;
	}
}

void crInsertToChatFriendTreeMethod::operator()(crHandle &handle)
{
	crNetChatData *myChatData = crMyPlayerData::getInstance()->getMyChatData();
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(myChatData && stage && stage->getShow() && m_playerid>0)
	{
		crTreeElement *friendTreeElement = dynamic_cast<crTreeElement *>(stage->getElement(m_friendTreeElementName));
		if(friendTreeElement)
		{
			crNetChatData::crChatFriend *chatFriend = myChatData->getFriend(m_playerid);
			if(chatFriend)
			{
				friendTreeElement->lockTree();
				ref_ptr<crTreeNode> treeRoot = friendTreeElement->getTreeRootNode();

				std::string columnName = chatFriend->getColumnName();
				if(columnName.empty()) columnName = "我的好友";
				ref_ptr<crTreeNode>treeNode = treeRoot->findChild(columnName);
				if(!treeNode)
				{
					treeNode = new crTreeNode;
					treeNode->setTitle(columnName);
					treeNode->expand();
					treeNode->setRowHeight(treeRoot->getRowHeight());
					treeNode->setColumnOffset(treeRoot->getColumnOffset());
					treeNode->setElementWidth(treeRoot->getElementWidth());
					treeNode->setTextAttribute(crTextAttribute::getTextAttribute("default"));
					treeRoot->addChild(treeNode.get());
				}
				ref_ptr<crTreeNode>friendNode = new crTreeNode;
				friendNode->setTitle(chatFriend->getNickName());
				friendNode->setData(chatFriend);
				treeNode->addChild(friendNode.get());

				friendNode->setRowHeight(treeRoot->getRowHeight());
				friendNode->setColumnOffset(treeRoot->getColumnOffset());
				friendNode->setElementWidth(treeRoot->getElementWidth());
				switch(chatFriend->getFriendChatState())
				{
				case crNetChatData::OffLine:
					friendNode->setTextAttribute(crTextAttribute::getTextAttribute("ChatOffLine"));
					break;
				case crNetChatData::OnLine:
					friendNode->setTextAttribute(crTextAttribute::getTextAttribute("ChatOnLine"));
					break;
				}

				friendTreeElement->unlockTree();
				friendTreeElement->updateData();

				stage->setNeedReDraw();
			}
		}
	}
}

/////////////////////////////////////////
//
//crCreateChatGroupMethod
//
/////////////////////////////////////////
crCreateChatGroupMethod::crCreateChatGroupMethod(){}
crCreateChatGroupMethod::crCreateChatGroupMethod(const crCreateChatGroupMethod& handle):
crMethod(handle),
m_groupNameElement(handle.m_groupNameElement),
m_groupIntroduceElement(handle.m_groupIntroduceElement)
{
}
void crCreateChatGroupMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crCreateChatGroupMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_groupNameElement = str;
		break;
	case 1:
		m_groupIntroduceElement = str;
		break;
	}
}

void crCreateChatGroupMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		std::string groupName, groupIntroduce;
		crEditBoxElement *groupNameElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_groupNameElement));
		if(groupNameElement)
		{
			groupName = groupNameElement->getStringArrayInString();
		}
		crEditBoxElement *groupIntroduceElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_groupIntroduceElement));
		if(groupIntroduceElement)
		{
			groupIntroduce = groupIntroduceElement->getStringArrayInString();
		}
        if(!groupName.empty())
		{
			crCreateChatGroupPacket packet;
			crCreateChatGroupPacket::buildRequestPacket(packet,groupName,groupIntroduce);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}

/////////////////////////////////////////
//
//crInsertToChatGroupTreeMethod
//
/////////////////////////////////////////
crInsertToChatGroupTreeMethod::crInsertToChatGroupTreeMethod():
m_groupid(0){}
crInsertToChatGroupTreeMethod::crInsertToChatGroupTreeMethod(const crInsertToChatGroupTreeMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_groupTreeElementName(handle.m_groupTreeElementName),
m_groupid(0)
{
}
void crInsertToChatGroupTreeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_groupid = LOINT64(param64);
		}
		else
		{
			m_groupid = 0;
		}
		break;
	}
}

void crInsertToChatGroupTreeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_groupTreeElementName = str;
		break;
	}
}

void crInsertToChatGroupTreeMethod::operator()(crHandle &handle)
{
	crNetChatData *myChatData = crMyPlayerData::getInstance()->getMyChatData();
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(myChatData && stage && m_groupid>0)
	{
		crTreeElement *groupTreeElement = dynamic_cast<crTreeElement *>(stage->getElement(m_groupTreeElementName));
		if(groupTreeElement)
		{
			crNetChatData::crChatGroup *chatGroup = myChatData->findChatGroup(m_groupid);
			if(chatGroup)
			{
				groupTreeElement->lockTree();
				ref_ptr<crTreeNode> treeRoot = groupTreeElement->getTreeRootNode();

				std::string columnName = chatGroup->getGroupName();
				ref_ptr<crTreeNode>treeNode = new crTreeNode;
				treeNode = new crTreeNode;
				treeNode->setTitle(columnName);
				treeNode->expand();
				treeNode->setRowHeight(treeRoot->getRowHeight());
				treeNode->setColumnOffset(treeRoot->getColumnOffset());
				treeNode->setElementWidth(treeRoot->getElementWidth());
				treeNode->setTextAttribute(crTextAttribute::getTextAttribute("default"));

				/////groupmember
				int membertype;
				chatGroup->lockMemberMap();
				ref_ptr<crTreeNode>treeNode2;
				std::string memberTitle;
				crNetChatData::crChatGroup::ChatMemberMap &memberMap = chatGroup->getMemberMap();
				for( crNetChatData::crChatGroup::ChatMemberMap::iterator mitr = memberMap.begin();
					mitr != memberMap.end();
					++mitr )
				{
					treeNode2 = new crTreeNode;
					memberTitle = mitr->second->getMemberName();
					if(memberTitle.empty())
					{
						memberTitle = mitr->second->getNickName();
						if(memberTitle.empty())
							memberTitle = CRCore::crArgumentParser::appItoa(mitr->second->getPlayerID());
					}
					treeNode2->setTitle(memberTitle);
					treeNode2->setData(mitr->second.get());
					treeNode->addChild(treeNode2.get());

					treeNode2->setRowHeight(treeRoot->getRowHeight());
					treeNode2->setColumnOffset(treeRoot->getColumnOffset());
					treeNode2->setElementWidth(treeRoot->getElementWidth());

					switch(mitr->second->getMemberChatState())
					{
					case crNetChatData::OffLine:
						treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOffLine"));
						break;
					case crNetChatData::OnLine:
						treeNode2->setTextAttribute(crTextAttribute::getTextAttribute("ChatOnLine"));
						break;
					}

					membertype = 0;
					if(mitr->second->getPlayerID() == chatGroup->getCreator())
					{
						membertype = 1;
					}
					else if(mitr->second->getPlayerID() == chatGroup->getManager1())
					{
						membertype = 2;
					}
					else if(mitr->second->getPlayerID() == chatGroup->getManager2())
					{
						membertype = 2;
					}
					if(mitr->second->getPlayerID() == chatGroup->getManager3())
					{
						membertype = 2;
					}

					if(membertype == 1)
					{//群主treeNode2显示属性设置

					}
					else if(membertype == 2)
					{//群管理员treeNode2显示属性设置

					}
				}
				chatGroup->unlockMemberMap();

				treeRoot->addChild(treeNode.get());
				groupTreeElement->unlockTree();
				groupTreeElement->updateData();
			}
		}
	}
}

/////////////////////////////////////////
//
//crChatWithFriendMethod
//
/////////////////////////////////////////
crChatWithFriendMethod::crChatWithFriendMethod(){}
crChatWithFriendMethod::crChatWithFriendMethod(const crChatWithFriendMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_titleElement(handle.m_titleElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crChatWithFriendMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_treeElement = (CRGUI::crTreeElement*)param;
}

void crChatWithFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_titleElement = str;
		break;
	case 2:
		m_chatRecElement = str;
		break;
	}
}

void crChatWithFriendMethod::operator()(crHandle &handle)
{
	if(m_treeElement.valid())
	{
        crTreeNode *selectNode = m_treeElement->getSelectNode();
		if(selectNode)
		{
			void *data = selectNode->getData();
			if(data)
			{
				crNetChatData::crChatFriend *chatFriend = (crNetChatData::crChatFriend *)data;
				crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
				crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
				if(stage && chatFriend && netChatData)
				{
					netChatData->setChatTarget(crNetChatData::ChatFriend,chatFriend);
					crStaticTextBoxElement *titleElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_titleElement));
					if(titleElement)
					{
						char title[64];
						sprintf(title,"与 %s 聊天中\0",chatFriend->getNickName().c_str());
						titleElement->setStringArrayByString(title);
					}
					crStaticTextBoxElement *chatRecElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
					if(chatRecElement)
					{
						chatRecElement->lockArray();
						chatFriend->getChatRec(chatRecElement->getStringArray());
						chatRecElement->unLockArray();

						chatRecElement->updateData();
					}
					if(stage->getShow())
					{
						stage->setNeedReDraw();
					}
					else
					{
						cr2DStageManager::getInstance()->showStage(stage,true);
					}
					if(chatFriend->getHasNewMsg())
					{
						switch(chatFriend->getFriendChatState())
						{
						case crNetChatData::OffLine:
							selectNode->setTextAttribute(crTextAttribute::getTextAttribute("Black15"));
							break;
						case crNetChatData::OnLine:
							selectNode->setTextAttribute(crTextAttribute::getTextAttribute("Red15"));
							break;
						}
					}
					chatFriend->setHasNewMsg(false);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crQueryChatGroupListMethod
//
/////////////////////////////////////////
crQueryChatGroupListMethod::crQueryChatGroupListMethod(){}
crQueryChatGroupListMethod::crQueryChatGroupListMethod(const crQueryChatGroupListMethod& handle):
crMethod(handle)
{
}
void crQueryChatGroupListMethod::inputParam(int i, void *param)
{
}

void crQueryChatGroupListMethod::addParam(int i, const std::string& str)
{
}

void crQueryChatGroupListMethod::operator()(crHandle &handle)
{
	crQueryChatGroupListPacket packet;
	crQueryChatGroupListPacket::buildRequestPacket(packet,0,100);
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crChatGroupListMethod
//
/////////////////////////////////////////
crChatGroupListMethod::crChatGroupListMethod(){}
crChatGroupListMethod::crChatGroupListMethod(const crChatGroupListMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crChatGroupListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crChatGroupListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crChatGroupListMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(!stage || !m_stream.valid()) return;

	crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
	if(columnListElement)
	{
		columnListElement->clearData();
		short count = m_stream->_readShort();
		int id;
		std::string groupName;
		int creator;
		crColumnNode *columnNode;
		for(int i = 0; i<count; i++)
		{
			id = m_stream->_readInt();
			groupName = m_stream->_readString();
			creator = m_stream->_readInt();
			columnNode = new crColumnNode;
			columnNode->addTitle(CRCore::crArgumentParser::appItoa(id));
			columnNode->addTitle(groupName);
			columnNode->addTitle(CRCore::crArgumentParser::appItoa(creator));

			columnListElement->addData(columnNode);
		}
		columnListElement->updateData();
	}
}
/////////////////////////////////////////
//
//crSendChatMethod
//
/////////////////////////////////////////
crSendChatMethod::crSendChatMethod(){}
crSendChatMethod::crSendChatMethod(const crSendChatMethod& handle):
crMethod(handle),
m_chatInputElement(handle.m_chatInputElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crSendChatMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSendChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatInputElement = str;
		break;
	case 1:
		m_chatRecElement = str;
		break;
	}
}

void crSendChatMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
		crImageStage *stage = m_element->getParentStage();
		if(stage && netChatData)
		{
			crStaticTextBoxElement *chatRec = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
            crEditBoxElement *chatInput = dynamic_cast<crEditBoxElement *>(stage->getElement(m_chatInputElement));
			if(chatInput && chatRec)
			{
				unsigned char chatTargetType = netChatData->getChatTargetType();
				if(chatTargetType == crNetChatData::ChatFriend)
				{
					crNetChatData::crChatFriend *chatFriend = dynamic_cast<crNetChatData::crChatFriend *>(netChatData->getChatTarget());
					if(chatFriend)
					{
						std::string chatStr = chatInput->getStringArrayInString();
						CRCore::ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(chatStr.length()+4);
						stream->_writeString(chatStr);

						crChatPacket packet;
						crChatPacket::buildRequestPacket(packet,chatFriend->getPlayerID(),stream.get());
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
						netConductor->getNetManager()->sendPacket("all",packet);

						CRCore::Timer_t t = time( 0 ); 
						char tmp[20];
						strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t));

						chatFriend->recChat(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						chatFriend->recChat(chatStr+"\n");

						if(chatRec->getNumStrings()>crGlobalHandle::gData()->gNumGameChatShow())
						{
							chatRec->lockArray();
							crStaticTextBoxElement::StringArray &stringArray = chatRec->getStringArray();
							stringArray.erase(stringArray.begin(),stringArray.begin()+crGlobalHandle::gData()->gNumGameChatClear());
							chatRec->unLockArray();
						}

						chatRec->addString(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						chatRec->addString(chatStr+"\n");
						chatRec->updateData();

						chatInput->clearString();
						chatInput->updateData();
					}
				}
			}
		}
	}
}

/////////////////////////////////////////
//
//crRecvFriendChatMethod
//
/////////////////////////////////////////
crRecvFriendChatMethod::crRecvFriendChatMethod(){}
crRecvFriendChatMethod::crRecvFriendChatMethod(const crRecvFriendChatMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_titleElement(handle.m_titleElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crRecvFriendChatMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvFriendChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_titleElement = str;
		break;
	case 2:
		m_chatRecElement = str;
		break;
	}
}

void crRecvFriendChatMethod::operator()(crHandle &handle)
{
	crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
	if(m_stream.valid() && netChatData)
	{
		int senderid = m_stream->_readInt();
		int recvid = m_stream->_readInt();
		crNetChatData::crChatFriend *chatFriend = netChatData->getFriend(senderid);
		if(chatFriend)
		{
			//std::string time = m_stream->_readString();
			char time[20];
			CRCore::Timer_t t = m_stream->_readInt64();
			strftime( time, sizeof(time), "%Y-%m-%d %H:%M:%S\0", localtime(&t));
			std::string chatStr = m_stream->_readString();
			chatFriend->recChat(chatFriend->getNickName()+" "+time+"\n");
			chatFriend->recChat(chatStr+"\n");
			bool hasNewMsg = true;
			if(chatFriend == netChatData->getChatTarget())
			{//
                crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
				if(stage && stage->getShow())
				{
					crStaticTextBoxElement *chatRecElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
					if(chatRecElement)
					{
						chatRecElement->addString(chatFriend->getNickName()+" "+time+"\n");
						chatRecElement->addString(chatStr+"\n");
						chatRecElement->updateData();
						stage->setNeedReDraw();
						hasNewMsg = false;
					}
				}
			}
			chatFriend->setHasNewMsg(hasNewMsg);
		}
		else
		{//陌生人发的消息？

		}
	}
}
/////////////////////////////////////////
//
//crLoadRecMethod
//
/////////////////////////////////////////
crLoadRecMethod::crLoadRecMethod(){}
crLoadRecMethod::crLoadRecMethod(const crLoadRecMethod& handle):
crMethod(handle),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crLoadRecMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crLoadRecMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatRecElement = str;
		break;
	}
}

void crLoadRecMethod::operator()(crHandle &handle)
{
	crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
	if(m_element.valid() && netChatData)
	{
		crImageStage *stage = m_element->getParentStage();
		crStaticTextBoxElement *chatRecElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
		if(chatRecElement)
		{
			unsigned char chatTargetType = netChatData->getChatTargetType();
			if(chatTargetType == crNetChatData::ChatFriend)
			{
				crNetChatData::crChatFriend *chatFriend = dynamic_cast<crNetChatData::crChatFriend *>(netChatData->getChatTarget());
				if(chatFriend)
				{
					chatRecElement->lockArray();
					chatFriend->loadChatRec(chatRecElement->getStringArray());
					chatRecElement->unLockArray();

					chatRecElement->updateData();
					stage->setNeedReDraw();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crSendSceneChatMethod
//
/////////////////////////////////////////
crSendSceneChatMethod::crSendSceneChatMethod(){}
crSendSceneChatMethod::crSendSceneChatMethod(const crSendSceneChatMethod& handle):
crMethod(handle),
m_chatInputElement(handle.m_chatInputElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crSendSceneChatMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSendSceneChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatInputElement = str;
		break;
	case 1:
		m_chatRecElement = str;
		break;
	}
}

void crSendSceneChatMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(stage)
		{
			crEditBoxElement *chatInput = dynamic_cast<crEditBoxElement *>(stage->getElement(m_chatInputElement));
			if(chatInput)
			{
				std::string chatStr = chatInput->getStringArrayInString();
				if(!chatStr.empty())
				{
					crSceneChatPacket packet;
					crSceneChatPacket::buildRequestPacket(packet,chatStr);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					netConductor->getNetManager()->sendPacket("all",packet);

					crStaticTextBoxElement *chatRec = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
					if(chatRec)
					{
						CRCore::Timer_t t = time( 0 ); 
						char tmp[20];
						strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );

						crMyPlayerData::getInstance()->recGameChat(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						crMyPlayerData::getInstance()->recGameChat(chatStr+"\n");

						if(chatRec->getNumStrings()>crGlobalHandle::gData()->gNumGameChatShow())
						{
							chatRec->lockArray();
							crStaticTextBoxElement::StringArray &stringArray = chatRec->getStringArray();
							stringArray.erase(stringArray.begin(),stringArray.begin()+crGlobalHandle::gData()->gNumGameChatClear());
							chatRec->unLockArray();
						}

						chatRec->addString(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						chatRec->addString(chatStr+"\n");
						chatRec->updateData();
					}
					chatInput->clearString();
					chatInput->updateData();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crSendSceneChat2Method
//
/////////////////////////////////////////
crSendSceneChat2Method::crSendSceneChat2Method(){}
crSendSceneChat2Method::crSendSceneChat2Method(const crSendSceneChat2Method& handle):
crMethod(handle),
m_chatInput(handle.m_chatInput),
m_chatRec(handle.m_chatRec)
{
}
void crSendSceneChat2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crSendSceneChat2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatInput = str;
		break;
	case 1:
		m_chatRec = str;
		break;
	}
}

void crSendSceneChat2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	ref_ptr<crEditWidgetNode> chatInput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_chatInput));
	if(chatInput.valid())
	{
		if(m_this == chatInput.get())
		{
			if(!(m_ea->getModKeyMask() & crGUIEventAdapter::MODKEY_CTRL))
				return;
		}
		const std::wstring& wchatStr = chatInput->getString();
		if(!wchatStr.empty())
		{
			std::string chatStr = CRIOManager::convertUTF16toUTF8(wchatStr.c_str());
			crSceneChatPacket packet;
			crSceneChatPacket::buildRequestPacket(packet,chatStr);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);

			ref_ptr<crHypertextWidgetNode> chatRec = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_chatRec));
			if(chatRec.valid())
			{
				CRCore::Timer_t t = time( 0 ); 
				char tmp[20];
				strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
				std::string headStr = crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n";
				crMyPlayerData::getInstance()->recGameChat(headStr);
				chatStr += "\n";
				crMyPlayerData::getInstance()->recGameChat(chatStr);

				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content",1);
				std::vector<float>v_i;
				v_i.push_back(0.0f);
				v_i.push_back(0.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text",headStr);
				cfg_script.Pop();
				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				cfg_script.Add("Text",chatStr);
				cfg_script.Pop();
				cfg_script.Pop();

				if(chatRec->getValidTextSize()>crGlobalHandle::gData()->gNumGameChatShow())
				{
					chatRec->popTexts(crGlobalHandle::gData()->gNumGameChatClear());
				}
				chatRec->setHypertext(cfg_script,true);
			}
			chatInput->clearString();
		}
	}
}
/////////////////////////////////////////
//
//crSendGameChatMethod
//
/////////////////////////////////////////
crSendGameChatMethod::crSendGameChatMethod(){}
crSendGameChatMethod::crSendGameChatMethod(const crSendGameChatMethod& handle):
crMethod(handle),
m_chatInputElement(handle.m_chatInputElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crSendGameChatMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSendGameChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chatInputElement = str;
		break;
	case 1:
		m_chatRecElement = str;
		break;
	}
}

void crSendGameChatMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(stage)
		{
			crEditBoxElement *chatInput = dynamic_cast<crEditBoxElement *>(stage->getElement(m_chatInputElement));
			if(chatInput)
			{
				std::string chatStr = chatInput->getStringArrayInString();
				if(!chatStr.empty())
				{
					crGameChatPacket packet;
					crGameChatPacket::buildRequestPacket(packet,chatStr);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					netConductor->getNetManager()->sendPacket("all",packet);

					crStaticTextBoxElement *chatRec = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
					if(chatRec)
					{
						CRCore::Timer_t t = time( 0 ); 
						char tmp[20];
						strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );

						crMyPlayerData::getInstance()->recGameChat(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						crMyPlayerData::getInstance()->recGameChat(chatStr+"\n");

						if(chatRec->getNumStrings()>crGlobalHandle::gData()->gNumGameChatShow())
						{
							chatRec->lockArray();
							crStaticTextBoxElement::StringArray &stringArray = chatRec->getStringArray();
							stringArray.erase(stringArray.begin(),stringArray.begin()+crGlobalHandle::gData()->gNumGameChatClear());
							chatRec->unLockArray();
						}
						chatRec->addString(crMyPlayerData::getInstance()->getCharacterName()+" "+tmp+"\n");
						chatRec->addString(chatStr+"\n");
						chatRec->updateData();
					}
					chatInput->clearString();
					chatInput->updateData();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvGameChatMethod
//
/////////////////////////////////////////
crRecvGameChatMethod::crRecvGameChatMethod(){}
crRecvGameChatMethod::crRecvGameChatMethod(const crRecvGameChatMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crRecvGameChatMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvGameChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_chatRecElement = str;
		break;
	}
}

void crRecvGameChatMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{//聊天记录文件下次做
		std::string senderName = m_stream->_readString();
		CRCore::Timer_t t = m_stream->_readInt64(); 
		char tmp[20];
		strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
		std::string chatStr = m_stream->_readString();
		crMyPlayerData::getInstance()->recGameChat(senderName+" "+tmp+"\n");
		crMyPlayerData::getInstance()->recGameChat(chatStr+"\n");
		crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
		if(stage)
		{
			crStaticTextBoxElement *chatRec = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
			if(chatRec)
			{
				if(chatRec->getNumStrings()>crGlobalHandle::gData()->gNumGameChatShow())
				{
					chatRec->lockArray();
					crStaticTextBoxElement::StringArray &stringArray = chatRec->getStringArray();
					stringArray.erase(stringArray.begin(),stringArray.begin()+crGlobalHandle::gData()->gNumGameChatClear());
					chatRec->unLockArray();
				}
				chatRec->addString(senderName+" "+tmp+"\n");
				chatRec->addString(chatStr+"\n");
				chatRec->updateData();
				stage->setNeedReDraw();
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvGameChat2Method
//
/////////////////////////////////////////
crRecvGameChat2Method::crRecvGameChat2Method(){}
crRecvGameChat2Method::crRecvGameChat2Method(const crRecvGameChat2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_chatRec(handle.m_chatRec)
{
}
void crRecvGameChat2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvGameChat2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_chatRec = str;
		break;
	}
}

void crRecvGameChat2Method::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{//聊天记录文件下次做
		std::string senderName = m_stream->_readString();
		CRCore::Timer_t t = m_stream->_readInt64(); 
		char tmp[20];
		strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
		std::string chatStr = m_stream->_readString();
		std::string headStr = senderName+" "+tmp+"\n";
		crMyPlayerData::getInstance()->recGameChat(headStr);
		chatStr += "\n";
		crMyPlayerData::getInstance()->recGameChat(chatStr);
		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
		if(canvas.valid())
		{
			ref_ptr<crHypertextWidgetNode> chatRec = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_chatRec));
			if(chatRec.valid())
			{
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content",1);
				std::vector<float>v_i;
				v_i.push_back(0.0f);
				v_i.push_back(0.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text",headStr);
				cfg_script.Pop();
				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				cfg_script.Add("Text",chatStr);
				cfg_script.Pop();
				cfg_script.Pop();

				if(chatRec->getValidTextSize()>crGlobalHandle::gData()->gNumGameChatShow())
				{
					chatRec->popTexts(crGlobalHandle::gData()->gNumGameChatClear());
				}
				chatRec->setHypertext(cfg_script,true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crAddChatFriendSystemMsgMethod
//
/////////////////////////////////////////
crAddChatFriendSystemMsgMethod::crAddChatFriendSystemMsgMethod(){}
crAddChatFriendSystemMsgMethod::crAddChatFriendSystemMsgMethod(const crAddChatFriendSystemMsgMethod& handle):
crMethod(handle),
m_string(handle.m_string),
m_stageName(handle.m_stageName),
m_msgTextElement(handle.m_msgTextElement)
{
}
void crAddChatFriendSystemMsgMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
			m_recvPlayerData = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_recvPlayerData = (crChatServerPlayerData *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
			m_recvPlayerData = NULL;
		}
		break;
	}
}

void crAddChatFriendSystemMsgMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
        m_string = str;
		break;
	case 1:
		m_stageName = str;
		break;
	case 2:
		m_msgTextElement = str;
		break;
	}
}

void crAddChatFriendSystemMsgMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_recvPlayerData.valid())
		{
			char *ptr = m_stream->getPtr();
			int playerid = m_stream->_readInt();
			std::string nickName = m_stream->_readString();

			crNetChatData::crChatFriend *chatFriend2 = new crNetChatData::crChatFriend;
			chatFriend2->setPlayerID(playerid);
			m_recvPlayerData->getNetChatData()->insertFriend(chatFriend2);
			chatFriend2->setNickName(nickName);
			chatFriend2->setFriendChatState(crNetChatData::OnLine);

			//CRCore::Timer_t t = time( 0 ); 
			//char tmp[20];
			//strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
			char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr - ptr2);
			crChatPacket packet;
			crChatPacket::buildRequestPacket2(packet,0,m_recvPlayerData->getPlayerID(),CD_AddChatFriend,/*tmp,*/m_stream.get());
			crNetConductor *chatServerConductor = crNetContainer::getInstance()->getNetConductor(ChatServer);
			chatServerConductor->getNetManager()->sendPacket(m_recvPlayerData->getPlayerConnectServerAddress(),packet);
		}
		else
		{//GameClient_Chat
			//std::string tmp = m_stream->_readString();
			char time[20];
			CRCore::Timer_t t = m_stream->_readInt64();
			strftime( time, sizeof(time), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
			std::string tmp = time;
			int playerid = m_stream->_readInt();
			std::string nickName = m_stream->_readString();

			crNetChatData::crChatFriend *chatFriend2 = new crNetChatData::crChatFriend;
			chatFriend2->setPlayerID(playerid);
			crMyPlayerData::getInstance()->getMyChatData()->insertFriend(chatFriend2);
			chatFriend2->setNickName(nickName);
			chatFriend2->setFriendChatState(crNetChatData::OnLine);
            
			crMyPlayerData::getInstance()->recChatMsg(tmp+"\n");
			crMyPlayerData::getInstance()->recChatMsg(nickName+m_string+"\n");
			crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
			if(stage)
			{
				crStaticTextBoxElement *msgText = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_msgTextElement));
				if(msgText)
				{
					if(msgText->getNumStrings()>crGlobalHandle::gData()->gNumGameChatShow())
					{
						msgText->lockArray();
						crStaticTextBoxElement::StringArray &stringArray = msgText->getStringArray();
						stringArray.erase(stringArray.begin(),stringArray.begin()+crGlobalHandle::gData()->gNumGameChatClear());
						msgText->unLockArray();
					}
					msgText->addString(tmp+"\n");
					msgText->addString(nickName+m_string+"\n");
					msgText->updateData();
					stage->setNeedReDraw();
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crInitCheckAndDownloadFilesMethod
////
///////////////////////////////////////////
//crInitCheckAndDownloadFilesMethod::crInitCheckAndDownloadFilesMethod(){}
//crInitCheckAndDownloadFilesMethod::crInitCheckAndDownloadFilesMethod(const crInitCheckAndDownloadFilesMethod& handle):
//	crMethod(handle)
//{
//}
//void crInitCheckAndDownloadFilesMethod::inputParam(int i, void *param)
//{
//}
//
//void crInitCheckAndDownloadFilesMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crInitCheckAndDownloadFilesMethod::operator()(crHandle &handle)
//{
//	crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//	data->insertDownloadFile(DF_InitCheck,"script/BaseFile.tab");
//	data->startDownloadFile(DF_InitCheck,GameClient_Download);
//}
///////////////////////////////////////////
////
////crInitCheckFileListMethod
////
///////////////////////////////////////////
//crInitCheckFileListMethod::crInitCheckFileListMethod(){}
//crInitCheckFileListMethod::crInitCheckFileListMethod(const crInitCheckFileListMethod& handle):
//	crMethod(handle)
//{
//}
//void crInitCheckFileListMethod::inputParam(int i, void *param)
//{
//}
//
//void crInitCheckFileListMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crInitCheckFileListMethod::operator()(crHandle &handle)
//{
//	std::string filename = "script/BaseFile.tab";
//	crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&filename,MAKEINT32(GameClient_Download,DF_InitCheckEnd)));
//}
///////////////////////////////////////////
////
////crInitCheckEndMethod
////
///////////////////////////////////////////
//int crInitCheckEndMethod::s_needUpdate = 0;
//crInitCheckEndMethod::crInitCheckEndMethod(){}
//crInitCheckEndMethod::crInitCheckEndMethod(const crInitCheckEndMethod& handle):
//	crMethod(handle)
//{
//}
//void crInitCheckEndMethod::inputParam(int i, void *param)
//{
//}
//
//void crInitCheckEndMethod::addParam(int i, const std::string& str)
//{
//}
//void crInitCheckEndMethod::needUpdate(int flg)
//{
//	s_needUpdate = flg;
//}
//void crInitCheckEndMethod::operator()(crHandle &handle)
//{
//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
//	stream->createBuf(1);
//	stream->_writeChar(s_needUpdate==0);
//	stream->seekBegin();
//	crWaitNetReturnStreamLogic::netReturn(stream.get());
//	if(s_needUpdate == 1)
//	{
//		_putenv("CRE_RESTART=1");
//		CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
//		bindview->setDone(true);
//		CRNetApp::crRunGameHandle::getInstance()->end();
//		CRNetApp::crRunGameHandle::getInstance()->setRunning(false);
//	}
//	else if(s_needUpdate==2)
//	{
//		_putenv("CRE_RESTART=2");
//		CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
//		bindview->setDone(true);
//		CRNetApp::crRunGameHandle::getInstance()->end();
//		CRNetApp::crRunGameHandle::getInstance()->setRunning(false);
//		//crImageStage *stage = NULL;
//		//if(m_element.valid())
//		//	stage = m_element->getParentStage();
//		//cr2DStageManager::getInstance()->closeAll(stage);
//	}
//}
/////////////////////////////////////////
//
//crRecvGameListMethod
//
/////////////////////////////////////////
crRecvGameListMethod::crRecvGameListMethod(){}
crRecvGameListMethod::crRecvGameListMethod(const crRecvGameListMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crRecvGameListMethod::inputParam(int i, void *param)
{
}

void crRecvGameListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crRecvGameListMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(!stage) return;

	crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
	if(columnListElement)
	{
		columnListElement->clearData();
		crColumnNode *columnNode;
		crMyPlayerData::getInstance()->lockGameMap();
		GameMap &gameMap = crMyPlayerData::getInstance()->getGameMap();
		for( GameMap::iterator itr = gameMap.begin();
		     itr != gameMap.end();
			 ++itr )
		{
            columnNode = new crColumnNode;
            columnNode->addTitle(CRCore::crArgumentParser::appItoa(itr->second->getID()));
			columnNode->addTitle(itr->second->getCName());
			columnListElement->addData(columnNode);
		}
		crMyPlayerData::getInstance()->unlockGameMap();
		columnListElement->setSelect(1);
		columnListElement->updateData();
	}
}
/////////////////////////////////////////
//
//crRecvGameList2Method
//
/////////////////////////////////////////
crRecvGameList2Method::crRecvGameList2Method(){}
crRecvGameList2Method::crRecvGameList2Method(const crRecvGameList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_tableWidget(handle.m_tableWidget)
{
}
void crRecvGameList2Method::inputParam(int i, void *param)
{
}

void crRecvGameList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_tableWidget = str;
		break;
	}
}

void crRecvGameList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(!canvas.valid()) return;

	ref_ptr<crTableWidgetNode>tableWidget = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_tableWidget));
	if(tableWidget.valid())
	{
		tableWidget->clearData();
		tableWidget->addData(0,0,"ID");
		tableWidget->addData(1,0,"游戏名");
		crMyPlayerData::getInstance()->lockGameMap();
		int row = 1;
		GameMap &gameMap = crMyPlayerData::getInstance()->getGameMap();
		for( GameMap::iterator itr = gameMap.begin();
			itr != gameMap.end();
			++itr,row++ )
		{
			tableWidget->addData(0,row,crArgumentParser::appItoa(itr->second->getID()));
			tableWidget->addData(1,row,itr->second->getCName());
		}
		crMyPlayerData::getInstance()->unlockGameMap();
		tableWidget->selectRow(1);
	}
}
/////////////////////////////////////////
//
//crSetSelectedGameMethod
//
/////////////////////////////////////////
crSetSelectedGameMethod::crSetSelectedGameMethod(){}
crSetSelectedGameMethod::crSetSelectedGameMethod(const crSetSelectedGameMethod& handle):
crMethod(handle),
m_columnListElement(handle.m_columnListElement)
{
}
void crSetSelectedGameMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSetSelectedGameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListElement = str;
		break;
	}
}

void crSetSelectedGameMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
		if(columnListElement)
		{
			int i = columnListElement->getSelect() - 1;
			if(i>=0)
			{
				crColumnNode *selectNode = columnListElement->getData(i);
				if(selectNode)
				{
					std::string id;
					selectNode->getTitle(0,id);
					int gameid = atoi(id.c_str());
					crQueryGameListData *gameData = crMyPlayerData::getInstance()->getGame(gameid);
					crMyPlayerData::getInstance()->setSelectedGame(gameData);

					const std::string &gameName = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
					crData *globalData = crGlobalHandle::getInstance()->getDataClass();
					std::string globalDataFile = gameName + "/GlobalData.cfg";
					CREncapsulation::loadIncludeData(globalDataFile,globalData);
					short sceneid = CRNetApp::crGlobalHandle::getInstance()->gData()->gFirstGameSceneID();
					crData *data = crRunGameHandle::getInstance()->getDataClass();
					data->inputParam(WCHDATA_SceneID,&sceneid);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crSetSelectedGame2Method
//
/////////////////////////////////////////
crSetSelectedGame2Method::crSetSelectedGame2Method(){}
crSetSelectedGame2Method::crSetSelectedGame2Method(const crSetSelectedGame2Method& handle):
crMethod(handle),
m_columnListWidget(handle.m_columnListWidget)
{
}
void crSetSelectedGame2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crSetSelectedGame2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListWidget = str;
		break;
	}
}

void crSetSelectedGame2Method::operator()(crHandle &handle)
{
	{
		crCanvasNode *canvas = m_this->getParentCanvas();
		if(!canvas) return;

		ref_ptr<crTableWidgetNode> columnListWidget = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_columnListWidget));
		if(columnListWidget.valid())
		{
			int i = columnListWidget->getSelect();
			if(i>=0)
			{
				std::wstring id;
				if(columnListWidget->getData(0,i,id))
				{
					int gameid = _wtoi(id.c_str());
					crQueryGameListData *gameData = crMyPlayerData::getInstance()->getGame(gameid);
					crMyPlayerData::getInstance()->setSelectedGame(gameData);

					const std::string &gameName = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
					crData *globalData = crGlobalHandle::getInstance()->getDataClass();
					std::string globalDataFile = gameName + "/GlobalData.cfg";
					CREncapsulation::loadIncludeData(globalDataFile,globalData);
					short sceneid = CRNetApp::crGlobalHandle::getInstance()->gData()->gFirstGameSceneID();
					crData *data = crRunGameHandle::getInstance()->getDataClass();
					data->inputParam(WCHDATA_SceneID,&sceneid);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crExternSelectedGameMethod
//
/////////////////////////////////////////
crExternSelectedGameMethod::crExternSelectedGameMethod(){}
crExternSelectedGameMethod::crExternSelectedGameMethod(const crExternSelectedGameMethod& handle):
crMethod(handle)
{
}
void crExternSelectedGameMethod::inputParam(int i, void *param)
{
}

void crExternSelectedGameMethod::addParam(int i, const std::string& str)
{
}

void crExternSelectedGameMethod::operator()(crHandle &handle)
{
	//crQueryGameListData *gameData = crMyPlayerData::getInstance()->getGame(crGlobalHandle::getInstance()->gData()->gGameID());
	//crMyPlayerData::getInstance()->setSelectedGame(gameData);

	ref_ptr<crQueryGameListData> gameData = new crQueryGameListData;
	gameData->setID(3);
	gameData->setGameName("JXJ");
	gameData->setCName("将星诀");
	//gameData->setUIFile("jxjui.cru");
	gameData->setRoleCount(4);
	crMyPlayerData::getInstance()->setSelectedGame(gameData.get());
}
///////////////////////////////////////////
////
////crEnterGameDownloadFilesMethod
////
///////////////////////////////////////////
//crEnterGameDownloadFilesMethod::crEnterGameDownloadFilesMethod(){}
//crEnterGameDownloadFilesMethod::crEnterGameDownloadFilesMethod(const crEnterGameDownloadFilesMethod& handle):
//crMethod(handle)
//{
//}
//void crEnterGameDownloadFilesMethod::inputParam(int i, void *param)
//{
//}
//
//void crEnterGameDownloadFilesMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crEnterGameDownloadFilesMethod::operator()(crHandle &handle)
//{
//	crQueryGameListData *gameData = crMyPlayerData::getInstance()->getSelectedGame();
//	crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//	if(gameData && data)
//	{
//		std::string basefilelist = gameData->getGameDir()+"BaseFile.tab";
//		data->insertDownloadFile(DF_PreEnterGame,basefilelist);
//		data->startDownloadFile(DF_PreEnterGame,GameClient_Download);
//	}
//}
///////////////////////////////////////////
////
////crRecvingDownLoadFileMethod
////
///////////////////////////////////////////
//crRecvingDownLoadFileMethod::crRecvingDownLoadFileMethod(){}
//crRecvingDownLoadFileMethod::crRecvingDownLoadFileMethod(const crRecvingDownLoadFileMethod& handle):
//crMethod(handle),
//m_notifyStage(handle.m_notifyStage),
//m_notifyTextElement(handle.m_notifyTextElement)
//{
//}
//void crRecvingDownLoadFileMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_recvFileStream = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_recvFileStream = (crRecvFileStream *)(LOINT64(param64));
//		}
//		else
//		{
//			m_recvFileStream = NULL;
//		}
//		break;
//	}
//}
//
//void crRecvingDownLoadFileMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_notifyStage = str;
//		break;
//	case 1:
//		m_notifyTextElement = str;
//		break;
//	}
//}
//
//void crRecvingDownLoadFileMethod::operator()(crHandle &handle)
//{
//	if(m_recvFileStream.valid())
//	{
//		crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//		const std::string &filename = m_recvFileStream->getFileName();
//		if(!filename.empty())
//		{
//			std::string cookfilename = filename;
//			CRIOManager::GetCookedFileName(cookfilename);
//			CRCore::notify(CRCore::ALWAYS)<<"RecvingDownLoadFile "<<cookfilename<<std::endl;
//			crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_notifyStage);
//			if(stage && stage->getShow())
//			{
//				crStaticTextBoxElement *downloadInfo = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_notifyTextElement));
//				if(downloadInfo)
//				{
//					char buf[16];
//					sprintf(buf,"完成：%d\0",m_recvFileStream->getProgress());
//					downloadInfo->setStringArrayByString(cookfilename + buf+"%");
//					stage->setNeedReDraw();
//				}
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crRecvingDownLoadFile2Method
////
///////////////////////////////////////////
//crRecvingDownLoadFile2Method::crRecvingDownLoadFile2Method(){}
//crRecvingDownLoadFile2Method::crRecvingDownLoadFile2Method(const crRecvingDownLoadFile2Method& handle):
//crMethod(handle)
//{
//}
//void crRecvingDownLoadFile2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_recvFileStream = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_recvFileStream = (crRecvFileStream *)(LOINT64(param64));
//		}
//		else
//		{
//			m_recvFileStream = NULL;
//		}
//		break;
//	}
//}
//
//void crRecvingDownLoadFile2Method::addParam(int i, const std::string& str)
//{
//}
//
//void crRecvingDownLoadFile2Method::operator()(crHandle &handle)
//{
//	if(m_recvFileStream.valid())
//	{
//		crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//		const std::string &filename = m_recvFileStream->getFileName();
//		if(!filename.empty())
//		{
//			std::string cookfilename = filename;
//			CRIOManager::GetCookedFileName(cookfilename);
//			CRCore::notify(CRCore::ALWAYS)<<"RecvingDownLoadFile "<<cookfilename<<std::endl;
//			CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
//			if(noticeText)
//			{
//				char buf[256];
//				sprintf(buf,"%s完成：%d%%\0",cookfilename.c_str(),m_recvFileStream->getProgress());
//				std::wstring notice = CRIOManager::convertUTF8toUTF16(buf,strlen(buf));
//				noticeText->setText(notice.c_str());
//				noticeText->setVisiable(true);
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crCheckFileListMethod
////
///////////////////////////////////////////
//crCheckFileListMethod::crCheckFileListMethod(){}
//crCheckFileListMethod::crCheckFileListMethod(const crCheckFileListMethod& handle):
//crMethod(handle)
//{
//}
//void crCheckFileListMethod::inputParam(int i, void *param)
//{
//}
//
//void crCheckFileListMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crCheckFileListMethod::operator()(crHandle &handle)
//{
//	crQueryGameListData *gameData = crMyPlayerData::getInstance()->getSelectedGame();
//	if(gameData)
//	{
//		std::string basefilelist = gameData->getGameDir()+"BaseFile.tab";
//		crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&basefilelist,MAKEINT32(GameClient_Download,DF_EnterGame)));
//	}
//}
/////////////////////////////////////////
//
//crEnterGameMethod
//
/////////////////////////////////////////
crEnterGameMethod::crEnterGameMethod(){}
crEnterGameMethod::crEnterGameMethod(const crEnterGameMethod& handle):
crMethod(handle)
{
}
void crEnterGameMethod::inputParam(int i, void *param)
{
}
void crEnterGameMethod::addParam(int i, const std::string& str)
{
}
void crEnterGameMethod::operator()(crHandle &handle)
{
	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	//if(noticeText)
	//{
	//	noticeText->setText("Login game...");
	//	noticeText->setVisiable(true);
	//}
	crGlobalHandle::getInstance()->doEvent(WCH_LoginGame,NULL);
}
/////////////////////////////////////////
//
//crEnterSceneMethod
//
/////////////////////////////////////////
crEnterSceneMethod::crEnterSceneMethod(){}
crEnterSceneMethod::crEnterSceneMethod(const crEnterSceneMethod& handle):
crMethod(handle)
{
}
void crEnterSceneMethod::inputParam(int i, void *param)
{
}
void crEnterSceneMethod::addParam(int i, const std::string& str)
{
}
void crEnterSceneMethod::operator()(crHandle &handle)
{
	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	//if(noticeText)
	//{
	//	noticeText->setText("Login scene...");
	//	noticeText->setVisiable(true);
	//}
	crGlobalHandle::getInstance()->doEvent(WCH_LoginScene,NULL);
}
///////////////////////////////////////////
////
////crCheckRoleUpdatecfgMethod
////
///////////////////////////////////////////
//crCheckRoleUpdatecfgMethod::crCheckRoleUpdatecfgMethod(){}
//crCheckRoleUpdatecfgMethod::crCheckRoleUpdatecfgMethod(const crCheckRoleUpdatecfgMethod& handle):
//crMethod(handle)
//{
//}
//void crCheckRoleUpdatecfgMethod::inputParam(int i, void *param)
//{
//}
//void crCheckRoleUpdatecfgMethod::addParam(int i, const std::string& str)
//{
//}
//void crCheckRoleUpdatecfgMethod::operator()(crHandle &handle)
//{
//	crRole *role = crMyPlayerData::getInstance()->getCurrentQueryRole();
//	if(role)
//	{
//		CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
//		if(noticeText)
//		{
//			noticeText->setText("Check role Files...");
//			noticeText->setVisiable(true);
//		}
//		std::string updateCfg = role->getAbstractItem()->getUpdatecfg();
//		if(!updateCfg.empty())
//			crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&updateCfg,MAKEINT32(GameClient_Game,DF_EnterSceneSucess)));
//		else
//			crGlobalHandle::getInstance()->doEvent(MAKEINT64(WCH_RecvedFileStream,DF_EnterSceneSucess),NULL);
//	}
//}
/////////////////////////////////////////
//
//crEnterSceneSucessMethod
//
/////////////////////////////////////////
crEnterSceneSucessMethod::crEnterSceneSucessMethod(){}
crEnterSceneSucessMethod::crEnterSceneSucessMethod(const crEnterSceneSucessMethod& handle):
crMethod(handle)
{
}
void crEnterSceneSucessMethod::inputParam(int i, void *param)
{
}
void crEnterSceneSucessMethod::addParam(int i, const std::string& str)
{
}
void crEnterSceneSucessMethod::operator()(crHandle &handle)
{
	crRole *queryRole = crMyPlayerData::getInstance()->queryNextRole();
	if(queryRole)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crQueryRoleInfoPacket packet;
			crQueryRoleInfoPacket::buildRequestPacket(packet,queryRole);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
	else
	{
		//crMyPlayerData::getInstance()->createScene();
		crGlobalHandle::getInstance()->doEvent(WCH_StartGame);
		//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
		//if(noticeText)
		//{
		//	noticeText->setText("Start game...");
		//	noticeText->setVisiable(true);
		//}
	}
}
/////////////////////////////////////////
//
//crRecvedItemMethod
//
/////////////////////////////////////////
crRecvedItemMethod::crRecvedItemMethod():
m_id(0){}
crRecvedItemMethod::crRecvedItemMethod(const crRecvedItemMethod& handle):
crMethod(handle),
m_id(0)
{
}
void crRecvedItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_id = LOINT64(param64);
		}
		else
		{
			m_id = 0;
		}
		break;
	}
}
void crRecvedItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvedItemMethod::operator()(crHandle &handle)
{
	crInstanceItem* item = crMyPlayerData::getInstance()->findDownloadItem(m_id);
	if(item)
	{
		crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item,NULL));
		crMyPlayerData::getInstance()->removeDownloadItem(m_id);
		//std::string updateCfg = item->getAbstractItem()->getUpdatecfg();
		//if(!updateCfg.empty())
		//{//checkAndDown updatecfg
		//	crMyPlayerData::getInstance()->pushDownloadItem(item.get(),DF_DownLoadItem2);
		//	crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&updateCfg,MAKEINT32(GameClient_Game,DF_DownLoadItem2)));
		//}
		//else
		//	crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
	}
}
///////////////////////////////////////////
////
////crRecvedItem2Method
////
///////////////////////////////////////////
//crRecvedItem2Method::crRecvedItem2Method(){}
//crRecvedItem2Method::crRecvedItem2Method(const crRecvedItem2Method& handle):
//crMethod(handle)
//{
//}
//void crRecvedItem2Method::inputParam(int i, void *param)
//{
//}
//void crRecvedItem2Method::addParam(int i, const std::string& str)
//{
//}
//void crRecvedItem2Method::operator()(crHandle &handle)
//{
//	ref_ptr<crInstanceItem> item = crMyPlayerData::getInstance()->getFrontDownloadItem();
//	if(item.valid())
//	{
//		crMyPlayerData::getInstance()->popFrontDownloadItem();
//		crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
//	}
//}
/////////////////////////////////////////
//
//crRecvedItemChildMethod
//
/////////////////////////////////////////
crRecvedItemChildMethod::crRecvedItemChildMethod(){}
crRecvedItemChildMethod::crRecvedItemChildMethod(const crRecvedItemChildMethod& handle):
crMethod(handle)
{
}
void crRecvedItemChildMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_id = LOINT64(param64);
		}
		else
		{
			m_id = 0;
		}
		break;
	}
}
void crRecvedItemChildMethod::addParam(int i, const std::string& str)
{
}
void crRecvedItemChildMethod::operator()(crHandle &handle)
{
	crMyPlayerData::ItemChildPair itemChildPair;
	if(crMyPlayerData::getInstance()->findDownloadItemChild(m_id,itemChildPair))
	{
		crGlobalHandle::getInstance()->doEvent(WCH_LoadItemChild,MAKEINT64(itemChildPair.first.get(),itemChildPair.second.get()));
		//crGlobalHandle::getInstance()->doEvent(WCH_LoadItemChild,MAKEINT64(NULL,NULL));//清理
		crMyPlayerData::getInstance()->removeDownloadItemChild(m_id);
	}
}
///////////////////////////////////////////
////
////crRecvedItemChild2Method
////
///////////////////////////////////////////
//crRecvedItemChild2Method::crRecvedItemChild2Method(){}
//crRecvedItemChild2Method::crRecvedItemChild2Method(const crRecvedItemChild2Method& handle):
//crMethod(handle)
//{
//}
//void crRecvedItemChild2Method::inputParam(int i, void *param)
//{
//}
//void crRecvedItemChild2Method::addParam(int i, const std::string& str)
//{
//}
//void crRecvedItemChild2Method::operator()(crHandle &handle)
//{
//	crMyPlayerData::ItemChildPair itemChildPair;
//	if(crMyPlayerData::getInstance()->getFrontDownloadItemChild(itemChildPair))
//	{
//		crMyPlayerData::getInstance()->popFrontDownloadItemChild();
//		crGlobalHandle::getInstance()->doEvent(WCH_LoadItemChild,MAKEINT64(itemChildPair.first.get(),itemChildPair.second.get()));
//	}
//}
///////////////////////////////////////////
////
////CRDownloadFileEndMethod
////
///////////////////////////////////////////
//CRDownloadFileEndMethod::CRDownloadFileEndMethod(){}
//CRDownloadFileEndMethod::CRDownloadFileEndMethod(const CRDownloadFileEndMethod& handle):
//crMethod(handle),
//m_stream(handle.m_stream),
//m_notifyStage(handle.m_notifyStage),
//m_notifyTextElement(handle.m_notifyTextElement)
//{
//}
//void CRDownloadFileEndMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_stream = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (CRCore::crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void CRDownloadFileEndMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_notifyStage = str;
//		break;
//	case 1:
//		m_notifyTextElement = str;
//		break;
//	}
//}
//
//void CRDownloadFileEndMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//		if(data)
//		{
//			unsigned short downloadFlg = m_stream->_readUShort();
//			//CRCore::notify(CRCore::ALWAYS)<<"DownloadFileEnd "<<downloadFlg<<std::endl;
//			if(downloadFlg == DF_EnterGame)
//			{
//				crGlobalHandle::getInstance()->doEvent(WCH_LoginGame,NULL);
//
//				crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_notifyStage);
//				if(stage && stage->getShow())
//				{
//					crStaticTextBoxElement *downloadInfo = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_notifyTextElement));
//					if(downloadInfo)
//					{
//						downloadInfo->setStringArrayByString("Login game...");
//						stage->setNeedReDraw();
//					}
//				}
//			}
//			else if(downloadFlg == DF_EnterScene)
//			{
//				crGlobalHandle::getInstance()->doEvent(WCH_LoginScene,NULL);
//				crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_notifyStage);
//				if(stage && stage->getShow())
//				{
//					crStaticTextBoxElement *downloadInfo = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_notifyTextElement));
//					if(downloadInfo)
//					{
//						downloadInfo->setStringArrayByString("Login scene...");
//						stage->setNeedReDraw();
//					}
//				}
//			}
//			else if(downloadFlg == DF_EnterSceneSucess)
//			{
//				//crGlobalHandle::getInstance()->doEvent(WCH_GetRoleZ);
//				crGlobalHandle::getInstance()->doEvent(WCH_StartGame);
//				crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_notifyStage);
//				if(stage && stage->getShow())
//				{
//					crStaticTextBoxElement *downloadInfo = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_notifyTextElement));
//					if(downloadInfo)
//					{
//						downloadInfo->setStringArrayByString("Start game...");
//						stage->setNeedReDraw();
//					}
//				}
//			}
//			else if(downloadFlg == DF_DownLoadItem)
//			{
//				ref_ptr<crInstanceItem> item = crMyPlayerData::getInstance()->getFrontDownloadItem();
//				if(item.valid())
//				{
//					crMyPlayerData::getInstance()->popFrontDownloadItem();
//                    std::string updateCfg = item->getUpdatecfg();
//					bool needDownload = false;
//					if(!updateCfg.empty())
//					{//checkAndDown updatecfg
//                        crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&updateCfg,&needDownload));
//					}
//					if(needDownload)
//						crMyPlayerData::getInstance()->pushDownloadItem(item.get(),DF_DownLoadItem2);
//					else
//			            crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
//				}
//			}
//			else if(downloadFlg == DF_DownLoadItem2)
//			{
//				ref_ptr<crInstanceItem> item = crMyPlayerData::getInstance()->getFrontDownloadItem();
//				if(item.valid())
//				{
//					crMyPlayerData::getInstance()->popFrontDownloadItem();
//					crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
//				}
//			}
//			else if(downloadFlg == DF_DownLoadItemChild)
//			{
//				crMyPlayerData::ItemChildPair itemChildPair;
//				if(crMyPlayerData::getInstance()->getFrontDownloadItemChild(itemChildPair))
//				{
//					crMyPlayerData::getInstance()->popFrontDownloadItemChild();
//					std::string updateCfg = itemChildPair.first->getInstanceItem()->getUpdatecfg();
//					bool needDownload = false;
//					if(!updateCfg.empty())
//					{//checkAndDown updatecfg
//						crGlobalHandle::getInstance()->doEvent(WCH_DownloadedUpdatecfg,MAKEINT64(&updateCfg,&needDownload));
//					}
//					if(needDownload)
//						crMyPlayerData::getInstance()->pushDownloadItemChild(itemChildPair.first.get(),itemChildPair.second.get(),DF_DownLoadItemChild2);
//					else
//						crGlobalHandle::getInstance()->doEvent(WCH_LoadItemChild,MAKEINT64(itemChildPair.first.get(),itemChildPair.second.get()));
//				}
//			}
//			else if(downloadFlg == DF_DownLoadItemChild2)
//			{
//				crMyPlayerData::ItemChildPair itemChildPair;
//				if(crMyPlayerData::getInstance()->getFrontDownloadItemChild(itemChildPair))
//				{
//                    crMyPlayerData::getInstance()->popFrontDownloadItemChild();
//					crGlobalHandle::getInstance()->doEvent(WCH_LoadItemChild,MAKEINT64(itemChildPair.first.get(),itemChildPair.second.get()));
//				}
//			}
//		}
//	}
//}

///////////////////////////////////////////
////
////crCheckAndDownloadFileMethod
////
///////////////////////////////////////////
//crCheckAndDownloadFileMethod::crCheckAndDownloadFileMethod():
//m_downloadFlg(DF_None),
//m_fileModifyTime(0){}
//crCheckAndDownloadFileMethod::crCheckAndDownloadFileMethod(const crCheckAndDownloadFileMethod& handle):
//crMethod(handle),
//m_fileName(handle.m_fileName),
//m_fileModifyTime(handle.m_fileModifyTime),
//m_downloadFlg(handle.m_downloadFlg)
//{
//}
//void crCheckAndDownloadFileMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 1:
//		if(param)
//		{
//			m_fileName = *(std::string *)param;
//		}
//		else
//		{
//			m_fileName.clear();
//		}
//		break;
//	case 2:
//		/*if(param)
//		{
//			m_fileModifyTime = *(std::string *)param;
//		}
//		else
//		{
//			m_fileModifyTime.clear();
//		}*/
//		m_fileModifyTime = param?*(CRCore::Timer_t *)param:0;
//		break;
//	case 3:
//		m_downloadFlg = param==NULL?DF_None:*(unsigned short*)param;
//		break;
//	}
//}
//
//void crCheckAndDownloadFileMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crCheckAndDownloadFileMethod::operator()(crHandle &handle)
//{
//	bool needDownload = false;
//	if(!m_fileName.empty())
//	{
//		//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//		crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
//		if(/*netConductor && */data)
//		{
//			std::string cookfilename = m_fileName;
//			CRIOManager::GetCookedFileName(cookfilename);
//			struct stat buf;
//			if (stat( cookfilename.c_str(), &buf )) 
//			{
//				needDownload = true;
//			}
//			else
//			{
//				//char mtime[20];
//				//strftime( mtime, sizeof(mtime), "%Y-%m-%d %H:%M:%S\0", localtime(&buf.st_mtime));
//				//if(m_fileModifyTime.compare(mtime) > 0)
//				//{//服务器上的文件日期比本机的新
//				//	needDownload = true;
//				//}
//				if(m_fileModifyTime>buf.st_mtime)
//				{//服务器上的文件日期比本机的新
//					needDownload = true;
//				}
//			}
//			if(needDownload)
//			{
//				//struct tm tmp_time;
//				//strptime("2011-07-28 23:27:12","%Y-%m-%d %H:%M:%S",&tmp_time);
//				data->insertDownloadFile(m_downloadFlg,m_fileName);
//				//if(fileid>=0)
//				//{//-1表示该文件已经存在于下载队列里，不需要再下载
//				//	CRDownloadFilePacket packet;
//				//	CRDownloadFilePacket::buildRequestPacket(packet,m_fileName,fileid,m_downloadFlg);
//				//	netConductor->getNetManager()->sendPacket("all",packet);
//				//	CRCore::notify(CRCore::ALWAYS)<<"crCheckAndDownloadFileMethod need download "<<m_fileName<<std::endl;
//				//}
//			}
//		}
//	}
//	//关闭下载
//	needDownload = false;
//    handle.outputParam(0,&needDownload);
//}
///////////////////////////////////////////
////
////crWaitLoginGameReturnMethod
////
///////////////////////////////////////////
////CRCore::crCondition crWaitLoginGameReturnMethod::s_loginGameCondition;
////CRCore::crMutex crWaitLoginGameReturnMethod::s_loginGameMutex;
//CRCore::crBarrier crWaitLoginGameReturnMethod::s_loginGameBarrier(2);
//char crWaitLoginGameReturnMethod::s_loginCode = 0;
//crWaitLoginGameReturnMethod::crWaitLoginGameReturnMethod(){}
//crWaitLoginGameReturnMethod::crWaitLoginGameReturnMethod(const crWaitLoginGameReturnMethod& handle):
//crMethod(handle)
//{
//}
//void crWaitLoginGameReturnMethod::inputParam(int i, void *param)
//{
//}
//
//void crWaitLoginGameReturnMethod::addParam(int i, const std::string& str)
//{
//}
//void crWaitLoginGameReturnMethod::loginGameReturn(char loginCode)
//{
//	CRCore::crThread::yieldCurrentThread();
//	s_loginCode = loginCode;
//	//s_loginGameCondition.signal();
//    s_loginGameBarrier.block();
//}
//void crWaitLoginGameReturnMethod::operator()(crHandle &handle)
//{
//	//bool sucess = !(s_loginGameCondition.wait(&s_loginGameMutex,INFINITE));
//	s_loginGameBarrier.block();
//	bool sucess = s_loginCode>0;
//	handle.outputParam(0,&sucess);
//	s_loginCode = 0;
//}
/////////////////////////////////////////
//
//crLoginGameMethod
//
/////////////////////////////////////////
crLoginGameMethod::crLoginGameMethod(){}
crLoginGameMethod::crLoginGameMethod(const crLoginGameMethod& handle):
crMethod(handle)
{
}
void crLoginGameMethod::inputParam(int i, void *param)
{
}

void crLoginGameMethod::addParam(int i, const std::string& str)
{
}
void crLoginGameMethod::operator()(crHandle &handle)
{
	bool sucess = false;
	crQueryGameListData *gameData = crMyPlayerData::getInstance()->getSelectedGame();
	if(gameData)
	{
		std::string clientcfg = gameData->getGameDir()+"GameClient.cfg";
		std::string keyStr = "GameConnectServer" + crArgumentParser::appItoa(1);
		std::string callback = "GameConnectServer";
		std::string serverName = keyStr;
		std::string serverPassword = keyStr;
		std::string ip;
		int port = DEFAULTPORT;
		int bufSizeScale = 1;

		//const std::string& userName = crMyPlayerData::getInstance()->getPlayerName();
		int playerid = crMyPlayerData::getInstance()->getPlayerID();

		rcfg::ConfigScript cfg_script;
		if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,clientcfg))
		{
			CRCore::notify(CRCore::FATAL)<<"crLoginGameMethod(): file open error,"<<clientcfg<<std::endl;
			return;
		}

		cfg_script.Push(keyStr);
		cfg_script.Get("NetCallbackString", callback);
		cfg_script.Get("ServerName", serverName);
		cfg_script.Get("ServerPassword", serverPassword);
		cfg_script.Get("IP", ip);
		cfg_script.Get("Port", port);
		cfg_script.Get("BufSizeScale", bufSizeScale);

		if (!cfg_script.Pop())
			CRCore::notify(CRCore::FATAL)<<"Start "<<serverName<<" error,检查Server.cfg "<<cfg_script.GetLastError()<<std::endl;

		CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
		netConductor->init(port);
		netConductor->setNetType(CRNetApp::GameClient_Game);
		netConductor->setName("GameClient_Game");
		netConductor->setEnableCook(true);
		crBlockDetectThread::getInstance()->pause();
		int code = 0;
		if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
			code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale);
		else
			code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,10);
		//int code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,playerid,serverName,serverPassword,port,bufSizeScale,5);
		crBlockDetectThread::getInstance()->resume();
		if(code<=0)
		{
			switch (code)
			{
			case 0:
				//无法创建客户端
				CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
				break;
			case -1:
				//超出服务器连接人数限制
				CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
				break;
			case -2:
				//同名客户端已经存在
				CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
				break;
			case -3:
				//要求连接的服务端名字与本服务器名不同
				CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
				break;
			case -4:
				//服务器密码不正确
				CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
				break;
			default:
				CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
			}
		}
		else
		{
			CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
			//CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;

			crLoginGamePacket packet;
			crLoginGamePacket::buildRequestPacket(packet);
			netConductor->getNetManager()->sendPacket("all",packet);

			sucess = true;
		}
	}
	handle.outputParam(0,&sucess);
}
/////////////////////////////////////////
//
//crLoginGameReturnMethod
//
/////////////////////////////////////////
crLoginGameReturnMethod::crLoginGameReturnMethod():
m_loginCode(0){}
crLoginGameReturnMethod::crLoginGameReturnMethod(const crLoginGameReturnMethod& handle):
crMethod(handle),
m_loginCode(handle.m_loginCode)
{
}
void crLoginGameReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_loginCode = LOINT64(param64);
		}
		break;
	}
}

void crLoginGameReturnMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_loginCode = (char)(atoi(str.c_str()));
	//	break;
	//}
}

void crLoginGameReturnMethod::operator()(crHandle &handle)
{
	//crWaitLoginGameReturnMethod::loginGameReturn(m_loginCode);
	handle.outputParam(0,&m_loginCode);
}
/////////////////////////////////////////
//
//crNotifyMethod
//
/////////////////////////////////////////
crNotifyMethod::crNotifyMethod():
m_type(0){}
crNotifyMethod::crNotifyMethod(const crNotifyMethod& handle):
crMethod(handle),
m_type(handle.m_type),
m_notify(handle.m_notify)
{
}
void crNotifyMethod::inputParam(int i, void *param)
{
}

void crNotifyMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	case 1:
		m_notify = str;
		break;
	}
}

void crNotifyMethod::operator()(crHandle &handle)
{
	CRCore::notify((CRCore::NotifySeverity)m_type)<<m_notify<<std::endl;
}

/////////////////////////////////////////
//
//crRecvGameRoleListMethod
//
/////////////////////////////////////////
crRecvGameRoleListMethod::crRecvGameRoleListMethod(){}
crRecvGameRoleListMethod::crRecvGameRoleListMethod(const crRecvGameRoleListMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crRecvGameRoleListMethod::inputParam(int i, void *param)
{
}

void crRecvGameRoleListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crRecvGameRoleListMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(!stage) return;

	crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
	if(columnListElement)
	{
		columnListElement->clearData();
		crColumnNode *columnNode;
		crMyPlayerData::getInstance()->lockGameRoleMap();
		GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
		for( GameRoleMap::iterator itr = gameRoleMap.begin();
			itr != gameRoleMap.end();
			++itr )
		{
			columnNode = new crColumnNode;
			columnNode->addTitle(CRCore::crArgumentParser::appItoa(itr->second->getID()));
			columnNode->addTitle(itr->second->getIName());
			columnListElement->addData(columnNode);
		}
		crMyPlayerData::getInstance()->unlockGameRoleMap();
		columnListElement->setSelect(1);
		columnListElement->updateData();
	}
}
/////////////////////////////////////////
//
//crRecvGameRoleList2Method
//
/////////////////////////////////////////
crRecvGameRoleList2Method::crRecvGameRoleList2Method(){}
crRecvGameRoleList2Method::crRecvGameRoleList2Method(const crRecvGameRoleList2Method& handle):
crMethod(handle),
m_canvas(handle.m_canvas),
m_columnListWidget(handle.m_columnListWidget)
{
}
void crRecvGameRoleList2Method::inputParam(int i, void *param)
{
}

void crRecvGameRoleList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_columnListWidget = str;
		break;
	}
}

void crRecvGameRoleList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(!canvas.valid()) return;

	ref_ptr<crTableWidgetNode> columnListWidget = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_columnListWidget));
	if(columnListWidget.valid())
	{
		columnListWidget->clearData();
		columnListWidget->addData(0,0,"ID");
		columnListWidget->addData(1,0,"角色名");
		crMyPlayerData::getInstance()->lockGameRoleMap();
		int row = 1;
		GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
		for( GameRoleMap::iterator itr = gameRoleMap.begin();
			itr != gameRoleMap.end();
			++itr,row++ )
		{
			columnListWidget->addData(0,row,CRCore::crArgumentParser::appItoa(itr->second->getRoleID()));
			columnListWidget->addData(1,row,itr->second->getIName());
		}
		crMyPlayerData::getInstance()->unlockGameRoleMap();
		columnListWidget->selectRow(1);
	}
}
/////////////////////////////////////////
//
//crRecvGameRoleListStreamMethod
//
/////////////////////////////////////////
crRecvGameRoleListStreamMethod::crRecvGameRoleListStreamMethod(){}
crRecvGameRoleListStreamMethod::crRecvGameRoleListStreamMethod(const crRecvGameRoleListStreamMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvGameRoleListStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}
void crRecvGameRoleListStreamMethod::addParam(int i, const std::string& str)
{
}
void crRecvGameRoleListStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crMyPlayerData::getInstance()->clearGameRoleMap();
		crStreamBuf *stream = m_recvDataStream->getStream();
		int count = (int)(stream->_readUChar());
		ref_ptr<crInstanceItem> item;
		for(int i = 0; i<count; i++)
		{
			readItem(item,stream,false);
			//download role and loadrole
			crBrain::getInstance()->doEvent(WCH_SetSelectRolePosition,MAKEINT64(item.get(),i));
			if(item->getAbstractItem())
				crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
			else
				crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
			crMyPlayerData::getInstance()->addGameRole(dynamic_cast<crRole *>(item.get()));
// 			if(i == 0)
// 				crMyPlayerData::getInstance()->setSelectedGameRole(dynamic_cast<crRole *>(item.get()));
		}
	}
}
/////////////////////////////////////////
//
//crRecvCreateRoleStreamMethod
//
/////////////////////////////////////////
crRecvCreateRoleStreamMethod::crRecvCreateRoleStreamMethod(){}
crRecvCreateRoleStreamMethod::crRecvCreateRoleStreamMethod(const crRecvCreateRoleStreamMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvCreateRoleStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}
void crRecvCreateRoleStreamMethod::addParam(int i, const std::string& str)
{
}
void crRecvCreateRoleStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crStreamBuf *stream = m_recvDataStream->getStream();
		ref_ptr<crInstanceItem> item;
		readItem(item,stream,false);
		//download role and loadrole
		crBrain::getInstance()->doEvent(WCH_SetSelectRolePosition,MAKEINT64(item.get(),crMyPlayerData::getInstance()->getGameRoleCount()));
		if(item->getAbstractItem())
			crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
		else
			crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
		crMyPlayerData::getInstance()->addGameRole(dynamic_cast<crRole *>(item.get()));
	}
}
/////////////////////////////////////////
//
//crRecvCreateMainRoleStreamMethod
//
/////////////////////////////////////////
crRecvCreateMainRoleStreamMethod::crRecvCreateMainRoleStreamMethod(){}
crRecvCreateMainRoleStreamMethod::crRecvCreateMainRoleStreamMethod(const crRecvCreateMainRoleStreamMethod& handle):
	crMethod(handle),
	m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvCreateMainRoleStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}
void crRecvCreateMainRoleStreamMethod::addParam(int i, const std::string& str)
{
}
void crRecvCreateMainRoleStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crStreamBuf *stream = m_recvDataStream->getStream();
		ref_ptr<crInstanceItem> item;
		readItem(item,stream,false);
		ref_ptr<crPlayerGameData>myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		if(myPlayer.valid())
		{
			myPlayer->setMainRole(dynamic_cast<crRole *>(item.get()));
			myPlayer->doEvent(WCH_RecvCreateMainRole);
			//download role and loadrole
			//crMyPlayerData::getInstance()->addGameRole(dynamic_cast<crRole *>(item.get()));
			//crBrain::getInstance()->doEvent(WCH_SetSelectRolePosition,MAKEINT64(item.get(),crMyPlayerData::getInstance()->getGameRoleCount()-1));
			//crMyPlayerData::getInstance()->setLoadMainRoleCase(3);
			if(item->getAbstractItem())
				crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
			else
				crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
			//crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
		}
	}
}
/////////////////////////////////////////
//
//crSetSelectRolePositionMethod
//
/////////////////////////////////////////
crSetSelectRolePositionMethod::crSetSelectRolePositionMethod():
m_roleIndex(0){}
crSetSelectRolePositionMethod::crSetSelectRolePositionMethod(const crSetSelectRolePositionMethod& handle):
crMethod(handle),
m_role(handle.m_role),
m_roleIndex(handle.m_roleIndex),
m_dir(handle.m_dir),
m_positionVec(handle.m_positionVec)
{
}
void crSetSelectRolePositionMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_role = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_role = (crInstanceItem *)(LOINT64(param64));
			m_roleIndex = HIINT64(param64);
		}
		else
		{
			m_role = NULL;
			m_roleIndex = 0;
		}
		break;
	}
}
void crSetSelectRolePositionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_dir);
		break;
	default:
		{
			crVector3 pos;
			crArgumentParser::appAtoVec(str,pos);
			m_positionVec.push_back(pos);
		}
		break;
	}
}
void crSetSelectRolePositionMethod::operator()(crHandle &handle)
{
	if(m_role.valid())
	{
		m_role->setDir(m_dir);
		if(m_roleIndex<m_positionVec.size())
		{
			crVector3 pos = m_positionVec[m_roleIndex];
			pos /= crGlobalHandle::gData()->gUnitScale();
			m_role->setPosxy(pos[0],pos[1]);
			m_role->setPosz(pos[2]);
		}
	}
}
/////////////////////////////////////////
//
//crCheckAndLoadGameRolesMethod
//
/////////////////////////////////////////
crCheckAndLoadGameRolesMethod::crCheckAndLoadGameRolesMethod(){}
crCheckAndLoadGameRolesMethod::crCheckAndLoadGameRolesMethod(const crCheckAndLoadGameRolesMethod& handle):
crMethod(handle)
{
}
void crCheckAndLoadGameRolesMethod::inputParam(int i, void *param)
{
}
void crCheckAndLoadGameRolesMethod::addParam(int i, const std::string& str)
{
}
void crCheckAndLoadGameRolesMethod::operator()(crHandle &handle)
{
	crMyPlayerData::getInstance()->lockGameRoleMap();
	GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
	crRole *role;
	for( GameRoleMap::iterator itr = gameRoleMap.begin();
		 itr != gameRoleMap.end();
		 ++itr )
	{
		role = itr->second.get();
		crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(role,HttpD_DownLoadItem));
	}
	crMyPlayerData::getInstance()->unlockGameRoleMap();
}
/////////////////////////////////////////
//
//crSetSelectedRoleMethod
//
/////////////////////////////////////////
crSetSelectedRoleMethod::crSetSelectedRoleMethod(){}
crSetSelectedRoleMethod::crSetSelectedRoleMethod(const crSetSelectedRoleMethod& handle):
crMethod(handle),
m_columnListElement(handle.m_columnListElement)
{
}
void crSetSelectedRoleMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSetSelectedRoleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListElement = str;
		break;
	}
}

void crSetSelectedRoleMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
		if(columnListElement)
		{
			int i = columnListElement->getSelect() - 1;
			if(i>=0)
			{
				crColumnNode *selectNode = columnListElement->getData(i);
				if(selectNode)
				{
					std::string id;
					selectNode->getTitle(0,id);
					int roleid = atoi(id.c_str());
					crRole *gameRole = crMyPlayerData::getInstance()->getGameRole(roleid);
					crMyPlayerData::getInstance()->setSelectedGameRole(gameRole);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crSetSelectedRole2Method
//
/////////////////////////////////////////
crSetSelectedRole2Method::crSetSelectedRole2Method(){}
crSetSelectedRole2Method::crSetSelectedRole2Method(const crSetSelectedRole2Method& handle):
crMethod(handle),
m_columnListWidget(handle.m_columnListWidget)
{
}
void crSetSelectedRole2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crSetSelectedRole2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListWidget = str;
		break;
	}
}

void crSetSelectedRole2Method::operator()(crHandle &handle)
{
	{
		crCanvasNode *canvas = m_this->getParentCanvas();
		if(!canvas) return;

		ref_ptr<crTableWidgetNode> columnListWidget = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_columnListWidget));
		if(columnListWidget.valid())
		{
			int i = columnListWidget->getSelect();
			if(i>=0)
			{
				std::wstring id;
				if(columnListWidget->getData(0,i,id))
				{
					int roleid = _wtoi(id.c_str());
					crRole *gameRole = crMyPlayerData::getInstance()->getGameRole(roleid);
					crMyPlayerData::getInstance()->setSelectedGameRole(gameRole);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crQuerySceneInfoMethod
//
/////////////////////////////////////////
crQuerySceneInfoMethod::crQuerySceneInfoMethod(){}
crQuerySceneInfoMethod::crQuerySceneInfoMethod(const crQuerySceneInfoMethod& handle):
crMethod(handle)
{
}
void crQuerySceneInfoMethod::inputParam(int i, void *param)
{
}
void crQuerySceneInfoMethod::addParam(int i, const std::string& str)
{
}
void crQuerySceneInfoMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	crRole *gameRole = crMyPlayerData::getInstance()->getSelectedGameRole();
	if(gameRole && netConductor)
	{
		int sceneid = gameRole->getSceneID();
		ref_ptr<crTableIO> sceneTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
		if(sceneTab.valid())
		{
			crTableIO::StrVec record;
			if(sceneTab->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
			{
				int scenenameindex = sceneTab->getTitleIndex("scenename");
				int filenameindex = sceneTab->getTitleIndex("filename");
				int	uisceneindex = sceneTab->getTitleIndex("uiscene");
				int collidefileindex = sceneTab->getTitleIndex("collidefile");
				int brainfileindex = sceneTab->getTitleIndex("brainfile");
				int extindex = sceneTab->getTitleIndex("exttype");

				ref_ptr<crQuerySceneInfoData> querySceneInfoData = new crQuerySceneInfoData;
				querySceneInfoData->setSceneID(sceneid);
				querySceneInfoData->setSceneName(record[scenenameindex]);
				querySceneInfoData->setFileName(record[filenameindex]);
				querySceneInfoData->setUIScene(record[uisceneindex]);
				querySceneInfoData->setCollideFile(record[collidefileindex]);
				querySceneInfoData->setBrainFile(record[brainfileindex]);
				if(extindex>0) querySceneInfoData->setExternSceneType(atoi(record[extindex].c_str()));

				crMyPlayerData::getInstance()->setSceneInfoData(querySceneInfoData.get());
				crGlobalHandle::getInstance()->doEvent(WCH_RecvSceneInfo,MAKEINT64(NULL,NULL));
			}
		}
		//crQuerySceneInfoPacket packet;
		//crQuerySceneInfoPacket::buildRequestPacket(packet,sceneid);
		//netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crQuerySceneInfo2Method
//
/////////////////////////////////////////
crQuerySceneInfo2Method::crQuerySceneInfo2Method(){}
crQuerySceneInfo2Method::crQuerySceneInfo2Method(const crQuerySceneInfo2Method& handle):
	crMethod(handle)
{
}
void crQuerySceneInfo2Method::inputParam(int i, void *param)
{
}
void crQuerySceneInfo2Method::addParam(int i, const std::string& str)
{
}
void crQuerySceneInfo2Method::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(room && netConductor)
	{
		int sceneid = room->getSceneID();
		ref_ptr<crTableIO> sceneTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
		if(sceneTab.valid())
		{
			crTableIO::StrVec record;
			if(sceneTab->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
			{
				int scenenameindex = sceneTab->getTitleIndex("scenename");
				int filenameindex = sceneTab->getTitleIndex("filename");
				int	uisceneindex = sceneTab->getTitleIndex("uiscene");
				int collidefileindex = sceneTab->getTitleIndex("collidefile");
				int brainfileindex = sceneTab->getTitleIndex("brainfile");
				int extindex = sceneTab->getTitleIndex("exttype");

				ref_ptr<crQuerySceneInfoData> querySceneInfoData = new crQuerySceneInfoData;
				querySceneInfoData->setSceneID(sceneid);
				querySceneInfoData->setSceneName(record[scenenameindex]);
				querySceneInfoData->setFileName(record[filenameindex]);
				querySceneInfoData->setUIScene(record[uisceneindex]);
				querySceneInfoData->setCollideFile(record[collidefileindex]);
				querySceneInfoData->setBrainFile(record[brainfileindex]);
				if(extindex>0) querySceneInfoData->setExternSceneType(atoi(record[extindex].c_str()));

				crMyPlayerData::getInstance()->setSceneInfoData(querySceneInfoData.get());
				crGlobalHandle::getInstance()->doEvent(WCH_RecvSceneInfo,MAKEINT64(NULL,NULL));
			}
		}
		//crQuerySceneInfoPacket packet;
		//crQuerySceneInfoPacket::buildRequestPacket(packet,sceneid);
		//netConductor->getNetManager()->sendPacket("all",packet);
	}
}
//crLoginSceneMethod::crLoginSceneMethod(){}
//crLoginSceneMethod::crLoginSceneMethod(const crLoginSceneMethod& handle):
//crMethod(handle)
//{
//}
//void crLoginSceneMethod::inputParam(int i, void *param)
//{
//}
//
//void crLoginSceneMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crLoginSceneMethod::operator()(crHandle &handle)
//{
//	bool sucess = false;
//	crQueryGameListData *gameData = crMyPlayerData::getInstance()->getSelectedGame();
//	crQuerySceneInfoData *sceneInfo = crMyPlayerData::getInstance()->getSceneInfoData();
//	if(gameData && sceneInfo)
//	{
//		const std::string& clientcfg = gameData->getClientCfg();
//		int nServer = 1;
//		std::string keyStr = "SceneConnectServer" + crArgumentParser::appItoa(nServer);
//		std::string callback = "SceneConnectServer";
//		std::string serverName = keyStr;
//		std::string serverPassword = keyStr;
//		std::string ip;
//		int port = DEFAULTPORT;
//		int interval = 10;
//		int bufSizeScale = 1.0f;
//
//		const std::string& userName = crMyPlayerData::getInstance()->getPlayerName();
//
//		rcfg::ConfigScript cfg_script;
//		struct stat buf;
//		CRIOManager::crLoadCookFile scopedLoad(clientcfg);
//		if (stat( clientcfg.c_str(), &buf )) 
//		{
//			CRCore::notify(CRCore::FATAL)<<clientcfg<<" open error"<<std::endl;
//			return;
//		}
//
//		if (!cfg_script.Open(clientcfg.c_str()))
//		{
//			CRCore::notify(CRCore::FATAL)<<clientcfg<<" read error "<<cfg_script.GetLastError()<<std::endl;
//			return;
//		}
//		int nScene = 1;
//		std::string sceneName;
//		std::vector<std::string> UsableSceneServerVec;
//		while(cfg_script.Push(keyStr))
//		{
//			nScene = 1;
//			while(cfg_script.Get("SceneName", sceneName,nScene++))
//			{
//				if(sceneName.compare(sceneInfo->getSceneName())==0)
//				{
//					UsableSceneServerVec.push_back(keyStr);
//				}
//			}
//            nServer++;
//			keyStr = "SceneConnectServer" + crArgumentParser::appItoa(nServer);
//			if (!cfg_script.Pop())
//				CRCore::notify(CRCore::FATAL)<<"crLoginSceneMethod Error 检查 "<<clientcfg<<" "<<cfg_script.GetLastError()<<std::endl;
//		}
//		if(!UsableSceneServerVec.empty())
//		{
//			int rndServer = CRCore::rangei(0,UsableSceneServerVec.size()).get_random();
//		    keyStr = UsableSceneServerVec[rndServer];
//			cfg_script.Push(keyStr);
//			cfg_script.Get("NetCallbackString", callback);
//			cfg_script.Get("ServerName", serverName);
//			cfg_script.Get("ServerPassword", serverPassword);
//			cfg_script.Get("IP", ip);
//			cfg_script.Get("Port", port);
//			cfg_script.Get("Interval", interval);
//			cfg_script.Get("BufSizeScale", bufSizeScale);
//
//			if (!cfg_script.Pop())
//				CRCore::notify(CRCore::FATAL)<<"crLoginSceneMethod Error 检查 "<<clientcfg<<" "<<cfg_script.GetLastError()<<std::endl;
//
//			CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
//			netConductor->init(port);
//			netConductor->setNetType(CRNetApp::GameClient_Game);
//			netConductor->setName("GameClient_Game");
//			int code = netConductor->getNetManager()->clientReconnectToServerCircle(ip,callback,userName,serverName,serverPassword,port,bufSizeScale);
//			if(code<=0)
//			{
//				switch (code)
//				{
//				case 0:
//					//无法创建客户端
//					CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<"，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
//					break;
//				case -1:
//					//超出服务器连接人数限制
//					CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
//					break;
//				case -2:
//					//同名客户端已经存在
//					CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
//					break;
//				case -3:
//					//要求连接的服务端名字与本服务器名不同
//					CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
//					break;
//				case -4:
//					//服务器密码不正确
//					CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
//					break;
//				default:
//					CRCore::notify(CRCore::FATAL)<<"无法连接"<<serverName<<std::endl;
//				}
//			}
//			else
//			{
//				CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
//				CRCore::notify(CRCore::ALWAYS)<<"已经与服务器建立连接"<<std::endl;
//
//				crLoginScenePacket packet;
//				crLoginScenePacket::buildRequestPacket(packet);
//				netConductor->getNetManager()->sendPacket("all",packet);
//				sucess = true;
//			}
//		}
//	}
//	handle.outputParam(0,&sucess);
//}
/////////////////////////////////////////
//
//crLoginSceneReturnMethod
//
/////////////////////////////////////////
crLoginSceneReturnMethod::crLoginSceneReturnMethod():
m_loginCode(-1){}
crLoginSceneReturnMethod::crLoginSceneReturnMethod(const crLoginSceneReturnMethod& handle):
crMethod(handle),
m_loginCode(handle.m_loginCode)
{
}
void crLoginSceneReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_loginCode = (char)(LOINT64(param64));
		}
		else
		{
			m_loginCode = -1;
		}
		break;
	}
}

void crLoginSceneReturnMethod::addParam(int i, const std::string& str)
{
}

void crLoginSceneReturnMethod::operator()(crHandle &handle)
{
	//bool success = m_loginCode>0;
	//char mode = crMyPlayerData::getInstance()->getLoginGameSceneMode();
	//if(mode==1)
	//{
	//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	//	stream->createBuf(1);
	//	stream->_writeBool(success);
	//	stream->seekBegin();
	//	crWaitNetReturnStreamLogic::netReturn(stream.get());
	//}
	//else if(mode == 2)
	//{
	//	crMyPlayerData::getInstance()->getPlayerGameData()->doEvent(WCH_LoginSceneReturn,MAKEINT64(m_loginCode,NULL));
	//}
	//else if(success)
	//{
	//	crGlobalHandle::getInstance()->doEvent(WCH_QueryRoleInfo);
	//}
	//else
	//{
	//	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	//	//if(noticeText)
	//	//{
	//	//	noticeText->setText("登陆场景失败...");
	//	//	noticeText->setVisiable(true);
	//	//}
	//	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(28,NULL));
	//	//crWaitStartGameMethod::startGame(0);
	//}
}
/////////////////////////////////////////
//
//crIsNetReturnSuccessMethod
//
/////////////////////////////////////////
crIsNetReturnSuccessMethod::crIsNetReturnSuccessMethod(){}
crIsNetReturnSuccessMethod::crIsNetReturnSuccessMethod(const crIsNetReturnSuccessMethod& handle):
	crMethod(handle)
{
}
void crIsNetReturnSuccessMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	//case 3:
	//	m_stream = (crStreamBuf *)(param);
	//	break;
	}
}
void crIsNetReturnSuccessMethod::addParam(int i, const std::string& str)
{
}
void crIsNetReturnSuccessMethod::operator()(crHandle &handle)
{
	bool success = m_stream.valid() && m_stream->_readChar()>0;
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crIsSuccessMethod
//
/////////////////////////////////////////
crIsSuccessMethod::crIsSuccessMethod():m_code(0){}
crIsSuccessMethod::crIsSuccessMethod(const crIsSuccessMethod& handle):
	crMethod(handle),
	m_code(0)
{
}
void crIsSuccessMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_code = LOINT64(param64);
		}
		break;
	}
}
void crIsSuccessMethod::addParam(int i, const std::string& str)
{
}
void crIsSuccessMethod::operator()(crHandle &handle)
{
	bool success = m_code>0;
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crRecvSceneItemListMethod
//SceneServer
/////////////////////////////////////////
crRecvSceneItemListMethod::crRecvSceneItemListMethod(){}
crRecvSceneItemListMethod::crRecvSceneItemListMethod(const crRecvSceneItemListMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvSceneItemListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvSceneItemListMethod::addParam(int i, const std::string& str)
{
}

void crRecvSceneItemListMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
		if(stream)
		{
			int sceneid = stream->_readInt();
			crScene *scene = netCallback->findScene(sceneid);
			if(scene)
			{
				CRCore::Timer_t start_tick = CRCore::Timer::instance()->tick();
				int itemVecCount = stream->_readInt();
				ref_ptr<crInstanceItem> item;
				for(int i = 0; i<itemVecCount; i++)
				{
					readItem(item,stream,true);
					if(item->getDataClass())
					{
						float posz = scene->getPosZ(item->getLayerID(),item->getPosx() * crGlobalHandle::gData()->gUnitScale(),item->getPosy() * crGlobalHandle::gData()->gUnitScale(), item->getZoffset() * crGlobalHandle::gData()->gUnitScale());
						item->setPosz(posz / crGlobalHandle::gData()->gUnitScale());
						scene->insertSceneItem(item.get());
						item->getDataClass()->excHandle(MAKEINT64(WCH_ServerCheckItemData,item.get()));

						item->doEvent(WCH_ServerLoad);
						if(item->getItemtype()>crInstanceItem::instanceitem)
						{//npc或role
							float rt = 0;
							item->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&rt,NULL));
							item->getDataClass()->inputParam(WCHDATA_RTHP,&rt);
							item->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&rt,NULL));
							item->getDataClass()->inputParam(WCHDATA_RTMP,&rt);
						}
					}
					else
					{
						CRCore::notify(CRCore::ALWAYS)<<"crRecvSceneItemListMethod loaditem 失败instractitemid="<<item->getInstanceItemID()<<std::endl;
					}
				}
				netCallback->initSuccess();
				CRCore::Timer_t end_tick = CRCore::Timer::instance()->tick();
				CRCore::notify(CRCore::ALWAYS)<<"crRecvSceneItemListMethod sceneid:"<<sceneid<<" ItemCount:"<<itemVecCount<<" 耗时"<<CRCore::Timer::instance()->delta_s(start_tick,end_tick)<<"s"<<std::endl;
			}
		}
	}
}
/////////////////////////////////////////
//
//crQueryRoleInfoMethod
//
/////////////////////////////////////////
crQueryRoleInfoMethod::crQueryRoleInfoMethod(){}
crQueryRoleInfoMethod::crQueryRoleInfoMethod(const crQueryRoleInfoMethod& handle):
crMethod(handle)
{
}
void crQueryRoleInfoMethod::inputParam(int i, void *param)
{
}
void crQueryRoleInfoMethod::addParam(int i, const std::string& str)
{
}
void crQueryRoleInfoMethod::operator()(crHandle &handle)
{
	crRole *queryRole = crMyPlayerData::getInstance()->queryFirstRole();
	if(queryRole)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crQueryRoleInfoPacket packet;
			crQueryRoleInfoPacket::buildRequestPacket(packet,queryRole);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
	//else
	//{
	//	std::string str = "请先创建角色！";
	//	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2,NULL));
	//}
}
/////////////////////////////////////////
//
//crRecvRoleInfo2Method
//SceneServer
/////////////////////////////////////////
crRecvRoleInfo2Method::crRecvRoleInfo2Method(){}
crRecvRoleInfo2Method::crRecvRoleInfo2Method(const crRecvRoleInfo2Method& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvRoleInfo2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvRoleInfo2Method::addParam(int i, const std::string& str)
{
}

void crRecvRoleInfo2Method::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		ref_ptr<crInstanceItem> item;
		crStreamBuf *stream = m_recvDataStream->getStream();
		readItem(item,stream,true);//SaveStream
		crRole *role = dynamic_cast<crRole *>(item.get());
		if(role && role->getDataClass())
		{
			//role->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
			int playerid = role->getPlayerID();
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				role->setSceneID(playerData->getSceneID());
				int roomid = playerData->getRoomID();
				role->setRoomID(roomid);
				crScene *scene = netCallback->findScene(role->getSceneID());
				if(scene)
				{
					//ref_ptr<crPlayerGameData> playerGameData;
					//std::string script = scene->getGameName() + "/playergamedata.cfg";
					//ref_ptr<crData> data;
					//std::string cookfilename = script;
					//struct stat buf;
					//CRIOManager::GetCookedFileName(cookfilename);
					//if (!stat( cookfilename.c_str(), &buf )) 
					//{
					//	data = CREncapsulation::loadData(script);
					//	playerGameData = new crPlayerGameData;
					//	playerGameData->setPlayerID(playerid);
					//	playerGameData->setDataClass(data.get());
					//	short streamCount = stream->_readShort();
					//	if(streamCount>0)
					//	{
					//		//crStreamBuf *dataStream = new CRCore::crStreamBuf;
					//		//dataStream->createBuf(streamCount);
					//		//dataStream->write(stream->getPtr(),streamCount);
					//		//dataStream->seekBegin();
					//		//stream->seek(streamCount);
					//		data->inputParam(WCHDATA_PlayerStream,stream);
					//		data->excHandle(MAKEINT64(WCH_InitData,NULL));
					//	}
					//	role->setPlayerGameData(playerGameData.get());
					//}
					int index = -1;
					if(roomid!=0)
					{
						ref_ptr<crRoom> room = netCallback->findRoom(roomid);
						if(room.valid())
						{
							ref_ptr<crRoomPlayer> roomplayer = room->getMember(playerid);
							if(roomplayer.valid())
							{
								//roomplayer->setPlayerGameData(playerGameData.get());
								index = room->getBirthPointIndex(roomplayer.get());
								////将playergameData同步给同房间内的其它玩家
								//data->excHandle(MAKEINT64(WCH_BuildDataStream,PlayerStream));
								//void *param;
								//data->getParam(WCHDATA_DataStream,param);
								//if(param)
								//{
								//	ref_ptr<crStreamBuf> stream = *((ref_ptr<crStreamBuf>*)param);
								//	if(stream.valid())
								//	{
								//		crRoomSetPlayerGameDataPacket packet;
								//		crRoomSetPlayerGameDataPacket::buildReplyPacket(packet,0,playerid,stream.get());
								//		room->sendPacketToAll(packet,playerid);
								//	}
								//}
							}
						}
					}
					if(roomid!=0 || (item->getPosx() == 0.0f && item->getPosy() == 0.0f))
					{//新创建的角色，第一次登陆或者登陆的是房间
						//crVector3i pos = scene->gainBirthPoint(item->getLayerID(),item->getZoffset() * crGlobalHandle::gData()->gUnitScale(),index);
						//item->setPosx(pos[0]);
						//item->setPosy(pos[1]);
						//item->setPosz(pos[2]);
						//scene->gainBirthPoint(item.get(),index);
					}
					else
					{
						float posz = scene->getPosZ(item->getLayerID(),item->getPosx() * crGlobalHandle::gData()->gUnitScale(),item->getPosy() * crGlobalHandle::gData()->gUnitScale(), item->getZoffset() * crGlobalHandle::gData()->gUnitScale());
						item->setPosz(posz / crGlobalHandle::gData()->gUnitScale());
					}
					//scene->insertRoomRole(role);放到RecvCreateSight去做，需要保证创建SightInfo后才能将role添加到场景里。
					playerData->addRole(role);
					crPlayerGameData *playerGameData = playerData->getPlayerGameData();
					role->setPlayerGameData(playerGameData);
					if(playerGameData)
						playerGameData->doEvent(WCH_RecvRoleInfo2,MAKEINT64(playerData.get(),role));
					//CRCore::notify(CRCore::ALWAYS)<<"WCH_ServerCheckRoleData "<<item->getRoleID()<<std::endl;
					item->getDataClass()->excHandle(MAKEINT64(WCH_ServerCheckRoleData,item.get()));
					//CRCore::notify(CRCore::ALWAYS)<<"WCH_ServerCheckRoleData end"<<item->getRoleID()<<std::endl;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvMainRoleMethod
//SceneServer
/////////////////////////////////////////
crRecvMainRoleMethod::crRecvMainRoleMethod(){}
crRecvMainRoleMethod::crRecvMainRoleMethod(const crRecvMainRoleMethod& handle):
	crMethod(handle),
	m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvMainRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvMainRoleMethod::addParam(int i, const std::string& str)
{
}

void crRecvMainRoleMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		ref_ptr<crInstanceItem> item;
		crStreamBuf *stream = m_recvDataStream->getStream();
		readItem(item,stream,false);
		crRole *role = dynamic_cast<crRole *>(item.get());
		if(role)
		{
			role->loadItemData(PlayerStream);
			role->loadMetierData(PlayerStream);
			int playerid = role->getPlayerID();
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				role->setSceneID(playerData->getSceneID());
				role->setRoomID(playerData->getRoomID());
				playerData->getPlayerGameData()->setMainRole(role);
				//CRCore::notify(CRCore::ALWAYS)<<"crRecvMainRoleMethod "<<std::endl;
			}
		}
	}
}
/////////////////////////////////////////
//
//crServerCheckRoleDataMethod
//SceneServer
/////////////////////////////////////////
crServerCheckRoleDataMethod::crServerCheckRoleDataMethod(){}
crServerCheckRoleDataMethod::crServerCheckRoleDataMethod(const crServerCheckRoleDataMethod& handle):
crMethod(handle)
{
}
void crServerCheckRoleDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}

void crServerCheckRoleDataMethod::addParam(int i, const std::string& str)
{
}

void crServerCheckRoleDataMethod::operator()(crHandle &handle)
{
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			//float rt = 0;
			//m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&rt,NULL));
			//m_this->getDataClass()->inputParam(WCHDATA_RTHP,&rt);
			//m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&rt,NULL));
			//m_this->getDataClass()->inputParam(WCHDATA_RTMP,&rt);

			/////write and send
			int count = 0;
			std::vector< ref_ptr<crStreamBuf> > BufVec;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(MTUBUFFERSIZE);//MAXBUFFERSIZE-12);

			writeItem(m_this,stream,BufVec,count,PlayerStream);
			////write playergamedata
			//crStreamBuf *playerGameStream = NULL;
			//crPlayerGameData *playerGameData = m_this->getPlayerGameData();
			//writeStreamVec(stream,2,BufVec,count);
			//if(playerGameData)
			//{
			//	crData *data = playerGameData->getDataClass();
			//	if(data)
			//	{
			//		data->excHandle(MAKEINT64(WCH_BuildDataStream,PlayerStream));
			//		void *param;
			//		data->getParam(WCHDATA_DataStream,param);
			//		if(param)
			//		{
			//			ref_ptr<crStreamBuf> dataStream = *((ref_ptr<crStreamBuf>*)param);
			//			if(dataStream.valid())
			//			{
			//				playerGameStream = dataStream.get();
			//			}
			//		}
			//	}
			//}
			//if(!playerGameStream || playerGameStream->getBufSize() == 0)
			//{
			//	stream->_writeShort(0);//2
			//}
			//else
			//{
			//	stream->_writeShort(playerGameStream->getBufSize());
			//	writeLongStream(stream,playerGameStream,BufVec,count);
			//}

			if(stream->getBufSize()>0)
			{
				count += stream->getBufSize();
				BufVec.push_back(stream.get());
			}
			//CRCore::notify(CRCore::ALWAYS)<<"crServerCheckRoleDataMethod count = "<<count<<" playerid = "<<playerid<<std::endl;
			if(count>0)
			{
				int streamid = crDataStreamTransfer::getInstance()->gainStreamID();
				crQueryRoleInfoPacket packet;
				crQueryRoleInfoPacket::buildReplyPacket(packet,playerid,streamid,count);
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				crDataStreamPacket streamPacket;
				for( std::vector< ref_ptr<crStreamBuf> >::iterator itr = BufVec.begin();
					itr != BufVec.end();
					++itr )
				{
					crDataStreamPacket::buildRequestPacket(streamPacket,playerid,streamid,crQueryRoleInfoPacket::ID,itr->get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),streamPacket);
				}
				crDataStreamTransfer::getInstance()->recycleStreamID(streamid,crGlobalHandle::gData()->gRecycleStreamIDTime_out());
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvRoleInfoMethod
//
/////////////////////////////////////////
crRecvRoleInfoMethod::crRecvRoleInfoMethod(){}
crRecvRoleInfoMethod::crRecvRoleInfoMethod(const crRecvRoleInfoMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvRoleInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvRoleInfoMethod::addParam(int i, const std::string& str)
{
}

void crRecvRoleInfoMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		ref_ptr<crInstanceItem> item;
		crStreamBuf *stream = m_recvDataStream->getStream();
		readItem(item,stream,false);
		crRole *role = dynamic_cast<crRole *>(item.get());

		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		if(playerGameData && playerGameData->getMainRoleID() == role->getRoleID())
		{
			playerGameData->setMainRole(role);
			crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
		}
		else
		{
			crRunGameHandle::getInstance()->addRole(role);
			//crMyPlayerData::getInstance()->addRole(role);
			//role->setPlayerGameData(playerGameData);
			crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_EnterSceneSuccess));
		}
	}
}
/////////////////////////////////////////
//
//crRecvItemMethod
//
/////////////////////////////////////////
crRecvItemMethod::crRecvItemMethod(){}
crRecvItemMethod::crRecvItemMethod(const crRecvItemMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvItemMethod::addParam(int i, const std::string& str)
{
}

void crRecvItemMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		ref_ptr<crInstanceItem> item;
		readItem(item,m_recvDataStream->getStream(),false);
        crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
	}
}
/////////////////////////////////////////
//
//crInitNetGameMethod
//
/////////////////////////////////////////
crInitNetGameMethod::crInitNetGameMethod(){}
crInitNetGameMethod::crInitNetGameMethod(const crInitNetGameMethod& handle):
crMethod(handle)
{
}
void crInitNetGameMethod::inputParam(int i, void *param)
{
}

void crInitNetGameMethod::addParam(int i, const std::string& str)
{
}

void crInitNetGameMethod::operator()(crHandle &handle)
{
	const std::string &path = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
	DeleteObject(CRGUI::crWindow::s_defaultCursor);
	std::string file = path+"/script/ui/default.ani";
    CRGUI::crWindow::s_defaultCursor = (HCURSOR)LoadImage(GetModuleHandle(NULL),file.c_str(),IMAGE_CURSOR,0,0,LR_LOADFROMFILE);
	CREncapsulation::loadGameStageCfg(path);
}
/////////////////////////////////////////
//
//crFinitNetGameMethod
//
/////////////////////////////////////////
crFinitNetGameMethod::crFinitNetGameMethod(){}
crFinitNetGameMethod::crFinitNetGameMethod(const crFinitNetGameMethod& handle):
crMethod(handle)
{
}
void crFinitNetGameMethod::inputParam(int i, void *param)
{
}

void crFinitNetGameMethod::addParam(int i, const std::string& str)
{
}

void crFinitNetGameMethod::operator()(crHandle &handle)
{
	DeleteObject(CRGUI::crWindow::s_defaultCursor);
	crWindow::s_defaultCursor = LoadCursor(NULL,IDC_ARROW);
}
/////////////////////////////////////////
//
//crRunNetGameMethod
//
/////////////////////////////////////////
crRunNetGameMethod::crRunNetGameMethod(){}
crRunNetGameMethod::crRunNetGameMethod(const crRunNetGameMethod& handle):
crMethod(handle)/*,
m_loadingDlgID(handle.m_loadingDlgID),
m_loadingProgress(handle.m_loadingProgress)*/
{
}
void crRunNetGameMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}
void crRunNetGameMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_loadingDlgID = str;
	//	break;
	//case 1:
	//	m_loadingProgress = str;
	//	break;
	//}
}

void crRunNetGameMethod::operator()(crHandle &handle)
{
	//CRGUI::crImageStage *imageStage = CRGUI::cr2DStageManager::getInstance()->findStage(m_loadingDlgID);
	//if(imageStage)
	//{
	//	while(!imageStage->getIsOnShow())
	//	{
	//		CRCore::crThread::sleep(1);
	//	}
	//}
	crMyPlayerData::getInstance()->setExitCode(EC_ExitGame);
	
	//crImageStage *stage = m_element->getParentStage();
	CREncapsulation::crStartHandler::getInstance()->setLoader(new CRNetApp::crNetStartLoader);
	crRunGameHandle::getInstance()->start();
	CREncapsulation::crStartHandler::getInstance()->start( CRProducer::crViewer::CURSOR_NULL,
		CRUtil::crSceneView::STANDARD_SETTINGS|CRUtil::crSceneView::USEPHYSICS|CRUtil::crSceneView::USEAI/*|CRUtil::crSceneView::SKY_LIGHT*/,NULL);

	//if(imageStage)
	//{//可以做一个延迟几秒关闭的函数
	//	CRGUI::crProgressElement *upd_element = dynamic_cast<CRGUI::crProgressElement *>(imageStage->getElement(m_loadingProgress));
	//	upd_element->fetchEnd();
	//	CRGUI::cr2DStageManager::getInstance()->close(imageStage);
	//}
	crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::getInstance()->getRunCode());
	ref_ptr<crNetConductor> sceneServer = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(sceneServer.valid())
	{
		crSetClientRunningPacket packet;
		crSetClientRunningPacket::buildRequestPacket(packet,true);
		sceneServer->getNetManager()->sendPacket("all",packet);
	}
	crBrain::getInstance()->doEvent(WCH_SceneStart);
	//crFilterRenderManager::getInstance()->closeCanvas("LoadingUI");
	CREncapsulation::crStartHandler::getInstance()->run();
	sceneServer = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(sceneServer.valid())
	{
		crSetClientRunningPacket packet;
		crSetClientRunningPacket::buildRequestPacket(packet,false);
		sceneServer->getNetManager()->sendPacket("all",packet);
	}
	crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::SwitchScene);
	crShaderManager::getInstance()->clear();
	crLightSourceManager::getInstance()->clear();
	CRNetApp::crScene::clearCollideMap();

	//CRAL::crSoundManager::instance()->loadSound("script/sound0.cfg");
	//crBrain::getInstance()->pushInstance(CRAL::crSoundManager::instance());
	CREncapsulation::crStartHandler::getInstance()->end();
}
/////////////////////////////////////////
//
//crSetRunSceneIDMethod
//
/////////////////////////////////////////
crSetRunSceneIDMethod::crSetRunSceneIDMethod():m_sceneid(1){}
crSetRunSceneIDMethod::crSetRunSceneIDMethod(const crSetRunSceneIDMethod& handle):
crMethod(handle),
m_sceneid(handle.m_sceneid)
{
}
void crSetRunSceneIDMethod::inputParam(int i, void *param)
{
}
void crSetRunSceneIDMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sceneid = atoi(str.c_str());
		break;
	}
}

void crSetRunSceneIDMethod::operator()(crHandle &handle)
{
	crData *data = crRunGameHandle::getInstance()->getDataClass();
	data->inputParam(WCHDATA_SceneID,&m_sceneid);
}
/////////////////////////////////////////
//
//crSetLoadingProgressMethod
//
/////////////////////////////////////////
crSetLoadingProgressMethod::crSetLoadingProgressMethod():m_progress(0){}
crSetLoadingProgressMethod::crSetLoadingProgressMethod(const crSetLoadingProgressMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crSetLoadingProgressMethod::inputParam(int i, void *param)
{
}
void crSetLoadingProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = atof(str.c_str());
		break;
	}
}

void crSetLoadingProgressMethod::operator()(crHandle &handle)
{
	crRunGameHandle::getInstance()->setLoadingProgress(m_progress);
}
/////////////////////////////////////////
//
//crRunGameMethod
//
/////////////////////////////////////////
crRunGameMethod::crRunGameMethod(){}
crRunGameMethod::crRunGameMethod(const crRunGameMethod& handle):
crMethod(handle)
//m_sceneFile(handle.m_sceneFile),
//m_uifile(handle.m_uifile),
//m_brainScript(handle.m_brainScript),
//m_loadingDlgID(handle.m_loadingDlgID),
//m_loadingProgress(handle.m_loadingProgress)
{
}
void crRunGameMethod::inputParam(int i, void *param)
{
}
void crRunGameMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	////case 0:
	////	m_sceneFile = str;
	////	break;
	////case 1:
	////	m_uifile = str;
	////	break;
	////case 2:
	////	m_brainScript = str;
	////	break;
	//case 0:
	//	m_loadingDlgID = str;
	//	break;
	//case 1:
	//	m_loadingProgress = str;
	//	break;
	//}
}

void crRunGameMethod::operator()(crHandle &handle)
{
	//CRGUI::crImageStage *imageStage = CRGUI::cr2DStageManager::getInstance()->findStage(m_loadingDlgID);
	//if(imageStage)
	//{
	//	while(!imageStage->getIsOnShow())
	//	{
	//		CRCore::crThread::sleep(1);
	//	}
	//}
	ref_ptr<crTableIO> table = crTableIO::openFile("script/scene.crb");
	crData *data = crRunGameHandle::getInstance()->getDataClass();
	void *param;
	data->getParam(WCHDATA_SceneID,param);
	short sceneid = *(short *)param;
	crTableIO::StrVec record;
	if(table.valid() && table->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
	{
		std::string sceneName = record[1];
		std::string sceneFile = record[2];
		std::string uifile = record[3];
		std::string brainScript = record[5];
		if(brainScript.empty())
			brainScript = "script/brain/" + sceneName + ".cfg";
		else
		{
			brainScript = crGlobalHandle::getInstance()->getScriptDir() + brainScript;
		}
		if(crDisplaySettings::instance()->getRunMode() >= crDisplaySettings::Robot)
			sceneFile = "NewScene.crs";
		data->inputParam(WCHDATA_SceneFile,&sceneFile);
		data->inputParam(WCHDATA_UIFile,&uifile);
		data->inputParam(WCHDATA_BrainScript,&brainScript);

		char gbuf[256];
		sprintf(gbuf,"当前场景:%s\n\0",sceneName.c_str());
		gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
		CREncapsulation::crStartHandler::getInstance()->setLoader(new CRNetApp::crLoginStartLoader);
		crRunGameHandle::getInstance()->start();
		CREncapsulation::crStartHandler::getInstance()->start( CRProducer::crViewer::CURSOR_NULL,
			CRUtil::crSceneView::STANDARD_SETTINGS|CRUtil::crSceneView::USEPHYSICS|CRUtil::crSceneView::USEAI,
			crRunGameHandle::getInstance()->getParentWnd(),
			crRunGameHandle::getInstance()->getRenderWnd());
		//if(imageStage)
		//{//可以做一个延迟几秒关闭的函数
		//	CRGUI::crProgressElement *upd_element = dynamic_cast<CRGUI::crProgressElement *>(imageStage->getElement(m_loadingProgress));
		//	upd_element->fetchEnd();
		//	CRGUI::cr2DStageManager::getInstance()->close(imageStage);
		//}
		//CRGUI::cr2DStageManager::getInstance()->close(m_loadingDlgID);

		crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::getInstance()->getRunCode());
		crBrain::getInstance()->doEvent(WCH_SceneStart);
		//crFilterRenderManager::getInstance()->closeCanvas("LoadingUI");
		CREncapsulation::crStartHandler::getInstance()->run();
		crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::SwitchScene);
		crMyPlayerData::getInstance()->clear();
		crShaderManager::getInstance()->clear();
		crLightSourceManager::getInstance()->clear();

		//CRAL::crSoundManager::instance()->loadSound("script/sound0.cfg");
		//crBrain::getInstance()->pushInstance(CRAL::crSoundManager::instance());
		CREncapsulation::crStartHandler::getInstance()->end();
	}
}
/////////////////////////////////////////
//
//crRunGame2Method
//
/////////////////////////////////////////
crRunGame2Method::crRunGame2Method(){}
crRunGame2Method::crRunGame2Method(const crRunGame2Method& handle):
	crMethod(handle)/*,
					m_loadingDlgID(handle.m_loadingDlgID),
					m_loadingProgress(handle.m_loadingProgress)*/
{
}
void crRunGame2Method::inputParam(int i, void *param)
{
}
void crRunGame2Method::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_loadingDlgID = str;
	//	break;
	//case 1:
	//	m_loadingProgress = str;
	//	break;
	//}
}

void crRunGame2Method::operator()(crHandle &handle)
{
	//CRGUI::crImageStage *imageStage = CRGUI::cr2DStageManager::getInstance()->findStage(m_loadingDlgID);
	//if(imageStage)
	//{
	//	while(!imageStage->getIsOnShow())
	//	{
	//		CRCore::crThread::sleep(1);
	//	}
	//}
	CRCore::Timer_t start_tick = CRCore::Timer::instance()->tick();
	CRCore::Timer_t end_tick;

	const std::string &gameName = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
	//std::string sceneTab = gameName + "/scene.tab";
	//ref_ptr<crTableIO> table = new crTableIO;
	//if(table->openFile(sceneTab))
	ref_ptr<crTableIO> table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
	crData *data = crRunGameHandle::getInstance()->getDataClass();
	void *param;
	data->getParam(WCHDATA_SceneID,param);
	short sceneid = *(short *)param;
	crTableIO::StrVec record;
	if(table.valid() && table->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
	{
		std::string sceneName = record[1];
		std::string sceneFile = record[2];
		std::string uifile = record[3];
		std::string brainScript = record[5];
		if(brainScript.empty())
			brainScript = gameName + "/script/brain/" + sceneName + ".cfg";
		else
		{
			brainScript = crGlobalHandle::getInstance()->getScriptDir() + brainScript;
		}
		if(sceneid>1 && crDisplaySettings::instance()->getRunMode() >= crDisplaySettings::Robot)
		{
			sceneFile = "RobotManor.crs";
		}
		data->inputParam(WCHDATA_SceneFile,&sceneFile);
		data->inputParam(WCHDATA_UIFile,&uifile);
		data->inputParam(WCHDATA_BrainScript,&brainScript);

		char gbuf[256];
		sprintf(gbuf,"当前场景:%s\n\0",sceneName.c_str());
		gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
		CREncapsulation::crStartHandler::getInstance()->setLoader(new CRNetApp::crLoginStartLoader2);
		crRunGameHandle::getInstance()->start();
		CREncapsulation::crStartHandler::getInstance()->start( CRProducer::crViewer::CURSOR_NULL,
			CRUtil::crSceneView::STANDARD_SETTINGS|CRUtil::crSceneView::USEPHYSICS|CRUtil::crSceneView::USEAI,
			crRunGameHandle::getInstance()->getParentWnd(),
			crRunGameHandle::getInstance()->getRenderWnd());

		//if(imageStage)
		//{//可以做一个延迟几秒关闭的函数
		//	CRGUI::crProgressElement *upd_element = dynamic_cast<CRGUI::crProgressElement *>(imageStage->getElement(m_loadingProgress));
		//	upd_element->fetchEnd();
		//	CRGUI::cr2DStageManager::getInstance()->close(imageStage);
		//}
		crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::getInstance()->getRunCode());
		end_tick = CRCore::Timer::instance()->tick();
		sprintf(gbuf,"RunGame2 LoadScene:%s,LoadTime:%f\n\0",sceneFile.c_str(),CRCore::Timer::instance()->delta_s(start_tick,end_tick));
		gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);

		start_tick = CRCore::Timer::instance()->tick();
		crBrain::getInstance()->doEvent(WCH_SceneStart);

		end_tick = CRCore::Timer::instance()->tick();
		sprintf(gbuf,"RunGame2 SceneStart Time:%f\n\0",CRCore::Timer::instance()->delta_s(start_tick,end_tick));
		gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);

		//crFilterRenderManager::getInstance()->closeCanvas("LoadingUI");
		CREncapsulation::crStartHandler::getInstance()->run();
		crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::SwitchScene);
		crMyPlayerData::getInstance()->clear();
		crShaderManager::getInstance()->clear();
		crLightSourceManager::getInstance()->clear();
		CREncapsulation::crStartHandler::getInstance()->end();
	}
}
/////////////////////////////////////////
//
//crRunNetGame2Method
//
/////////////////////////////////////////
crRunNetGame2Method::crRunNetGame2Method(){}
crRunNetGame2Method::crRunNetGame2Method(const crRunNetGame2Method& handle):
crMethod(handle)/*,
m_loadingDlgID(handle.m_loadingDlgID),
m_loadingProgress(handle.m_loadingProgress)*/
{
}
void crRunNetGame2Method::inputParam(int i, void *param)
{
}
void crRunNetGame2Method::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_loadingDlgID = str;
	//	break;
	//case 1:
	//	m_loadingProgress = str;
	//	break;
	//}
}

void crRunNetGame2Method::operator()(crHandle &handle)
{
	//CRGUI::crImageStage *imageStage = CRGUI::cr2DStageManager::getInstance()->findStage(m_loadingDlgID);
	//if(imageStage)
	//{
	//	while(!imageStage->getIsOnShow())
	//	{
	//		CRCore::crThread::sleep(1);
	//	}
	//}
	CRCore::Timer_t start_tick = CRCore::Timer::instance()->tick();
	CRCore::Timer_t end_tick;

	crMyPlayerData::getInstance()->setExitCode(EC_ExitGame);
	
	crQuerySceneInfoData *sceneInfoData = crMyPlayerData::getInstance()->getSceneInfoData();
	if(!sceneInfoData)
	{
		CRCore::notify(CRCore::FATAL)<<"Loading Error 没有指定场景..."<< std::endl;
		crRunGameHandle::getInstance()->setRunCode(1);
		return;
	}
	const std::string &gameName = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
	const std::string& sceneName = sceneInfoData->getSceneName();
	crSceneManager::getInstance()->setCurrentSceneName(sceneName);
	std::string sceneFile = sceneInfoData->getFileName();
	std::string uifile = sceneInfoData->getUIScene();//crMyPlayerData::getInstance()->getSelectedGame()->getUIFile();
	std::string brainScript = sceneInfoData->getBrainFile();
	if(brainScript.empty())
		brainScript = gameName + "/script/brain/" + sceneName + ".cfg";
	else
	{
		brainScript = crGlobalHandle::getInstance()->getScriptDir() + brainScript;
	}
	crData *data = crRunGameHandle::getInstance()->getDataClass();
	if(crDisplaySettings::instance()->getRunMode() >= crDisplaySettings::Robot)
	{
		sceneFile = "Robot.crs";
	}
	
	data->inputParam(WCHDATA_SceneFile,&sceneFile);
	data->inputParam(WCHDATA_UIFile,&uifile);
	data->inputParam(WCHDATA_BrainScript,&brainScript);
	//int sceneid = sceneInfoData->getSceneID();
	//data->inputParam(WCHDATA_SceneID,&sceneid);
	
	char gbuf[256];
	sprintf(gbuf,"当前场景:%s\n\0",sceneName.c_str());
	gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
	CREncapsulation::crStartHandler::getInstance()->setLoader(new CRNetApp::crNetStartLoader2);
	crRunGameHandle::getInstance()->start();
	CREncapsulation::crStartHandler::getInstance()->start( CRProducer::crViewer::CURSOR_NULL,
		CRUtil::crSceneView::STANDARD_SETTINGS|CRUtil::crSceneView::USEPHYSICS|CRUtil::crSceneView::USEAI,
		crRunGameHandle::getInstance()->getParentWnd(),
		crRunGameHandle::getInstance()->getRenderWnd());

	//if(imageStage)
	//{//可以做一个延迟几秒关闭的函数
	//	CRGUI::crProgressElement *upd_element = dynamic_cast<CRGUI::crProgressElement *>(imageStage->getElement(m_loadingProgress));
	//	upd_element->fetchEnd();
	//	CRGUI::cr2DStageManager::getInstance()->close(imageStage);
	//}
	crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::getInstance()->getRunCode());
	ref_ptr<crNetConductor> sceneServer = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(sceneServer.valid())
	{
		crSetClientRunningPacket packet;
		crSetClientRunningPacket::buildRequestPacket(packet,true);
		sceneServer->getNetManager()->sendPacket("all",packet);
	}
	end_tick = CRCore::Timer::instance()->tick();
	sprintf(gbuf,"RunNetGame2 LoadScene:%s,LoadTime:%f\n\0",sceneFile.c_str(),CRCore::Timer::instance()->delta_s(start_tick,end_tick));
	gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);

	start_tick = CRCore::Timer::instance()->tick();
	crBrain::getInstance()->doEvent(WCH_SceneStart);

	end_tick = CRCore::Timer::instance()->tick();
	sprintf(gbuf,"RunNetGame2 SceneStart Time:%f\n\0",CRCore::Timer::instance()->delta_s(start_tick,end_tick));
	gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);

	//crFilterRenderManager::getInstance()->closeCanvas("LoadingUI");
	CREncapsulation::crStartHandler::getInstance()->run();
	sceneServer = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(sceneServer.valid())
	{
		crSetClientRunningPacket packet;
		crSetClientRunningPacket::buildRequestPacket(packet,false);
		sceneServer->getNetManager()->sendPacket("all",packet);
	}
	crRunGameHandle::getInstance()->setRunningCode(crRunGameHandle::SwitchScene);
	crMyPlayerData::getInstance()->clear();
	crShaderManager::getInstance()->clear();
	crLightSourceManager::getInstance()->clear();
	CRNetApp::crScene::clearCollideMap();

	//CRAL::crSoundManager::instance()->loadSound("script/sound0.cfg");
	//crBrain::getInstance()->pushInstance(CRAL::crSoundManager::instance());
	//sceneServer = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	CREncapsulation::crStartHandler::getInstance()->end();
}
/////////////////////////////////////////
//
//crPlayerInRangeTestMethod
//
/////////////////////////////////////////
crPlayerInRangeTestMethod::crPlayerInRangeTestMethod(){}
crPlayerInRangeTestMethod::crPlayerInRangeTestMethod(const crPlayerInRangeTestMethod& handle):
crMethod(handle)
{
}
void crPlayerInRangeTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_sight = NULL;
			m_role2 = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_sight = (crSightInfo *)(LOINT64(param64));
			m_role2 = (crRole *)(HIINT64(param64));
		}
		else
		{
			m_sight = NULL;
			m_role2 = NULL;
		}
		break;
	}
}

void crPlayerInRangeTestMethod::addParam(int i, const std::string& str)
{
}

void crPlayerInRangeTestMethod::operator()(crHandle &handle)
{
	if(m_sight && m_role2 && m_role2->getDataClass())
	{
		unsigned int guisestate = GS_Normal;
		m_role2->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable || (guisestate & GS_Hide && !(guisestate & GS_UnHide)))
		{
			if(m_sight->isRoleInSight(m_role2))
			{
				m_sight->insertOutSightItem(m_role2);
			}
			return;
		}
		crData *data = m_this->getDataClass();
		void *param;
		if(guisestate & GS_Static)
		{
			unsigned char itemstate;
			data->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
			{
				if(m_sight->isRoleInSight(m_role2))
				{
					m_sight->insertOutSightItem(m_role2);
				}
				return;
			}
		}
		//data->getParam(WCHDATA_GuiseState,param);
		//if(param)
		//{
		//	unsigned char guiseState = *(unsigned char *)param;
		//	if(guiseState == GS_UnVisiable || guiseState == GS_StaticUnVisiable)
		//	{//
		//		if(m_sight->isRoleInSight(m_role2))
		//		{
		//			m_sight->insertOutSightItem(m_role2);
		//		}
		//		return;
		//	}
		//}
		bool inRange = true;
		//data->getParam(WCHDATA_SightRange,param);
		//short sightRange = *((short*)param);
		float sightRange = 0;
		m_this->doEvent(MAKEINT64(WCH_GetSightRange,NULL),MAKEINT64(&sightRange,NULL));

		float stealth = 0;
		m_role2->doEvent(MAKEINT64(WCH_GetStealth,NULL),MAKEINT64(&stealth,NULL));
		if(stealth>0.0f)
		{
			float stealthspy = 0;
			m_this->doEvent(MAKEINT64(WCH_GetStealthSpy,NULL),MAKEINT64(&stealthspy,NULL));
			stealth -= stealthspy;
			if(stealth<0.0f)
				stealth = 0.0f;
		}
		sightRange -= stealth;

		crVector2i thisPos(m_this->getPosx(), m_this->getPosy());//,m_this->getPosz());
		crVector2i rolePos2(m_role2->getPosx(), m_role2->getPosy());// , m_role2->getPosz());
		int dist2 = (thisPos - rolePos2).length2();// / crGlobalHandle::gData()->gUnitScale();
		if (/*sightRange>0.0f && */dist2>sightRange*sightRange)
		{
			inRange = false;
		}
		if(inRange)
		{
			m_sight->insertInSightRole(m_role2);
		}
		else/* if(m_player->getRoomID()==0)*/
		{//非开房间游戏模式
			if(m_sight->isRoleInSight(m_role2))
			{
				m_sight->insertOutSightItem(m_role2);
			}
		}
		if(m_this->getItemtype() == crInstanceItem::Npc)
		{
			//void *param;
			//int enmity = 0;
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_EnmityMap,param);
			//EnmityMap *enmityMap = (EnmityMap *)param;
			//_crInt64 id = MAKEINT64(m_role2->getRoleID(),m_role2->getID());
			//EnmityMap::iterator eitr = enmityMap->find(id);
			//if(eitr!=enmityMap->end())
			//	enmity = eitr->second;
			//data->excHandle(MAKEINT64(WCH_LockData,0));
			if(inRange/*||enmity>0*/)
			{
				//if(inRange)
				//{
				//	crData *itemdata = m_role2->getDataClass();
				//	itemdata->getParam(WCHDATA_BaseEnmity,param);
				//	enmity += *(int*)param;
				//}
				crData *data2 = m_role2->getDataClass();
				data2->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
				{
					char isEnemy = 0;
					m_this->doEvent(WCH_EnemyCheck,MAKEINT64(m_role2,&isEnemy));
					if(isEnemy == -1)
					{
						//_crInt64 distEnmity = MAKEINT64(-(int)dist,enmity);
						m_this->doEvent(WCH_InPatrolTest, MAKEINT64(m_role2, dist2));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crLoadItemMethod
//
/////////////////////////////////////////
crLoadItemMethod::crLoadItemMethod(){}
crLoadItemMethod::crLoadItemMethod(const crLoadItemMethod& handle):
crMethod(handle)
{
}
void crLoadItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_item = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_item = NULL;
		}
		break;
	}
}

void crLoadItemMethod::addParam(int i, const std::string& str)
{
}

void crLoadItemMethod::operator()(crHandle &handle)
{
	if(m_item.valid()/*&&crRunGameHandle::getInstance()->isInGame()*/)
	{
		crData *itemdata;
		void *param;
		unsigned char itemtype = m_item->getItemtype();
		if(itemtype == crInstanceItem::Emporium)
		{
			crMyPlayerData::getInstance()->getScene()->setEmporium(m_item.get());
			m_item->loadItemData(NetStream);
			itemdata = m_item->getDataClass();
			itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
		}
		else if(itemtype>=crInstanceItem::Npc && itemtype<=crInstanceItem::Role)
		{
			crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
			if(myPlayer && dynamic_cast<crRole *>(m_item.get()) && myPlayer->getMainRole() == m_item.get())
			{
				m_item->loadItemData(PlayerStream);
				itemdata = m_item->getDataClass();
				itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
				if(itemtype == crInstanceItem::Role)
				{
					(dynamic_cast<crRole *>(m_item.get()))->loadMetierData(PlayerStream);
				}
				crGlobalHandle::getInstance()->setStartupLoadingProgress(1.0f);
				crGlobalHandle::getInstance()->doEvent(WCH_LoginGameReturn,MAKEINT64(crMyPlayerData::getInstance()->getLoadMainRoleCase(),NULL));
			}
			else if(!m_item->getAbstractItem())
			{
				if(itemtype == crInstanceItem::Role)
				{
					(dynamic_cast<crRole *>(m_item.get()))->loadMetierData(NetStream);
				}
			}
			else if(m_item->getInstanceItemID() == 0)
			{
				if(itemtype == crInstanceItem::Role)
				{
					(dynamic_cast<crRole *>(m_item.get()))->loadMetierData(NetStream);
				}
			}
			else if(m_item->getAbstractItem()->getFileName().empty())
			{
				m_item->loadItemData(NetStream);
				itemdata = m_item->getDataClass();
				itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
				if(itemtype == crInstanceItem::Role)
				{
					(dynamic_cast<crRole *>(m_item.get()))->loadMetierData(NetStream);
				}
			}
			else
			{
				m_item->loadItemData(NetStream);
				CRCore::ref_ptr<crNPC> npc = new crNPC;
				//std::string name;
				//if(m_item->getRoomID()>0 && itemtype == crInstanceItem::Role)
				//{
				//	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
				//	crRoom::crRoomPlayer *player = room->getMember(m_item->getID());
				//	name = player->getPlayerName();
				//}
				//else
				//{
				//	name = m_item->getIName();
				//}
				loadNPCCfg(m_item->getIName(),m_item->getAbstractItem()->getResScript(),npc.get(),m_item->getAbstractItem()->getFileName());
				crViewMatterObject *bot = npc->getNPCBot();
				if(!bot)
				{
					CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod::operator() loadNPCCfg error"<<std::endl;
					return;
				}
				itemdata = m_item->getDataClass();
				itemdata->getParam(WCHDATA_HalfPhysicsBox,param);
				crVector3 halfPhysicsBox = *(crVector3 *)param;
				bot->setPhysicsBox(halfPhysicsBox*2.0f);

				//crAcceptGIVisitor acceptGI(1);
				//bot->accept(acceptGI);
				//m_item->setPosz(m_item->getPosz()/*+50*/);
				//bot->setPosition(crVector3(m_item->getPosx() * crGlobalHandle::gData()->gUnitScale(),m_item->getPosy() * crGlobalHandle::gData()->gUnitScale(), m_item->getPosz() * crGlobalHandle::gData()->gUnitScale()));
				m_item->setNode(npc->getNPCBody());
				bot->getDataClass()->inputParam(WCHDATA_Item,m_item.get());
				crData *itemdata = m_item->getDataClass();
				itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
				//m_item->clientLoadItemChild();
				unsigned char itemstate = IS_Stop;//IS_ItemLoad;
				itemdata->inputParam(WCHDATA_ItemState,&itemstate);

				m_item->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
				if(itemtype == crInstanceItem::Role)
				{
					(dynamic_cast<crRole *>(m_item.get()))->loadMetierData(NetStream);
					crMyPlayerData::getInstance()->insertInRangePlayer(dynamic_cast<crRole *>(m_item.get()),npc.get());
					m_item->doEvent(WCH_CheckAndRackEquipOnMesh,NULL);
				}
				else
				{
					crMyPlayerData::getInstance()->insertInRangeNpc(m_item.get(),npc.get());
				}

				int runcode = crRunGameHandle::getInstance()->getRunningCode();
				if( runcode == crRunGameHandle::RoleSelect)
				{
					//角色选择场景
					//m_item->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
					bot->setVisiable(true);
					bot->setEnableIntersect(true);
					//bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				}
				else if( runcode >= crRunGameHandle::NetGame)
				{//NetGame
					////bot->doEvent(MAKEINT64(WCH_AITASK,5),MAKEINT64(MAKEINT32(WCHAI_Begin,WCHAI_SetCPToBot),NULL));
					bot->doEvent(WCH_RequestItemRTData);
				}

				float rt = 0;
				m_item->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&rt,NULL));
				itemdata->inputParam(WCHDATA_RTHP,&rt);
				m_item->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&rt,NULL));
				itemdata->inputParam(WCHDATA_RTMP,&rt);
			}
		}
		else if(itemtype == crInstanceItem::instanceitem)
		{
			m_item->loadItemData(NetStream);
			itemdata = m_item->getDataClass();
			itemdata->getParam(WCHDATA_DataType,param);
			ref_ptr<crGroup> group;
			if(param)
			{
				unsigned char datatype = *((unsigned char*)param);
				if(datatype == DT_Box)
				{
					group = new crBoxMatterObject;
				}
				else if(datatype == DT_Sphere)
				{
					group = new crSphereMatterObject;
				}
			}
			if(!group.valid())
			{
				group = new crMatrixTransform;
			}
			group->setVisiable(false);
			group->setName(m_item->getIName());
			const std::string &filename = m_item->getAbstractItem()->getFileName();
			if(!filename.empty())
			{
				CRCore::ref_ptr<crGroup> proxyNode = new crGroup;
				CRIOManager::crLoadManager::getInstance()->requestNode(filename,proxyNode.get(),false);
				if(proxyNode->getNumChildren()==1)
				{
					crNode *loadedNode = proxyNode->getChild(0);
					loadedNode = dynamic_cast<crNode *>(loadedNode->clone(crCopyOp::DEEP_COPY_NODES));
					group->addChild(loadedNode);
					//crAcceptGIVisitor acceptGI(1);
					//group->accept(acceptGI);
				}
				//CRIOManager::crLoadManager::getInstance()->requestNode(filename,group.get(),false);
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod::operator() FileName是空的"<<std::endl;
			}
			m_item->setNode(group.get());
			//crAcceptGIVisitor acceptGI(true);
			//group->accept(acceptGI);
			itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
			//m_item->clientLoadItemChild();
			unsigned char itemstate = IS_Stop;//IS_ItemLoad;
			itemdata->inputParam(WCHDATA_ItemState,&itemstate);

			const std::string &resScript = m_item->getAbstractItem()->getResScript();
			if(!resScript.empty())
			{
				CREncapsulation::loadItemCfg(resScript,group.get());
				crData *nodeData = group->getDataClass();
				if(nodeData)
				{
					nodeData->inputParam(WCHDATA_Item,m_item.get());
				}
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod(): resScript是空的 "<<std::endl;
			}

			crMyPlayerData::getInstance()->insertInRangeItem(m_item.get(),group.get());

			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor && itemtype == crInstanceItem::instanceitem)
			{
				crRequestItemRTDataPacket packet;
				crRequestItemRTDataPacket::buildRequestPacket(packet,m_item.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			else
			{//单机游戏
				m_item->doEvent(WCH_RecvItemRTData);
			}
		}
		else if(itemtype == crInstanceItem::LocalItem)
		{
			m_item->loadItemData(SaveStream);
			itemdata = m_item->getDataClass();
			itemdata->getParam(WCHDATA_DataType,param);
			ref_ptr<crGroup> group;
			if(param)
			{
				unsigned char datatype = *((unsigned char*)param);
				if(datatype == DT_Box)
				{
					group = new crBoxMatterObject;
				}
				else if(datatype == DT_Sphere)
				{
					group = new crSphereMatterObject;
				}
			}
			if(!group.valid())
			{
				group = new crMatrixTransform;
			}
			//group->setVisiable(false);
			group->setName(m_item->getIName());
			const std::string &filename = m_item->getAbstractItem()->getFileName();
			if(!filename.empty())
			{
				CRCore::ref_ptr<crGroup> proxyNode = new crGroup;
				CRIOManager::crLoadManager::getInstance()->requestNode(filename,proxyNode.get(),false);
				if(proxyNode->getNumChildren()==1)
				{
					crNode *loadedNode = proxyNode->getChild(0);
					loadedNode = dynamic_cast<crNode *>(loadedNode->clone(crCopyOp::DEEP_COPY_NODES));
					group->addChild(loadedNode);
				}
				//CRIOManager::crLoadManager::getInstance()->requestNode(filename,group.get(),false);
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod::operator() FileName是空的"<<std::endl;
			}
			m_item->setNode(group.get());
			//crAcceptGIVisitor acceptGI(true);
			//group->accept(acceptGI);
			//itemdata->excHandle(MAKEINT64(WCH_CheckNetData,m_item.get()));
			//m_item->clientLoadItemChild();
			unsigned char itemstate = IS_Stop;//IS_ItemLoad;
			itemdata->inputParam(WCHDATA_ItemState,&itemstate);
			const std::string &resScript = m_item->getAbstractItem()->getResScript();
			if(!resScript.empty())
			{
				CREncapsulation::loadItemCfg(resScript,group.get());
				crData *nodeData = group->getDataClass();
				if(nodeData)
				{
					nodeData->inputParam(WCHDATA_Item,m_item.get());
				}
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod(): resScript是空的 "<<std::endl;
			}
			crMyPlayerData::getInstance()->getScene()->insertSceneItem(m_item.get());
			m_item->doEvent(WCH_RecvItemRTData);
			//char gbuf[256];
			//sprintf(gbuf,"LoadLocalItem %s,visiable:%d\n\0",m_item->getIName().c_str(),group->getVisiable());
			//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
		}
	}
	else
	{
		char gbuf[256];
		sprintf(gbuf,"LoadItem Falid\n\0");
		gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
	}
	m_item = NULL;
}

/////////////////////////////////////////
//
//crItemInRangeTestMethod
//
/////////////////////////////////////////
crItemInRangeTestMethod::crItemInRangeTestMethod(){}
crItemInRangeTestMethod::crItemInRangeTestMethod(const crItemInRangeTestMethod& handle):
crMethod(handle)
{
}
void crItemInRangeTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_sight = NULL;
			m_item = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_sight = (crSightInfo *)(LOINT64(param64));
			m_item = (crInstanceItem *)(HIINT64(param64));
		}
		else
		{
			m_sight = NULL;
			m_item = NULL;
		}
		break;
	}
}

void crItemInRangeTestMethod::addParam(int i, const std::string& str)
{
}

void crItemInRangeTestMethod::operator()(crHandle &handle)
{
	if(m_sight && m_item && m_item->getDataClass())
	{
		unsigned int guisestate = GS_Normal;
		m_item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable || (guisestate & GS_Hide && !(guisestate & GS_UnHide)))
		{
			if(m_sight->isItemInSight(m_item))
			{
				m_sight->insertOutSightItem(m_item);
			}
			return;
		}
		crData *data = m_this->getDataClass();
		void *param;
		if(guisestate & GS_Static)
		{
			unsigned char itemstate;
			data->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
			{
				if(m_sight->isItemInSight(m_item))
				{
					m_sight->insertOutSightItem(m_item);
				}
				return;
			}
		}
		//void *param;
		//crData *data = m_item->getDataClass();
		//data->getParam(WCHDATA_GuiseState,param);
		//if(param)
		//{
		//	unsigned char guiseState = *(unsigned char *)param;
		//	if(guiseState == GS_UnVisiable || guiseState == GS_StaticUnVisiable)
		//	{//
		//		if(m_sight->isItemInSight(m_item))
		//		{
		//			m_sight->insertOutSightItem(m_item);
		//		}
		//		return;
		//	}
		//}
		bool inRange = true;
		//data->getParam(WCHDATA_SightRange,param);
		//short sightRange = *((short*)param);
		float sightRange = 0;
		m_this->doEvent(MAKEINT64(WCH_GetSightRange,NULL),MAKEINT64(&sightRange,NULL));
		float stealth = 0;
		m_item->doEvent(MAKEINT64(WCH_GetStealth,NULL),MAKEINT64(&stealth,NULL));
		if(stealth>0.0f)
		{
			float stealthspy = 0;
			m_this->doEvent(MAKEINT64(WCH_GetStealthSpy,NULL),MAKEINT64(&stealthspy,NULL));
			stealth -= stealthspy;
			if(stealth<0.0f)
				stealth = 0.0f;
		}
		sightRange -= stealth;

		crVector2i thisPos(m_this->getPosx(), m_this->getPosy());// , m_this->getPosz());
		crVector2i itmePos(m_item->getPosx(), m_item->getPosy());// , m_item->getPosz());
		int dist2 = (thisPos - itmePos).length2();// / crGlobalHandle::gData()->gUnitScale();
		if (/*sightRange>0.0f && */dist2>sightRange*sightRange)
		{
			inRange = false;
		}
		if(inRange)
		{
			m_sight->insertInSightItem(m_item);
		}
		else
		{
			if(m_sight->isItemInSight(m_item))
			{
				m_sight->insertOutSightItem(m_item);
			}
		}
		if(m_this->getItemtype() == crInstanceItem::Npc && (m_item->getItemtype()==crInstanceItem::Npc || m_item->getItemtype()==crInstanceItem::Role))
		{
			//
			//int enmity = 0;
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_EnmityMap,param);
			//EnmityMap *enmityMap = (EnmityMap *)param;
			//_crInt64 id = MAKEINT64(m_item->getInstanceItemID(),NULL);
			//EnmityMap::iterator eitr = enmityMap->find(id);
			//if(eitr!=enmityMap->end())
			//	enmity = eitr->second;
			//data->excHandle(MAKEINT64(WCH_LockData,0));
			if(inRange/*||enmity>0*/)
			{
				//if(inRange)
				//{
				//	crData *itemdata = m_item->getDataClass();
				//	itemdata->getParam(WCHDATA_BaseEnmity,param);
				//	enmity += *(int*)param;
				//}
				crData *data2 = m_item->getDataClass();
				data2->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
				{
					char isEnemy = 0;
					m_this->doEvent(WCH_EnemyCheck,MAKEINT64(m_item,&isEnemy));
					if(isEnemy == -1)
					{
						//_crInt64 distEnmity = MAKEINT64(-(int)dist,enmity);
						m_this->doEvent(WCH_InPatrolTest,MAKEINT64(m_item,dist2));
					}
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crRoomPlayerInRangeTestMethod
////
///////////////////////////////////////////
//crRoomPlayerInRangeTestMethod::crRoomPlayerInRangeTestMethod():m_rolePlayer2(NULL){}
//crRoomPlayerInRangeTestMethod::crRoomPlayerInRangeTestMethod(const crRoomPlayerInRangeTestMethod& handle):
//crMethod(handle),
//m_rolePlayer2(NULL)
//{
//}
//void crRoomPlayerInRangeTestMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_player = NULL;
//			m_rolePlayer2 = NULL;
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRole*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_player = (crSceneServerPlayerData *)(LOINT64(param64));
//			m_rolePlayer2 = (RolePlayerPair *)(HIINT64(param64));
//		}
//		else
//		{
//			m_player = NULL;
//			m_rolePlayer2 = NULL;
//		}
//		break;
//	}
//}
//
//void crRoomPlayerInRangeTestMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRoomPlayerInRangeTestMethod::operator()(crHandle &handle)
//{
//	if(m_player.valid() && m_player->getRoomID()!=0 && m_rolePlayer2)
//	{
//		float dist;
//		bool inRange = false;
//		crRole *role2 = m_rolePlayer2->first.get();
//		//if(m_player->getRoomID() == role2->getRoomID() && m_this->getLayerID() == role2->getLayerID())
//		//{
//		//void *param;
//		//crData *roleData2 = role2->getDataClass();
//		//roleData2->getParam(WCHDATA_RTHP,param);
//		//float rthp = *(float*)param;
//		//if(rthp > 0)
//		//{//!= IS_Dead
//		crData *data = m_this->getDataClass();
//		void *_sightRange;
//		data->getParam(WCHDATA_SightRange,_sightRange);
//		short sightRange = *((short*)_sightRange);
//
//		crVector3 rolePos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
//		crVector3 rolePos2(role2->getPosx(),role2->getPosy(),role2->getPosz());
//		dist = (rolePos - rolePos2).length();
//		if(dist<sightRange)
//		{
//			inRange = true;
//		}
//		//}
//		//}
//		if(inRange)
//			m_player->insertInRangeRole(role2,m_rolePlayer2->second.get(),dist);
//		else
//		{
//			bool playerInRange = m_player->isRoleInRange(role2->getRoleID()/*m_player2->getPlayerID()*/);
//			if(playerInRange)
//			{
//				m_player->removeInRangeRole(role2);
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crRoomItemInRangeTestMethod
////
///////////////////////////////////////////
//crRoomItemInRangeTestMethod::crRoomItemInRangeTestMethod(){}
//crRoomItemInRangeTestMethod::crRoomItemInRangeTestMethod(const crRoomItemInRangeTestMethod& handle):
//crMethod(handle)
//{
//}
//void crRoomItemInRangeTestMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_player = (crSceneServerPlayerData *)(LOINT64(param64));
//			m_item = (crInstanceItem *)(HIINT64(param64));
//		}
//		else
//		{
//			m_player = NULL;
//			m_item = NULL;
//		}
//		break;
//	}
//}
//
//void crRoomItemInRangeTestMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRoomItemInRangeTestMethod::operator()(crHandle &handle)
//{
//	if(m_player.valid() && m_player->getRoomID()!=0 && m_item.valid())
//	{
//		float dist = -1;
//		void *param;
//		if(m_item->getRoomID() == m_player->getRoomID())
//		{
//			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//			bool inRange = false;
//			crRole *role = m_player->getRole();
//			if(role->getLayerID() == m_item->getLayerID())
//			{
//				crData *data = role->getDataClass();
//
//				data->getParam(WCHDATA_SightRange,param);
//				short sightRange = *((short*)param);
//
//				crVector3 rolePos(role->getPosx(),role->getPosy(),0);
//				crVector3 itmePos(m_item->getPosx(),m_item->getPosy(),0);
//				dist = (rolePos - itmePos).length();
//				//if(dist<c_safeDistance)
//				//{//安全距离
//				//	//修改player位置
//				//	unsigned char targettype = Target_None;
//				//	role->getDataClass()->inputParam(WCHDATA_TargetType,&targettype);//避免closetarget
//				//	unsigned char itemstate = IS_Stop;
//				//	role->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
//
//				//	float posx = role->getPosx();
//				//	float posy = role->getPosy();
//				//	float dirx = role->getDirx();
//				//	float diry = role->getDiry();
//
//				//	posx -= dirx * (c_safeDistance+100-dist);
//				//	posy -= diry * (c_safeDistance+100-dist);
//				//	role->setPosx(posx);
//				//	role->setPosy(posy);
//				//	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//				//	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//				//	crScene *scene = netCallback->findScene(role->getSceneID());
//				//	float posz = scene->getPosZ(role->getLayerID(),posx * crGlobalHandle::gData()->gUnitScale(),posy * crGlobalHandle::gData()->gUnitScale(), role->getZoffset() *crGlobalHandle::gData()->gUnitScale());
//				//	posz /= crGlobalHandle::gData()->gUnitScale();
//				//	role->setPosz(posz);
//				//	////////not send
//				//	//            ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				//	//stream->createBuf(12);
//				//	//            stream->_writeInt(posx);
//				//	//stream->_writeInt(posy);
//				//	//stream->_writeInt(posz);
//				//	//crPlayerEventPacket packet;
//				//	//crPlayerEventPacket::buildRequestPacket(packet,m_player->getPlayerID(),m_player->getPlayerID(),WCH_CorrectPosition,stream.get());
//				//	//sceneServerConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);
//				//	//m_player->sendPacketToNeighbor(packet);
//				//	inRange = true; 
//				//	//CRCore::notify(CRCore::ALWAYS)<<"crItemInRangeTestMethod WCH_CorrectPosition"<<std::endl;
//				//}
//				//else 
//				if(dist<sightRange)
//				{
//					inRange = true;
//				}
//			}
//			if(m_item->getItemtype() != crInstanceItem::Role)
//			{
//				m_item->doEvent(WCH_ItemInRangeTest,MAKEINT64(role,&dist));
//			}
//			if(inRange)
//				m_player->insertInRangeItemMap(m_item.get(),dist);
//			else
//			{
//				bool playerInRange = m_player->isItemInRange(m_item->getInstanceItemID());
//				if(playerInRange)
//				{
//					m_player->removeInRangeItem(m_item.get());
//				}
//			}
//			//bool playerInRange = m_player->isItemInRange(m_item->getInstanceItemID());
//			//if(playerInRange!=inRange)
//			//{
//			//	if(inRange)
//			//	{//新进入视野范围
//			//		m_player->insertInRangeItem(m_item.get(),dist,sightRange);
//			//	}
//			//	else
//			//	{//
//			//		m_player->removeInRangeItem(m_item.get());
//			//	}
//			//}
//		}
//	}
//}
/////////////////////////////////////////
//
//crLoadRoleDataMethod
//
/////////////////////////////////////////
crLoadRoleDataMethod::crLoadRoleDataMethod(){}
crLoadRoleDataMethod::crLoadRoleDataMethod(const crLoadRoleDataMethod& handle):
crMethod(handle)
{
}
void crLoadRoleDataMethod::inputParam(int i, void *param)
{
}

void crLoadRoleDataMethod::addParam(int i, const std::string& str)
{
}

void crLoadRoleDataMethod::operator()(crHandle &handle)
{
	//crRole *role = crMyPlayerData::getInstance()->getRole();
	//if(role)
	//{
	//	role->loadItemData(PlayerStream);
	//	role->loadMetierData(PlayerStream);
	//}
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	crRunGameHandle::RoleVec &roleVec = crRunGameHandle::getInstance()->getRoleVec();
	for( crRunGameHandle::RoleVec::iterator itr = roleVec.begin();
		 itr != roleVec.end();
		 ++itr )
	{
		crMyPlayerData::getInstance()->addRole(itr->get());
		(*itr)->setPlayerGameData(playerGameData);
	}
	roleVec.clear();
	crMyPlayerData::getInstance()->createScene();

	crRole *role;
	crMyPlayerData::getInstance()->lockMyRoleNpcMap();
	crMyPlayerData::MyRoleNpcMap &roleMap = crMyPlayerData::getInstance()->getMyRoleNpcMap();
	for( crMyPlayerData::MyRoleNpcMap::iterator itr = roleMap.begin();
		 itr != roleMap.end();
		 ++itr )
	{
		role = itr->second.first.get();
		role->loadItemData(PlayerStream);
		role->loadMetierData(PlayerStream);
	}
	crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
}
/////////////////////////////////////////
//
//crSendToBotMethod
//
/////////////////////////////////////////
crSendToBotMethod::crSendToBotMethod(){}
crSendToBotMethod::crSendToBotMethod(const crSendToBotMethod& handle):
crMethod(handle)
{
}
void crSendToBotMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		m_param = (_crInt64*)param;
		break;
	}
}

void crSendToBotMethod::addParam(int i, const std::string& str)
{
}

void crSendToBotMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	if(role)
	{
		crNode *bot = role->getRelNode();
		bot->doEvent(m_this->getCurrentMsg(),*m_param);
	}
}

/////////////////////////////////////////
//
//crNetPickTargetMethod
//
/////////////////////////////////////////
crNetPickTargetMethod::crNetPickTargetMethod()
{
}

crNetPickTargetMethod::crNetPickTargetMethod(const crNetPickTargetMethod& handle):
crMethod(handle)
{
}

void crNetPickTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	case 3:
		m_root = (crNode *)param;
		break;
	}
}

void crNetPickTargetMethod::addParam(int i, const std::string& str)
{
}

void crNetPickTargetMethod::operator()(crHandle &handle)
{
	if(!m_ea.valid()) return;
	unsigned char targetType = Target_None;
	crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());

	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(!bindview||!bindview->isInited())
		return;
	CRCore::crIntersectVisitor::HitList hits;
	if(m_root.valid())
		bindview->computeIntersections(mouse[0],mouse[1],m_root.get(),hits,~AutoTransMask);
	else
		bindview->computeIntersections(mouse[0],mouse[1],hits,~AutoTransMask);

	if(!hits.empty())
	{
		//mousePickObj = hits[0].getObject();
		crVector3 pickPoint;
		crNode *targetNode = NULL;
		crData *targetData = NULL;
		void *param;
		crInstanceItem *targetItem = NULL;
		CRCore::NodePath &nodePath = hits[0].getNodePath();
		for( CRCore::NodePath::reverse_iterator pitr = nodePath.rbegin();
			pitr != nodePath.rend();
			++pitr )
		{
			targetNode = *pitr;
			targetData = targetNode->getDataClass();
			if(targetData)
			{
				targetData->getParam(WCHDATA_Item,param);
				targetItem = (crInstanceItem*)param;
				if(targetItem)
				{
					break;
				}
			}
		}
		if(targetItem)
		{
			switch (targetItem->getItemtype())
			{
			case crInstanceItem::Role:
				if(targetItem->getID() == crMyPlayerData::getInstance()->getPlayerID())
					targetType = Target_Role | Target_Self;
				else
					targetType = Target_Role;
				break;
			case crInstanceItem::Npc:
				{
					unsigned int guisestate = GS_Normal;
					guisestate = GS_Normal;
					targetItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if(guisestate & GS_Static)
					{
						targetType = Target_StaticNpc;
					}
					else
					{
						targetType = Target_Npc;
					}
				}
				break;
			case crInstanceItem::instanceitem:
			case crInstanceItem::LocalItem:
				{
					targetType = Target_Item;
					//unsigned int guisestate = GS_Normal;
					//guisestate = GS_Normal;
					//targetItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					//if(guisestate & GS_Static)
					//{
					////	targetType = Target_StaticItem;
					////}
					////else
					////{
					//	targetType = Target_Item;
					//}
				}
				break;
			}
			handle.outputParam(WCHDATA_TargetNode,targetNode);

			pickPoint = hits[0].getWorldIntersectPoint();//targetItem->getPosition();
			//crSceneLayer *scenelayer = crMyPlayerData::getInstance()->getSceneLayer();
			//if(scenelayer)
			//{
			//	crVector2s coord = scenelayer->getCoord(crVector2(pickPoint[0],pickPoint[1]));
			//	float height = scenelayer->getHeight(coord[0],coord[1]);
			//	pickPoint[2] = height;
			//}
		}
		else
		{
			targetType = Target_Coord;
			pickPoint = hits[0].getWorldIntersectPoint();
		}
		//CRCore::crSearchNodeHasDataEventVisitor searchVisitor;
		//searchVisitor.setTraversalMode(crNodeVisitor::TRAVERSE_PARENTS);
		//mousePickObj->accept(searchVisitor);
		//crNode *targetNode = searchVisitor.getResult();
		//if(targetNode)
		//{
		//	crData *targetData = targetNode->getDataClass();
		//	void *param;
		//	targetData->getParam(WCHDATA_Item,param);
		//	crInstanceItem *item = (crInstanceItem*)param;
		//	if(item)
		//	{
		//		if(item == crMyPlayerData::getInstance()->getRole())
		//		{
		//			targetType = Target_Self;
		//		}
		//		else
		//		{
		//			switch (item->getItemtype())
		//			{
		//			case crInstanceItem::Role:
		//				targetType = Target_Role;
		//				break;
		//			case crInstanceItem::Npc:
		//				targetType = Target_Npc;
		//				break;
		//			case crInstanceItem::instanceitem:
		//				targetType = Target_Item;
		//				break;
		//			}
		//		}
		//	}
		//	handle.outputParam(WCHDATA_TargetNode,targetNode);
		//}
		//else
		//{
		//	targetType = Target_Coord;
		//}
		handle.outputParam(WCHDATA_TargetPos,&pickPoint);
		//if(pickPoint == crVector3(0.0f,0.0f,0.0f))
		//{
		//	int i = 0;
		//}
	}
	handle.outputParam(WCHDATA_TargetType,&targetType);
}

/////////////////////////////////////////
//
//crNodeMouseEventMethod
//
/////////////////////////////////////////
crNodeMouseEventMethod::crNodeMouseEventMethod()
{
}

crNodeMouseEventMethod::crNodeMouseEventMethod(const crNodeMouseEventMethod& handle):
crMethod(handle)
{
}

void crNodeMouseEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crNodeMouseEventMethod::addParam(int i, const std::string& str)
{
}

void crNodeMouseEventMethod::operator()(crHandle &handle)
{
	if(!m_ea.valid()) return;
	crNode *targetNode = NULL;
	crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(!bindview||!bindview->isInited())
		return;
	CRCore::crIntersectVisitor::HitList hits;
	bindview->computeIntersections(mouse[0],mouse[1],hits,~AutoTransMask);
    
	if(!hits.empty())
	{
		targetNode = hits[0].getObject();
		if(targetNode->hasHandle(m_msg))
			targetNode->doEvent(m_msg,m_param);
		else
		{
			CRCore::NodePath &nodePath = hits[0].getNodePath();
			for( CRCore::NodePath::iterator pitr = nodePath.begin();
				pitr != nodePath.end();
				++pitr )
			{
				targetNode = *pitr;
				if(targetNode->hasHandle(m_msg))
				{
					targetNode->doEvent(m_msg,m_param);
					break;
				}
			}
		}
	}
	if(m_ea->getEventType() == crGUIEventAdapter::MOVE)
	{
		crData *brainData = crBrain::getInstance()->getDataClass();
		void *param;
		brainData->getParam(WCHDATA_CurrentFocusNode,param);
		crNode *currentFocusNode = (crNode *)param;
		if(targetNode != currentFocusNode)
		{
			if(currentFocusNode)
				currentFocusNode->doEvent(WCH_NODELOSTFOCUS);
			if(targetNode)
				targetNode->doEvent(WCH_NODEGETFOCUS);
			brainData->inputParam(WCHDATA_CurrentFocusNode,targetNode);
		}
	}
}

/////////////////////////////////////////
//
//crNetControlMethod
//
/////////////////////////////////////////
crNetControlMethod::crNetControlMethod():
m_netType(GameClient_Game),
m_delta(200.0f),
m_attackDelta(1.0f){}
crNetControlMethod::crNetControlMethod(const crNetControlMethod& handle):
crMethod(handle),
m_delta(handle.m_delta),
m_attackDelta(handle.m_attackDelta)
{
}
void crNetControlMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crNetControlMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_delta = atof(str.c_str());
		break;
	case 1:
		m_attackDelta = atof(str.c_str());
		break;
	}
}

void crNetControlMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crNetMousePick2Method recv WCH_NetControl"<<std::endl;
		//void *param;
		crData *thisData = m_this->getDataClass();
		void *param;
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_ItemLoad || itemstate == IS_Dead)
		{
			return;
		}
		unsigned int guisestate = GS_Normal;
		m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			return;
		}
		//thisData->getParam(WCHDATA_GuiseState,param);
		//unsigned char guisestate = *(unsigned char *)param;
		//if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
		//{
		//	return;
		//}
		unsigned char targetType = m_stream->_readUChar();
		thisData->inputParam(WCHDATA_TargetType,&targetType);
		crVector3 targetPosition;
		int targetid = 0;
		int targetroleid = 0;
		ref_ptr<crInstanceItem>targetItem;
		if(targetType & Target_Instance || targetType & Target_Self || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
		{
			targetid = m_stream->_readInt();
			targetroleid = targetType&Target_Role?m_stream->_readInt():0;
			itemstate = m_stream->_readUChar();
			thisData->inputParam(WCHDATA_TargetID,&targetid);
			thisData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			if(m_netType == GameClient_Game)
			{
				ref_ptr<crMatrixTransform>targetNode;
				m_this->clientGetTarget(targetItem,targetNode);
				//thisData->inputParam(WCHDATA_TargetNode,targetNode.get());
				if(targetItem.valid())
				{
					targetPosition = targetItem->getPosition();
					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
				}
			}
			else if(m_netType == SceneServer)
			{
				targetItem = m_this->serverGetTarget();
				if(targetItem.valid())
				{
					targetPosition = targetItem->getPosition();
					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
				}
			}
		}
		else
		{
            targetPosition = m_stream->_readVec3();
			itemstate = m_stream->_readUChar();
	        thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
		}
        if(itemstate == IS_UseItem)
		{
			int itemid = m_stream->_readInt();
			if(!crGlobalHandle::isClient())
			{
				crVector2 clientpos,serverpos;
				clientpos[0] = m_stream->_readInt();
				clientpos[1] = m_stream->_readInt();
				serverpos.set(m_this->getPosx(),m_this->getPosy());
				if((serverpos-clientpos).length()>m_delta)//服务器位置和客户端位置相差1米忽略本次攻击
					return;
			}
			//float rthp = m_stream->_readFloat();
			//float rtmp = m_stream->_readFloat();
			//float followDistance =m_stream->_readFloat();
			//thisData->inputParam(WCHDATA_RTHP,&rthp);
			//thisData->inputParam(WCHDATA_RTMP,&rtmp);
			//thisData->inputParam(WCHDATA_FollowDistance,&followDistance);

			crItemChild *itemChild = m_this->findChildItem(itemid);
			if(!itemChild || !itemChild->isLoaded())
				return;
			crInstanceItem *item = itemChild->getInstanceItem();
			crVector3 myPos = m_this->getPosition();
			if(!(guisestate & GS_Static) && !(guisestate & GS_StaticNoneBlock))
			{
				crVector3 targetDir = targetPosition - myPos;
				targetDir[2] = 0.0f;
				targetDir.normalize();
				m_this->setDir(targetDir);
			}
			if(m_netType == GameClient_Game)
			{
				UseItemParam useItemParam;
				useItemParam.m_user = m_this;
				if(targetItem.valid() && (targetItem->getItemtype()==crInstanceItem::Npc || targetItem->getItemtype()==crInstanceItem::Role))
					useItemParam.m_target = targetItem.get();
				item->doEvent(MAKEINT64(WCH_UseItem,UT_NetClient),MAKEINT64(&useItemParam,NULL));
				if(!(guisestate & GS_Static) && !(guisestate & GS_StaticNoneBlock))
				{
					crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
					if(bot)
					{
						m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_RotMatrix));
					}
				}
			}
			else if(m_netType == SceneServer)
			{
				float clientRelRange = m_stream->_readFloat();
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemUseRange,param);
				unsigned short itemUseRange = *((unsigned short*)param);
				float relRange = itemUseRange * crGlobalHandle::gData()->gUnitScale();
				//relRange += m_this->getAttackDistance(/*NULL*/targetItem.get());
				if(fabs(relRange-clientRelRange)<m_attackDelta)
				{//攻击距离合法，防止玩家修改客户端攻击距离
					UseItemParam useItemParam;
					useItemParam.m_user = m_this;
					if(targetItem.valid() && (targetItem->getItemtype()==crInstanceItem::Npc || targetItem->getItemtype()==crInstanceItem::Role))
						useItemParam.m_target = targetItem.get();
					unsigned short useResult = UR_None;
					item->doEvent(MAKEINT64(WCH_UseItem,UT_NetServer),MAKEINT64(&useItemParam,&useResult));
				}
			}
			//itemstate = IS_Stop;
		}
		else if(itemstate >= IS_MoveToPos &&itemstate <= IS_CloseTargetTouch)
		{					
			float followDistance = m_stream->_readFloat();
            thisData->inputParam(WCHDATA_FollowDistance,&followDistance);
		}
		//if(itemstate!=IS_UseItem)
		//{
		//	crVector3i pos;
		//	pos[0] = m_stream->_readInt();
		//	pos[1] = m_stream->_readInt();
		//	pos[2] = m_stream->_readInt();
		//	//pos 合法性检查
		//	m_this->setPosx(pos[0]);
		//	m_this->setPosy(pos[1]);
		//	m_this->setPosz(pos[2]);
		//	if(itemstate < IS_Move)
		//	{
		//		crVector3 dir;
		//		dir[0] = m_stream->_readFloat();
		//		dir[1] = m_stream->_readFloat();
		//		dir[2] = m_stream->_readFloat();
		//		m_this->setDir(dir);
		//	}
		//}
		//else
		//{
		//	itemstate = IS_Stop;
		//}
		//thisData->inputParam(WCHDATA_ItemState,&itemstate);
		//if(m_netType == GameClient_Game)
		//{
		//	crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		//	if(bot)
		//	{
		//		m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
		//	}
		//}
		//if(m_netType == GameClient_Game)
		//{
		//	crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		//	if(bot)
		//	{
		//		//float speed = 0.0f;
		//		if(itemstate >= IS_Move)
		//		{
		//			//m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
		//			//speed *= crGlobalHandle::gData()->gUnitScale();
		//			//bot->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&targetPosition,&speed));
		//			m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_TransMatrix));
		//			crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
		//		}
		//		else
		//		{
		//			m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
		//		}
		//		//else
		//		//{
		//		//	crVector3 nullpos;
		//		//	bot->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));//停止移动
		//		//}
		//	}
		//}
		//else if(m_netType == SceneServer)
		//{
		//	if(itemstate >= IS_Move)
		//	{
		//		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		//		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		//		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		//		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		//		scene->getPathFindingManager()->addPathFindRequest(m_this);
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crServerItemMoveMethod
//
/////////////////////////////////////////
crServerItemMoveMethod::crServerItemMoveMethod():
m_taskPointRange(1.0f),
m_dt(0.0f){}
crServerItemMoveMethod::crServerItemMoveMethod(const crServerItemMoveMethod& handle):
crMethod(handle),
m_taskPointRange(handle.m_taskPointRange),
m_dt(handle.m_dt)
{
}
void crServerItemMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crServerItemMoveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskPointRange = atof(str.c_str());
		break;
	}
}

void crServerItemMoveMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *((unsigned char*)param);
		if(itemstate != IS_Dead)
		{//!=IS_Dead
			if(itemstate >= IS_Move)
			{
				float speed = 0;
				m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
				float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
				data->getParam(WCHDATA_TargetPos,param);
				crVector3 targetPosition = *((crVector3*)param);
				crVector3 pos(m_this->getPosx(),m_this->getPosy(),0.0f);
				pos *= crGlobalHandle::gData()->gUnitScale();
				targetPosition[2] = 0.0f;
				crVector3 vec = targetPosition - pos;
				if(vec.length2()<m_taskPointRange * m_taskPointRange)
				{
					itemstate = IS_Stop;
					data->inputParam(WCHDATA_ItemState, &itemstate);
					//send stop
					if(m_this->getItemtype() < crInstanceItem::Role)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(24);
						stream->_writeInt(m_this->getPosx());
						stream->_writeInt(m_this->getPosy());
						stream->_writeInt(m_this->getPosz());
						stream->_writeFloat(m_this->getDirx());
						stream->_writeFloat(m_this->getDiry());//4
						stream->_writeFloat(m_this->getDirz());//4

						crItemEventPacket packet;
						crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvStopMove,stream.get());
						crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
						crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
						crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						crScene *scene = netCallback->findScene(m_this->getSceneID());
						if(scene) scene->sendPacketToItemNeighbor(m_this,packet);
					}
				}
				else
				{
					vec[2] = 0.0f;
					vec.normalize();
					m_this->setTargetDir(vec);

					float dx = (vec[0] * relspeed * m_dt);
					dx /= crGlobalHandle::gData()->gUnitScale();
					float dy = (vec[1] * relspeed * m_dt);
					dy /= crGlobalHandle::gData()->gUnitScale();
					m_this->setPosxy(m_this->getPosx() + dx,m_this->getPosy() + dy);

					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					crScene *scene = netCallback->findScene(m_this->getSceneID());
					if(scene)
					{
						float posz = scene->getPosZ(m_this->getLayerID(),m_this->getPosx() * crGlobalHandle::gData()->gUnitScale(),m_this->getPosy() * crGlobalHandle::gData()->gUnitScale(), m_this->getZoffset() *crGlobalHandle::gData()->gUnitScale());
						m_this->setPosz(posz / crGlobalHandle::gData()->gUnitScale());
					}
				}
			}
		}
		else 
		{
			bool taskCanceled = true;
			handle.outputParam(0,&taskCanceled);
		}
	}
}
/////////////////////////////////////////
//
//crRevertUpdateMethod
//
/////////////////////////////////////////
crRevertUpdateMethod::crRevertUpdateMethod():
m_dt(0.0f){}
crRevertUpdateMethod::crRevertUpdateMethod(const crRevertUpdateMethod& handle):
crMethod(handle),
m_dt(0.0f)
{
}
void crRevertUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crRevertUpdateMethod::addParam(int i, const std::string& str)
{
}

void crRevertUpdateMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_RTHP,param);
		float* rthp = (float*)param;
		if(!rthp || *rthp<=0) return;
		data->excHandle(MAKEINT64(WCH_LockData,1));

		float maxhp = 0;
		float maxmp = 0;
		float revert = 0;
		m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));

		if(*rthp<maxhp)
		{
			m_this->doEvent(MAKEINT64(WCH_GetHPRevert,NULL),MAKEINT64(&revert,NULL));
			*rthp += revert * m_dt;
			if(*rthp>maxhp) *rthp = maxhp;
		}

		data->getParam(WCHDATA_RTMP,param);
		float* rtmp = (float*)param;
        if(*rtmp<maxmp)
		{
		    m_this->doEvent(MAKEINT64(WCH_GetMPRevert,NULL),MAKEINT64(&revert,NULL));
		    *rtmp += revert * m_dt;
			if(*rtmp>maxmp) *rtmp = maxmp;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crItemUpdateMethod
//
/////////////////////////////////////////
crItemUpdateMethod::crItemUpdateMethod(){}
crItemUpdateMethod::crItemUpdateMethod(const crItemUpdateMethod& handle):
crMethod(handle)
{
}
void crItemUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(LOINT64(param64));
		}
		else
		{
			m_updateVisitor = NULL;
		}
		break;
	}
}

void crItemUpdateMethod::addParam(int i, const std::string& str)
{
}

void crItemUpdateMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(m_this->getVisiable() && m_updateVisitor.valid() && crDisplaySettings::instance()->getRunMode()>0 && (!room || !room->isPaused()))
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Item,param);
		if(param)
		{
			ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
			if(item.valid())
			{
				float dt = crFrameStamp::getInstance()->getFrameInterval();
				item->clientUpdate(dt);
				item->doEvent(WCH_UPDATEVISITOR,MAKEINT64(&dt,m_this));
			}
		}
	}
}
/////////////////////////////////////////
//
//crNodeCoordToItemMethod
//
/////////////////////////////////////////
crNodeCoordToItemMethod::crNodeCoordToItemMethod()
{
}

crNodeCoordToItemMethod::crNodeCoordToItemMethod(const crNodeCoordToItemMethod& handle):
crMethod(handle)
{
}

void crNodeCoordToItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_node = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_node = (crNode*)(HIINT64(param64));
		}
		else
		{
			m_node = NULL;
		}
		break;
	}
}

void crNodeCoordToItemMethod::addParam(int i, const std::string& str)
{
}

void crNodeCoordToItemMethod::operator()(crHandle &handle)
{
	if(m_node.valid())
	{
		crVector3 pos,dir;
		if(dynamic_cast<crViewMatterObject *>(m_node.get()))
		{
            pos = (dynamic_cast<crViewMatterObject *>(m_node.get()))->getTrans();
			dir = -(dynamic_cast<crViewMatterObject *>(m_node.get()))->getDirection();
			m_this->setDir(dir);
		}
		else if(dynamic_cast<crMatrixTransform *>(m_node.get()))
		{
			pos = (dynamic_cast<crMatrixTransform *>(m_node.get()))->getTrans();
			crMatrixf rotation = (dynamic_cast<crMatrixTransform *>(m_node.get()))->getMatrix();
			rotation.setTrans(0.0f,0.0f,0.0f);
			dir = (-Y_AXIS * rotation).normalize();
			m_this->setDir(dir);
		}
		else
		{
			pos = m_node->getBound().center();
		}
		pos /= crGlobalHandle::gData()->gUnitScale();
		m_this->setPosxy(pos[0],pos[1]);
		m_this->setPosz(pos[2]);
	}
}
/////////////////////////////////////////
//
//crItemCoordToNodeMethod
//
/////////////////////////////////////////
crItemCoordToNodeMethod::crItemCoordToNodeMethod():
m_mode(crMatterObject::MD_FullMatrix)
{
}

crItemCoordToNodeMethod::crItemCoordToNodeMethod(const crItemCoordToNodeMethod& handle):
crMethod(handle),
m_mode(handle.m_mode)
{
}

void crItemCoordToNodeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_node = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_node = (crNode*)(LOINT64(param64));
			m_mode = (crMatterObject::MatrixDummyType)(HIINT64(param64));
		}
		else
		{
			m_node = NULL;
			m_mode = crMatterObject::MD_FullMatrix;
		}
		break;
	}
}

void crItemCoordToNodeMethod::addParam(int i, const std::string& str)
{
}

void crItemCoordToNodeMethod::operator()(crHandle &handle)
{
	if(m_node)
	{
		crVector3 pos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
		pos *= crGlobalHandle::gData()->gUnitScale();
		crVector3 dir(m_this->getDirx(),m_this->getDiry(),m_this->getDirz());
		//if(m_this->getItemtype() == crInstanceItem::Npc)
		//{
		//	CRCore::notify(CRCore::ALWAYS)<<"crItemCoordToNodeMethod "<<m_this->getIName()<<" pos:"<<pos<<std::endl;
		//}
		//const crMatrix& nodeMatrix = (dynamic_cast<crMatrixTransform *>(m_node.get()))->getMatrix();
		//crVector3 nodePos = nodeMatrix.getTrans();
		//if((nodePos - pos).length()<0.01f)
		//{//过滤细小的位置变化
		//	m_mode &= ~crMatterObject::MD_TransMatrix;
		//	if(m_mode == crMatterObject::MD_None)
		//		return;
		//}
		CRCore::crMatrix newMat;
		if(m_mode == crMatterObject::MD_LoadMatrix || m_mode & crMatterObject::MD_RotMatrix)
		{
			if(dir == crVector3(0.0f,0.0f,0.0f))
			{
				dir[1] = -1.0f;
				m_this->setDir(dir);
			}
			
			if(dir[1] > 0.999)
			{
				newMat.makeRotate(-CRCore::Y_AXIS,dir);
				CRCore::crVector3d ep,center,up;
				newMat.getLookAt(ep,center,up);
				if(center[2]>0.0f)
				{
					center = -center;
				}
				newMat.makeLookAt(ep,center,up);
			}
			else
				newMat.makeRotate(-CRCore::Y_AXIS,dir);
		}
		newMat.setTrans(pos);

		if(dynamic_cast<crMatterObject *>(m_node))
		{
			//if(m_mode == crMatterObject::MD_LoadMatrix)
				(dynamic_cast<crMatterObject *>(m_node))->setMatrix(newMat);
			//else
				(dynamic_cast<crMatterObject *>(m_node))->setMatterObjectMatrix(newMat,m_mode);
		}
		else if(dynamic_cast<crMatrixTransform *>(m_node))
		{
			crMatrix matrix = (dynamic_cast<crMatrixTransform *>(m_node))->getMatrix();
			switch (m_mode)
			{
			case crMatterObject::MD_RotMatrix:
				newMat.setTrans(matrix.getTrans());
				break;
			case crMatterObject::MD_TransMatrix:
				matrix.setTrans(newMat.getTrans());
				newMat = matrix;
				break;
			}
			(dynamic_cast<crMatrixTransform *>(m_node))->setMatrix(newMat);
		}
	}
}
/////////////////////////////////////////
//
//crNetMoveToTargetMethod
//
/////////////////////////////////////////
crNetMoveToTargetMethod::crNetMoveToTargetMethod():
//m_time(0L),
m_init(false),
m_velocity(3.0f)
{
}

crNetMoveToTargetMethod::crNetMoveToTargetMethod(const crNetMoveToTargetMethod& handle):
crMethod(handle),
m_aiTask(NULL),
m_velocity(handle.m_velocity),
//m_time(0L),
m_init(false)
{
}

void crNetMoveToTargetMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetPosition = *((crVector3*)(LOINT64(param64)));
			m_velocity = *((float*)(HIINT64(param64)));
		}
		break;
	//case 3:
	//	m_targetPosition = param?*((crVector3*)param):crVector3(0.0f,0.0f,0.0f);
	//	break;
	//case 4:
	//	m_velocity = param?*((float*)param):3.0f;
	//	break;
	}
}

void crNetMoveToTargetMethod::addParam(int i, const std::string& str)
{
}

void crNetMoveToTargetMethod::init()
{
	if(!m_init)
	{
		m_aiTask = new crAITask;
		m_aiTask->setName("NetMoveToTarget");
		//m_moveTask->setName(bot->getName());
		m_aiTask->setLoopMode(crAITask::NO_LOOPING);
		crOrdinalMsgControlPoint *omcp = new crOrdinalMsgControlPoint;
		omcp->setNeedVelocity(false);
		omcp->setIgnoreZ(true);
		CRCore::Msg msg;
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYDOWN),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		//时间到后停下
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(WCH_USER+47,NULL);//WCH_NetStopMove
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_INPUTAITASK,NULL);
		msg.m_param = MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get());
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		m_aiTask->pushTaskPoint(omcp);

		omcp = new crOrdinalMsgControlPoint;
		omcp->setNeedVelocity(false);
		omcp->setIgnoreZ(true);
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(WCH_USER+47,NULL);//WCH_NetStopMove
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_INPUTAITASK,NULL);
		msg.m_param = MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get());
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		m_aiTask->pushTaskPoint(omcp);

		//CRAI::crMoveTaskManager::getInstance()->insertMoveTask(m_moveTask.get());
		m_init = true;
	}
}

void crNetMoveToTargetMethod::operator()(crHandle &handle)
{
	//CRCore::notify(CRCore::FATAL)<<"m_targetType = "<<m_targetType<<std::endl;
	{
		if(!m_init) init();

		//距离判断
		crVector3f myPos = m_this->getTrans();
		myPos[2] = m_targetPosition[2];
		float dis = (m_targetPosition - myPos).length();
		//float r = m_this->getGameBodyInfo()->getTaskPointRange();
		if(/*dis>r&&*/m_velocity>0.001f)
		{
			crOrdinalMsgControlPoint *omcp;
			crAITask::TaskPointVec &taskPointVec = m_aiTask->getTaskPointVec();
			float time = dis/m_velocity + 1.0f;//0.1余量
			omcp = dynamic_cast<crOrdinalMsgControlPoint *>(taskPointVec[0].get());
			unsigned int msgid = 0;
			Msg *msg = omcp->getOrdinalMsg(msgid);
			msg->m_interval = time;

			omcp = dynamic_cast<crOrdinalMsgControlPoint *>(taskPointVec[1].get());
			omcp->setPosition(m_targetPosition);

			m_this->doEvent(MAKEINT64(WCH_INPUTAITASK,NULL),MAKEINT64(MAKEINT32(WCHAI_Begin,WCHAI_SetCPToBot),m_aiTask.get()));

			//m_time = t1;
		}
		else
		{//停止移动
			m_this->doEvent(MAKEINT64(WCH_INPUTAITASK,NULL),MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get()));
			m_this->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE),MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL));
			//m_this->doEvent(WCH_NetStopMove);
			//CRCore::notify(CRCore::ALWAYS)<<"crNetMoveToTargetMethod "<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crNetMoveToTarget2Method
//
/////////////////////////////////////////
crNetMoveToTarget2Method::crNetMoveToTarget2Method():
m_init(false),
m_velocity(3.0f)
{
}

crNetMoveToTarget2Method::crNetMoveToTarget2Method(const crNetMoveToTarget2Method& handle):
crMethod(handle),
m_aiTask(NULL),
m_velocity(handle.m_velocity),
m_init(false)
{
}

void crNetMoveToTarget2Method::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetPosition = *((crVector3*)(LOINT64(param64)));
			m_velocity = *((float*)(HIINT64(param64)));
		}
		break;
	//case 3:
	//	m_targetPosition = param?*((crVector3*)param):crVector3(0.0f,0.0f,0.0f);
	//	break;
	//case 4:
	//	m_velocity = param?*((float*)param):3.0f;
	//	break;
	}
}

void crNetMoveToTarget2Method::addParam(int i, const std::string& str)
{
}

void crNetMoveToTarget2Method::init()
{
	if(!m_init)
	{
		m_aiTask = new crAITask;
		m_aiTask->setName("NetMoveToTarget2");
		//m_moveTask->setName(bot->getName());
		m_aiTask->setLoopMode(crAITask::NO_LOOPING);
		crOrdinalMsgControlPoint *omcp = new crOrdinalMsgControlPoint;
		omcp->setNeedVelocity(false);
		omcp->setIgnoreZ(true);
		CRCore::Msg msg;
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYDOWN),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		//时间到停止
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_INPUTAITASK,NULL);
		msg.m_param = MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get());
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		m_aiTask->pushTaskPoint(omcp);

		omcp = new crOrdinalMsgControlPoint;
		omcp->setNeedVelocity(false);
		omcp->setIgnoreZ(true);
		msg.m_msg = MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE);
		msg.m_param = MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL);
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		msg.m_msg = MAKEINT64(WCH_INPUTAITASK,NULL);
		msg.m_param = MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get());
		msg.m_interval = 0.0f;
		omcp->addOrdinalMsg(msg);

		m_aiTask->pushTaskPoint(omcp);

		//CRAI::crMoveTaskManager::getInstance()->insertMoveTask(m_moveTask.get());
		m_init = true;
	}
}

void crNetMoveToTarget2Method::operator()(crHandle &handle)
{
	//CRCore::notify(CRCore::FATAL)<<"m_targetType = "<<m_targetType<<std::endl;
	{
		if(!m_init) init();

		crVector3f myPos = m_this->getTrans();
		myPos[2] = m_targetPosition[2];
		float dis = (m_targetPosition - myPos).length();
		//float r = m_this->getGameBodyInfo()->getTaskPointRange();
		if(/*dis>r&&*/m_velocity>0.001f)
		{
			crOrdinalMsgControlPoint *omcp;
			crAITask::TaskPointVec &taskPointVec = m_aiTask->getTaskPointVec();
			float time = dis/m_velocity + 1.0f;//0.1余量
			//CRCore::notify(CRCore::FATAL)<<"dis = "<<dis<<" m_velocity = "<<m_velocity<<std::endl;
			omcp = dynamic_cast<crOrdinalMsgControlPoint *>(taskPointVec[0].get());
			unsigned int msgid = 0;
			Msg *msg = omcp->getOrdinalMsg(msgid);
			msg->m_interval = time;

			omcp = dynamic_cast<crOrdinalMsgControlPoint *>(taskPointVec[1].get());
			omcp->setPosition(m_targetPosition);

			m_this->doEvent(MAKEINT64(WCH_INPUTAITASK,NULL),MAKEINT64(MAKEINT32(WCHAI_Begin,WCHAI_SetCPToBot),m_aiTask.get()));

			//m_time = t1;
		}
		else
		{//停止移动
			m_this->doEvent(MAKEINT64(WCH_INPUTAITASK,NULL),MAKEINT64(MAKEINT32(WCHAI_End,NULL),m_aiTask.get()));
			m_this->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE),MAKEINT64(MAKEINT32(WCH_UP,crGUIEventAdapter::KEYUP),NULL));
		}
	}
}
/////////////////////////////////////////
//
//crCreateRoleMethod
//
/////////////////////////////////////////
crCreateRoleMethod::crCreateRoleMethod(){}
crCreateRoleMethod::crCreateRoleMethod(const crCreateRoleMethod& handle):
crMethod(handle),
m_metierElement(handle.m_metierElement),
m_botElement(handle.m_botElement),
m_roleNameElement(handle.m_roleNameElement)
{
}
void crCreateRoleMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crCreateRoleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_metierElement = str;
		break;
	case 1:
		m_botElement = str;
		break;
	case 2:
		m_roleNameElement = str;
		break;
	}
}

void crCreateRoleMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		int metierid, botid;
		std::string roleName;
		crEditBoxElement *metier_element = dynamic_cast<crEditBoxElement *>(stage->getElement(m_metierElement));
		if(metier_element)
		{
			metierid = atoi(metier_element->getStringArrayInString().c_str());
		}
		crEditBoxElement *bot_element = dynamic_cast<crEditBoxElement *>(stage->getElement(m_botElement));
		if(bot_element)
		{
			botid = atoi(bot_element->getStringArrayInString().c_str());
		}
		crEditBoxElement *name_element = dynamic_cast<crEditBoxElement *>(stage->getElement(m_roleNameElement));
		if(name_element)
		{
			roleName = name_element->getStringArrayInString();
		}
        
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crCreateRolePacket packet;
			crCreateRolePacket::buildRequestPacket(packet,botid,metierid,roleName);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crCreateRole2Method
//
/////////////////////////////////////////
crCreateRole2Method::crCreateRole2Method():
m_metierid(1){}
crCreateRole2Method::crCreateRole2Method(const crCreateRole2Method& handle):
crMethod(handle),
m_metierWidget(handle.m_metierWidget),
m_roleNameWidget(handle.m_roleNameWidget),
m_metierid(handle.m_metierid)
{
}
void crCreateRole2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crCreateRole2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_metierWidget = str;
		break;
	case 1:
		m_roleNameWidget = str;
		break;
	case 2:
		m_metierid = atoi(str.c_str());
		break;
	}
}

void crCreateRole2Method::operator()(crHandle &handle)
{
	{
		crCanvasNode *canvas = m_this->getParentCanvas();
		if(!canvas) return;

		int metierid = m_metierid;
		int botid = 1;
		std::string roleName;
		ref_ptr<crStaticTextWidgetNode> metierWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_metierWidget));
		if(metierWidget.valid())
		{
			metierid = _wtoi(metierWidget->getString().c_str());
		}
		ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_roleNameWidget));
		if(nameWidget.valid())
		{
			roleName = nameWidget->getUTF8String();
		}
		crData *data = crBrain::getInstance()->getDataClass();
		void *param;
		data->getParam(WCHDATA_CreateRoleTab,param);
		crTableIO *table = (crTableIO *)param;
		if(table)
		{
			data->getParam(WCHDATA_CurrentRoleTabIndex,param);
			int index = *(int *)param;
			botid = atoi((*table)(index,1).c_str());
		}
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crCreateRolePacket packet;
			crCreateRolePacket::buildRequestPacket(packet,botid,metierid,roleName);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crQueryGameRoleListMethod
//
/////////////////////////////////////////
crQueryGameRoleListMethod::crQueryGameRoleListMethod(){}
crQueryGameRoleListMethod::crQueryGameRoleListMethod(const crQueryGameRoleListMethod& handle):
crMethod(handle)
{
}
void crQueryGameRoleListMethod::inputParam(int i, void *param)
{
}

void crQueryGameRoleListMethod::addParam(int i, const std::string& str)
{
}

void crQueryGameRoleListMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->getGameRoleCount()==0)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crQueryGameRoleListPacket packet;
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
///////////////////////////////////////////
////
////crWaitStartGameMethod
////
///////////////////////////////////////////
////CRCore::crCondition crWaitStartGameMethod::s_startGameCondition;
////CRCore::crMutex crWaitStartGameMethod::s_startGameMutex;
//CRCore::crBarrier crWaitStartGameMethod::s_startGameBarrier(2);
//char crWaitStartGameMethod::s_code = 0;
//crWaitStartGameMethod::crWaitStartGameMethod(){}
//crWaitStartGameMethod::crWaitStartGameMethod(const crWaitStartGameMethod& handle):
//crMethod(handle)
//{
//	s_code = 0;
//}
//void crWaitStartGameMethod::inputParam(int i, void *param)
//{
//}
//
//void crWaitStartGameMethod::addParam(int i, const std::string& str)
//{
//}
//void crWaitStartGameMethod::startGame(char code)
//{
//	CRCore::crThread::yieldCurrentThread();
//	s_code = code;
//	//s_startGameCondition.signal();
//	s_startGameBarrier.block();
//}
//void crWaitStartGameMethod::operator()(crHandle &handle)
//{
//	//s_startGameCondition.wait(&s_startGameMutex,INFINITE);
//	s_startGameBarrier.block();
//	bool sucess = s_code>0;
//	handle.outputParam(0,&sucess);
//	s_code = 0;
//}
///////////////////////////////////////////
////
////crStartGameMethod
////
///////////////////////////////////////////
//crStartGameMethod::crStartGameMethod():
//m_code(0){}
//crStartGameMethod::crStartGameMethod(const crStartGameMethod& handle):
//crMethod(handle),
//m_code(handle.m_code)
//{
//}
//void crStartGameMethod::inputParam(int i, void *param)
//{
//}
//
//void crStartGameMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_code = (char)(atoi(str.c_str()));
//		break;
//	}
//}
//
//void crStartGameMethod::operator()(crHandle &handle)
//{
//	crWaitStartGameMethod::startGame(m_code);
//}
/////////////////////////////////////////
//
//crNetMouseControlViewMethod
//
/////////////////////////////////////////
crNetMouseControlViewMethod::crNetMouseControlViewMethod():
m_rotMode(XYRot),
m_time(0.0f)
{
}

crNetMouseControlViewMethod::crNetMouseControlViewMethod(const crNetMouseControlViewMethod& handle):
crMethod(handle),
m_rotMode(handle.m_rotMode),
m_time(0.0f)
{
}

void crNetMouseControlViewMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crNetMouseControlViewMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		if(str.compare("XRot") == 0)
		{
			m_rotMode = XRot;
		}
		else if(str.compare("YRot") == 0)
		{
			m_rotMode = YRot;
		}
		else if(str.compare("XYRot") == 0)
		{
			m_rotMode = XYRot;
		}
		break;
	}
}
void crNetMouseControlViewMethod::operator()(crHandle &handle)
{
	if(m_ea.valid() && m_this == crMyPlayerData::getInstance()->getCurrentRole())
	{
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		if(bot)
		{
			crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
			if(bindview && bindview->isInited() && !bindview->isCursorOnShow())
			{
				crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
				float dt = m_ea->time() - m_time;
				if(dt>0.5f)
				{
					m_time = m_ea->time();
					return;
				}
				//if(dt>0.05) dt = 0.05;
				float x = 0.0f;
				float y = 0.0f;
				float mouseSpeed = crDisplaySettings::instance()->getMouseSpeed();
				if(m_rotMode & XRot)
					x = -inDegrees(mouse[0]*200.0f*mouseSpeed/*dt*/);
				if(m_rotMode & YRot)
					y = -inDegrees(mouse[1]*100.0f*mouseSpeed/*dt*/);
				//CRCore::notify(CRCore::ALWAYS)<<"m_mouse_speed = "<<m_mouse_speed<< std::endl;
				//CRCore::notify(CRCore::ALWAYS)<<"x = "<<mouse[0]<<"y = "<<mouse[1]<<"dt = "<<dt<< std::endl;
				//if(fabs(y)<0.01f) y = 0.0; 
				m_time = m_ea->time();

				m_turn_angle.set(x,y);
				bot->rotate(m_turn_angle);
			}
		}
	}
}
/////////////////////////////////////////
//
//crNetStopMoveMethod
//
/////////////////////////////////////////
crNetStopMoveMethod::crNetStopMoveMethod()
{
}

crNetStopMoveMethod::crNetStopMoveMethod(const crNetStopMoveMethod& handle):
crMethod(handle)
{
}

void crNetStopMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crNetStopMoveMethod::addParam(int i, const std::string& str)
{
}

void crNetStopMoveMethod::operator()(crHandle &handle)
{
	{
		unsigned char itemstate = IS_Stop;
		m_this->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
		crNode *bot = m_this->getRelNode();
		if(bot)
		{
		    m_this->doEvent(WCH_NodeCoordToItem,MAKEINT64(NULL,bot));
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(24);
			stream->_writeInt(m_this->getPosx());
			stream->_writeInt(m_this->getPosy());
			stream->_writeInt(m_this->getPosz());
			stream->_writeFloat(m_this->getDirx());
			stream->_writeFloat(m_this->getDiry());//4
			stream->_writeFloat(m_this->getDirz());//4

			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvStopMove,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				//CRCore::notify(CRCore::ALWAYS)<<"send crPlayerEventPacket WCH_RecvStopMove"<<std::endl;
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvStopMoveMethod
//
/////////////////////////////////////////
crRecvStopMoveMethod::crRecvStopMoveMethod():
m_netType(GameClient_Game){}
crRecvStopMoveMethod::crRecvStopMoveMethod(const crRecvStopMoveMethod& handle):
crMethod(handle)
{
}
void crRecvStopMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvStopMoveMethod::addParam(int i, const std::string& str)
{
}

void crRecvStopMoveMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//void *param;
		//crData *data = m_this->getDataClass();
		crVector3i pos;
		pos[0] = m_stream->_readInt();
		pos[1] = m_stream->_readInt();
		pos[2] = m_stream->_readInt();
		//pos 合法性检查
		m_this->setPosxy(pos[0],pos[1]);
		m_this->setPosz(pos[2]);
		crVector3 dir;
		dir[0] = m_stream->_readFloat();
		dir[1] = m_stream->_readFloat();
		dir[2] = m_stream->_readFloat();
		m_this->setTargetDir(dir);
		unsigned char itemstate = IS_Stop;
		m_this->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
		//if(m_netType == GameClient_Game)
		//{
		//	crMatterGroup *body = dynamic_cast<crMatterGroup *>(m_this->getNode());
		//	crViewMatterObject *this_bot = NULL;
		//	if(body)
		//	{
		//		this_bot = dynamic_cast<crViewMatterObject *>(body->getChild(0));
		//		crVector3 nullpos;
		//		float speed = 0.0f;
		//		this_bot->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));//停止移动
		//		m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(this_bot,crMatterObject::MD_FullMatrix));
		//	}
		//}
		//CRCore::notify(CRCore::ALWAYS)<<"recv crPlayerEventPacket WCH_RecvStopMove"<<std::endl;
	}
}
/////////////////////////////////////////
//
//crRecvItemRTDataMethod
//
/////////////////////////////////////////
crRecvItemRTDataMethod::crRecvItemRTDataMethod():
m_staticRoot(false){}
crRecvItemRTDataMethod::crRecvItemRTDataMethod(const crRecvItemRTDataMethod& handle):
crMethod(handle),
m_staticRoot(handle.m_staticRoot)
{
}
void crRecvItemRTDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvItemRTDataMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_staticRoot = (bool)(atoi(str.c_str()));
		break;
	}
}

void crRecvItemRTDataMethod::operator()(crHandle &handle)
{
	{
		crData *data = m_this->getDataClass();
		if(m_stream.valid())
		{
			float x = m_stream->_readFloat();
			float y = m_stream->_readFloat();
			//pos[2] = m_stream->_readFloat();
			float scale = crGlobalHandle::gData()->gUnitScale();
			CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
			float z = scene->getPosZ(m_this->getLayerID(),x*scale,y*scale,m_this->getZoffset()*scale);
			m_this->setPosxy(x,y);
			m_this->setPosz(z/scale);
			crVector3 dir;
			dir[0] = m_stream->_readFloat();
			dir[1] = m_stream->_readFloat();
			dir[2] = m_stream->_readFloat();
			m_this->setDir(dir);
		}
		crNode *relNode = m_this->getRelNode();
		unsigned char itemtype = m_this->getItemtype();
		if(m_stream.valid() && itemtype>=crInstanceItem::Npc && itemtype<=crInstanceItem::Role)
		{
			if(relNode)
			{
				m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
				if(crMyPlayerData::getInstance()->isTeammateAndShareSight(m_this))
				{
					relNode->setVisiable(true);
					relNode->setEnableIntersect(true);
					//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				}
			}

			unsigned char targetType = m_stream->_readUChar();
			data->inputParam(WCHDATA_TargetType, &targetType);
			crVector3 targetPos;
			if(targetType & Target_Instance || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
			{
				int targetid = m_stream->_readInt();
				data->inputParam(WCHDATA_TargetID,&targetid);
				if(targetType & Target_Role)
				{
					int targetroleid = m_stream->_readInt();
					data->inputParam(WCHDATA_TargetRoleID,&targetroleid);
				}
			}
			else
			{
                targetPos = m_stream->_readVec3();
				data->inputParam(WCHDATA_TargetPos,&targetPos);
			}
			unsigned char itemstate = m_stream->_readUChar();
			data->inputParam(WCHDATA_ItemState,&itemstate);
			unsigned int guisestate = m_stream->_readUInt();
			data->inputParam(WCHDATA_GuiseState,&guisestate);

			//float followDistance = m_stream->_readFloat();
			//data->inputParam(WCHDATA_FollowDistance,&followDistance);

			float rthp = m_stream->_readFloat();
			data->inputParam(WCHDATA_RTHP,&rthp);
			float rtmp = m_stream->_readFloat();
			data->inputParam(WCHDATA_RTMP,&rtmp);

			//if(relNode)
			//{
			//	if(!(targetType & Target_Instance) && itemstate >= IS_Move/* && itemstate <= IS_Patrol*/)
			//	{
			//		//float speed = 0;
			//		//m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
			//		//float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
			//		//if(m_this == crMyPlayerData::getInstance()->getRole())
			//		//	node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&targetPos,&relspeed));
			//		//else
			//		//	node->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&targetPos,&relspeed));
			//		crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->recvPathFindRequest(m_this);
			//	}
			//	//else
			//	//{
			//	//	crVector3 nullpos;
			//	//	float speed = 0.0f;
			//	//	if(m_this == crMyPlayerData::getInstance()->getRole())
			//	//		node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));
			//	//	else
			//	//		node->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));
			//	//}
			//}
			if(m_this->getItemtype() == crInstanceItem::Role)
			{//如果是玩家，还应检查其身上装备的同步问题， 玩家的NetStream变化问题
				data->excHandle(MAKEINT64(WCH_LockData,1));
				unsigned char size = m_stream->_readUChar();
				unsigned char i;
				int int1,int2;
				void *param;
				data->getParam(WCHDATA_QuickList,param);
				QuickList *quickList = (QuickList *)param;
				quickList->clear();
				for(i = 0; i<size; i++)
				{
					int1 = m_stream->_readInt();
					int2 = m_stream->_readInt();
					quickList->push_back(std::make_pair(int1,int2));
				}
				data->getParam(WCHDATA_EquipOnMap,param);
				EquipOnMap *equipOnMap = (EquipOnMap *)param;
				size = m_stream->_readUChar();
				equipOnMap->clear();
				for(i = 0; i<size; i++)
				{
					int1 = m_stream->_readInt();
					int2 = m_stream->_readInt();
					equipOnMap->insert(std::make_pair(int1,int2));
				}
				//Tank
				data->getParam(WCHDATA_AttackMap,param);
				AttackMap *attackMap = (AttackMap *)param;
				size = m_stream->_readUChar();
				attackMap->clear();
				for(i = 0; i<size; i++)
				{
					int1 = m_stream->_readInt();
					int2 = m_stream->_readInt();
					attackMap->insert(std::make_pair(int1,int2));
				}
				data->getParam(WCHDATA_BackPackMap,param);
				BackPackMap *backPackMap = (BackPackMap *)param;
				size = m_stream->_readUChar();
				backPackMap->clear();
				for(i = 0; i<size; i++)
				{
					int1 = m_stream->_readInt();
					int2 = m_stream->_readInt();
					backPackMap->insert(std::make_pair(int1,int2));
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));

				data->excHandle(MAKEINT64(WCH_CheckNetData,m_this));
				m_this->doEvent(WCH_CheckAndRackEquipOnMesh);
			}
		}
		else
		{//只在loaditem的时候才会触发接收一次
			if(relNode)
			{
				//if(!m_staticRoot)
				//{
				//	crAcceptGIVisitor acceptGI(1);
				//	relNode->accept(acceptGI);
				//}

			    m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
				void *param;
				data->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate == IS_ItemLoad)
				{
					itemstate = IS_None;
					data->inputParam(WCHDATA_ItemState,&itemstate);
					const std::string &resScript = m_this->getAbstractItem()->getResScript();
					if(!resScript.empty())
					{
						CREncapsulation::loadItemCfg(resScript,dynamic_cast<crGroup *>(relNode)/*,m_staticRoot*/);
						crData *nodeData = relNode->getDataClass();
						if(nodeData)
						{
							nodeData->inputParam(WCHDATA_Item,m_this);
						}
					}
					else
					{
						CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod(): resScript是空的 "<<std::endl;
					}
				}
				//if(!m_staticRoot) node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				if(m_staticRoot)
				{
					relNode->setVisiable(true);
					relNode->setEnableIntersect(true);
				}
			}
		}
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvItemRTDataMethod pos = "<<pos<<std::endl;
	}
}
/////////////////////////////////////////
//
//crRecvItemChildDataMethod
//
/////////////////////////////////////////
crRecvItemChildDataMethod::crRecvItemChildDataMethod(){}
crRecvItemChildDataMethod::crRecvItemChildDataMethod(const crRecvItemChildDataMethod& handle):
crMethod(handle)
{
}
void crRecvItemChildDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvItemChildDataMethod::addParam(int i, const std::string& str)
{
}
void crRecvItemChildDataMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		ref_ptr<crItemChild> itemchild;
		ref_ptr<crInstanceItem> item;

		itemchild = new crItemChild;
		itemchild->setItemChildID(m_stream->_readInt());
		readItem(item,m_stream.get(),false);
		itemchild->setInstanceItem(item.get());
		//m_this->insertChildItem(itemchild.get());
		crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(itemchild.get(),m_this));
		//crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(NULL,NULL));//清理
	}
}
/////////////////////////////////////////
//
//crNodeInRangeMethod
//
/////////////////////////////////////////
crNodeInRangeMethod::crNodeInRangeMethod():
m_frameDelay(0)
{
}

crNodeInRangeMethod::crNodeInRangeMethod(const crNodeInRangeMethod& handle):
crMethod(handle),
m_frameDelay(0)
{
}

void crNodeInRangeMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_node = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_node = (CRCore::crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_frameDelay = (short)(LOINT64(param64));
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(HIINT64(param64));
		}
		else
		{
			m_frameDelay = 0;
			m_updateVisitor = NULL;
		}
		break;
	}
}

void crNodeInRangeMethod::addParam(int i, const std::string& str)
{
}

void crNodeInRangeMethod::operator()(crHandle &handle)
{
	if(m_node.valid() && m_updateVisitor.get())
	{//可以加入一个能程现半透明渐变的材质
		//m_frameDelay--;
		//if(m_frameDelay>0)
		//          m_node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,m_frameDelay));
		float dt = crFrameStamp::getInstance()->getFrameInterval();
		if(m_frameDelay>0)
		{
			float delay = (float)m_frameDelay / 1000.0f;
			delay -= dt;
			m_frameDelay = floor(delay * 1000.0f);
			m_node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,m_frameDelay));
		}
		else
		{
	        m_node->setVisiable(true);
			m_node->setEnableIntersect(true);
		}
	}
}
/////////////////////////////////////////
//
//crNodeOutRangeMethod
//
/////////////////////////////////////////
crNodeOutRangeMethod::crNodeOutRangeMethod():
m_frameDelay(0)
{
}

crNodeOutRangeMethod::crNodeOutRangeMethod(const crNodeOutRangeMethod& handle):
crMethod(handle),
m_frameDelay(0)
{
}

void crNodeOutRangeMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_node = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_node = (CRCore::crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_frameDelay = (short)(LOINT64(param64));
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(HIINT64(param64));
		}
		else
		{
			m_frameDelay = 0;
			m_updateVisitor = NULL;
		}
		break;
	}
}

void crNodeOutRangeMethod::addParam(int i, const std::string& str)
{
}

void crNodeOutRangeMethod::operator()(crHandle &handle)
{
	if(m_node.valid() && m_updateVisitor.valid())
	{//可以加入一个能程现半透明渐变的材质
		//m_frameDelay--;
		//if(m_frameDelay>0)
		//	m_node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeOutRange,m_frameDelay));
		float dt = crFrameStamp::getInstance()->getFrameInterval();
		if(m_frameDelay>0)
		{
			float delay = (float)m_frameDelay / 1000.0f;
			delay -= dt;
			m_frameDelay = floor(delay * 1000.0f);
			m_node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeOutRange,m_frameDelay));
		}
		else
		{
			m_node->setVisiable(false);
			//m_node->setEnableIntersect(false);
		}
	}
}

/////////////////////////////////////////
//
//crRecvCreateItemChildMethod
//
/////////////////////////////////////////
crRecvCreateItemChildMethod::crRecvCreateItemChildMethod(){}
crRecvCreateItemChildMethod::crRecvCreateItemChildMethod(const crRecvCreateItemChildMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvCreateItemChildMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvCreateItemChildMethod::addParam(int i, const std::string& str)
{
}

void crRecvCreateItemChildMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		int parentid = m_recvDataStream->getStreamID();
		crStreamBuf *stream = m_recvDataStream->getStream();
		unsigned char itemtype = stream->_readUChar();
		int id = stream->_readInt();
		int roleid = itemtype == crInstanceItem::Role?stream->_readInt():0;
		int itemchildid = stream->_readInt();
	    ref_ptr<crInstanceItem> rootitem;
		if(itemtype == crInstanceItem::Role)
		{
			if(id == crMyPlayerData::getInstance()->getPlayerID())
			{
				rootitem = crMyPlayerData::getInstance()->getRole(roleid);
			}
			else
			{
				crMyPlayerData::RoleNpcPair roleNpcPair;
				if(crMyPlayerData::getInstance()->findInRangePlayer(id,roleid,roleNpcPair))
				{
					rootitem = roleNpcPair.first.get();
				}
				else if(crMyPlayerData::getInstance()->findOutRangePlayer(id,roleid,roleNpcPair))
				{
					rootitem = roleNpcPair.first.get();
				}
			}
		}
		else if(itemtype == crInstanceItem::Npc)
		{
			crMyPlayerData::ItemNpcPair itemNpcPair;
			if(crMyPlayerData::getInstance()->findInRangeNpc(id,itemNpcPair))
			{
				rootitem = itemNpcPair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeNpc(id,itemNpcPair))
			{
				rootitem = itemNpcPair.first.get();
			}
		}
		else
		{
			crMyPlayerData::ItemNodePair itemNodePair;
			if(crMyPlayerData::getInstance()->findInRangeItem(id,itemNodePair))
			{
				rootitem = itemNodePair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeItem(id,itemNodePair))
			{
				rootitem = itemNodePair.first.get();
			}
		}

		if(rootitem.valid())
		{
			ref_ptr<crInstanceItem> parentItem;
			if(parentid == rootitem->getInstanceItemID())
			{
				parentItem = rootitem.get();
			}
			else
			{
				crItemChild *itemchild = rootitem->findChildItem(parentid);
				if(itemchild) parentItem = itemchild->getInstanceItem();
			}
            
			if(parentItem.valid())
			{
				ref_ptr<crInstanceItem> item;
				readItem(item,stream,false);

				ref_ptr<crItemChild> itemChild = new crItemChild;
				itemChild->setItemChildID(itemchildid);
				itemChild->setInstanceItemID(item->getInstanceItemID());
				itemChild->setInstanceItem(item.get());
				itemChild->setParentItem(parentItem.get());
				parentItem->insertChildItem(itemChild.get());

				crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(itemChild.get(),rootitem.get()));
				//crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(NULL,NULL));//清理
			}
		}
	}
}
/////////////////////////////////////////
//
//crLoadItemChildMethod
//
/////////////////////////////////////////
crLoadItemChildMethod::crLoadItemChildMethod(){}
crLoadItemChildMethod::crLoadItemChildMethod(const crLoadItemChildMethod& handle):
crMethod(handle)
{
}
void crLoadItemChildMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_itemchild = NULL;
			m_rootitem = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_itemchild = (crItemChild *)(LOINT64(param64));
			m_rootitem = (crInstanceItem *)(HIINT64(param64));
		}
		else
		{
			m_itemchild = NULL;
			m_rootitem = NULL;
		}
		break;
	}
}

void crLoadItemChildMethod::addParam(int i, const std::string& str)
{
}

void crLoadItemChildMethod::operator()(crHandle &handle)
{
	if(m_itemchild.valid() && m_itemchild->getInstanceItem() && m_rootitem.valid())
	{
		//if(crGlobalHandle::isClient()/* && !crRunGameHandle::getInstance()->isInGame()*/)
		//	return;
		void *param;
		crData *rootData = m_rootitem->getDataClass();
		crInstanceItem *item = m_itemchild->getInstanceItem();
		int itemid = item->getInstanceItemID();
		if(crGlobalHandle::isClient())
		{
			//if(m_rootitem == crMyPlayerData::getInstance()->getRole())
			//	item->loadItemData(PlayerStream);
			//else
                item->loadItemData(NetStream);
		}
		else
			item->loadItemData(SaveStream);
		crData *itemdata = item->getDataClass();
		if(itemdata)
		{
			itemdata->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *((unsigned char*)param);
			int abstractid = item->getAbstractItemID();
			rootData->excHandle(MAKEINT64(WCH_LockData,1));
			bool loadNode = false;
			if(datatype == DT_Attack)
			{
				rootData->getParam(WCHDATA_AttackMap,param);
				AttackMap* attackMap = (AttackMap* )param;
				if(attackMap && attackMap->find(abstractid) != attackMap->end())
				{
					(*attackMap)[abstractid] = itemid;
					loadNode = true;
				}
			}
			//else if(datatype == DT_Skill)
			//{
			//	rootData->getParam(WCHDATA_SkillMap,param);
			//	SkillMap* skillMap = (SkillMap* )param;
			//	if(skillMap && skillMap->find(abstractid) != skillMap->end())
			//	{
			//	    (*skillMap)[abstractid] = itemid;
			//		loadNode = true;
			//	}
			//}
			else
			{//背包、仓库、身上、快捷栏、出售栏,itemid>0的只能存在于BackPackMap中
				//创建>0的itemid时，需要将item放入BackPackMap，然后将其itemid设为0，AttackMap和SkillMap除外
				//放在其它栏里的item不可以创建>0的itemid
				if(crGlobalHandle::isClient() && (datatype == DT_AttackThing || datatype == DT_Skill))
				{
					loadNode = true;
				}
				rootData->getParam(WCHDATA_EquipOnMap,param);
				EquipOnMap* equipOnMap = (EquipOnMap*)param;
				if(equipOnMap)
				{
					bool equipOnMapChanged = false;
					EquipOnMap::iterator eitr = equipOnMap->find(abstractid);
					for(; eitr!= equipOnMap->end() && eitr->first == abstractid; ++eitr)
					{
						//if(itemid>0)
						//{//
						//	if(eitr->second==0)
						//	{
						//		eitr->second = itemid;
						//		equipOnMapChanged = true;
						//	}
						//}
						//else
						//{
						//	if(eitr->second == 0/*INT_MIN*/)
						//	{
						//		eitr->second = itemid;
						//		equipOnMapChanged = true;
						//	}
						//}
						eitr->second = itemid;
						equipOnMapChanged = true;
					}
					if(crGlobalHandle::isClient() && equipOnMapChanged)
					{
						//if( crMyPlayerData::getInstance()->ifItemIsMe(m_rootitem.get()) )
						//	m_rootitem->doEvent(WCH_BuildEquipOnList,NULL);
						m_rootitem->doEvent(WCH_CheckAndRackEquipOnMesh,NULL);
					}
				}
				rootData->getParam(WCHDATA_SkillMap,param);
				SkillMap* skillMap = (SkillMap* )param;
				if(skillMap && skillMap->find(abstractid) != skillMap->end())
				{
					(*skillMap)[abstractid] = itemid;
					loadNode = true;
				}
				//rootData->getParam(WCHDATA_BackPackMap,param);
				//BackPackMap* backPackMap = (BackPackMap*)param;
				//if(backPackMap)
				//{
				//	bool backpackChanged = false;
				//	BackPackMap::iterator bitr = backPackMap->find(abstractid);
				//	for(; bitr!= backPackMap->end() && bitr->first == abstractid; ++bitr)
				//	{
				//		if(itemid>0)
				//		{//
				//			if(bitr->second==0)
				//			{
				//				bitr->second = itemid;
				//				backpackChanged = true;
				//			}
				//		}
				//		else
				//		{
				//			if(bitr->second == 0/*INT_MIN*/)
				//			{
				//				bitr->second = itemid;
				//				backpackChanged = true;
				//			}
				//		}
				//	}
				//	if(crGlobalHandle::isClient())
				//	{
				//		if(backpackChanged)
				//		{
				//			if( m_rootitem->getItemtype() == crInstanceItem::Role
				//				&& m_rootitem->getID() == crMyPlayerData::getInstance()->getPlayerID() )
				//				m_rootitem->doEvent(WCH_BuildBackPackList,NULL);
				//		}
				//	}
				//}
				//rootData->getParam(WCHDATA_StorageMap,param);
				//StorageMap* storageMap = (StorageMap*)param;
				//if(storageMap)
				//{
				//	bool storageChanged = false;
				//	StorageMap::iterator sitr = storageMap->find(abstractid);
				//	for(; sitr!= storageMap->end() && sitr->first == abstractid; ++sitr)
				//	{
				//		if(itemid>0)
				//		{//
				//			if(sitr->second==0)
				//			{
				//				sitr->second = itemid;
				//				storageChanged = true;
				//			}
				//		}
				//		else
				//		{
				//			if(sitr->second == 0/*INT_MIN*/)
				//			{
				//				sitr->second = itemid;
				//				storageChanged = true;
				//			}
				//		}
				//	}
				//	if(crGlobalHandle::isClient())
				//	{
				//		if(storageChanged)
				//		{
				//			if( crMyPlayerData::getInstance()->ifItemIsMe(m_rootitem.get()) )
				//				m_rootitem->doEvent(WCH_BuildStorageItemList,NULL);
				//		}
				//	}
				//}
			}
			//rootData->getParam(WCHDATA_SaleItemMap,param);
			//SaleItemMap* saleMap = (SaleItemMap*)param;
			//if(saleMap)
			//{
			//	SaleItemMap::iterator saitr = saleMap->find(abstractid);
			//	for(; saitr!= saleMap->end() && saitr->first == abstractid; ++saitr)
			//	{
			//		if(itemid>0)
			//		{//
			//			if(saitr->second[0]==0)
			//			{
			//				saitr->second[0] = itemid;
			//			}
			//		}
			//		else
			//		{
			//			if(saitr->second[0] == 0/*INT_MIN*/)
			//			{
			//				saitr->second[0] = itemid;
			//			}
			//		}
			//	}
			//}
			//////////////
			//rootData->getParam(WCHDATA_QuickList,param);
			//QuickList* quickList = (QuickList*)param;
			//if(quickList)
			//{
			//	bool quickListChanged = false;
			//	for( QuickList::iterator qitr = quickList->begin(); 
			//		qitr!= quickList->end() && qitr->first == abstractid; 
			//		++qitr)
			//	{
			//		if(itemid>0)
			//		{//
			//			if(qitr->second==0)
			//			{
			//				qitr->second = itemid;
			//				quickListChanged = true;
			//			}
			//		}
			//		else
			//		{
			//			if(qitr->second == 0/*INT_MIN*/)
			//			{
			//				qitr->second = itemid;
			//				quickListChanged = true;
			//			}
			//		}
			//	}
			//	if(crGlobalHandle::isClient())
			//	{
			//		if(quickListChanged && crMyPlayerData::getInstance()->ifItemIsMe(m_rootitem.get()))
			//		{
			//			m_rootitem->doEvent(WCH_BuildQuickList,NULL);
			//		}
			//	}
			//}
			rootData->excHandle(MAKEINT64(WCH_LockData,0));
			if(crGlobalHandle::isClient())
			{
				if(loadNode)
					item->clientLoadItemChildNode(m_rootitem.get());
				//else if(m_rootitem == crMyPlayerData::getInstance()->getRole())
				//	m_rootitem->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
			}
			//else
			//{
			//	m_rootitem->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
			//}
			m_rootitem->insertChildItem(m_itemchild.get());
		}
	}
	m_itemchild = NULL;
	m_rootitem = NULL;
}
/////////////////////////////////////////
//
//crUseItemCheckMethod
//
/////////////////////////////////////////
crUseItemCheckMethod::crUseItemCheckMethod():m_useItemParam(NULL){}
crUseItemCheckMethod::crUseItemCheckMethod(const crUseItemCheckMethod& handle):
	crMethod(handle),
	m_useItemParam(NULL)
{
}
void crUseItemCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam*)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crUseItemCheckMethod::addParam(int i, const std::string& str)
{
}

void crUseItemCheckMethod::operator()(crHandle &handle)
{
	if(crGlobalHandle::isClient() && !m_this->getNode())
		return;
	if(m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			crInstanceItem *targetItem = m_useItemParam->m_target.get();
			if(targetItem && targetItem->getDataClass())
			{
				crData *targetData = targetItem->getDataClass();
				targetData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *((unsigned char*)param);
				if(itemstate == IS_Dead)
				{//IS_Dead
					*m_useResult = UR_TargetDead;
					break;
				}
				//targetData->getParam(WCHDATA_RTHP,param);
				//float* rthp = (float *)param;
				//if(rthp && *rthp <= 0)
				//{//IS_Dead
				//	*m_useResult = UR_TargetDead;
				//	break;
				//}
			}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			thisData->getParam(WCHDATA_NeedMP,param);
			unsigned short needMP = *(unsigned short*)param;
			float *rtmp = NULL;
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			if(needMP>0)
			{
				userData->getParam(WCHDATA_RTMP,param);
				rtmp = (float*)param;
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<=needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			//UR_TargetInvalid check
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			*m_useResult = UR_Succeed;

		}while(0);

		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crUseItemMethod
//
/////////////////////////////////////////
crUseItemMethod::crUseItemMethod():m_useItemParam(NULL){}
crUseItemMethod::crUseItemMethod(const crUseItemMethod& handle):
crMethod(handle),
m_useItemParam(NULL)
{
}
void crUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam*)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crUseItemMethod::addParam(int i, const std::string& str)
{
}

void crUseItemMethod::operator()(crHandle &handle)
{
	if(m_this->getNode() && m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			crInstanceItem *targetItem = m_useItemParam->m_target.get();
			if(targetItem && targetItem->getDataClass())
			{
				crData *targetData = targetItem->getDataClass();
				targetData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *((unsigned char*)param);
				if(itemstate == IS_Dead)
				{//IS_Dead
					*m_useResult = UR_TargetDead;
					break;
				}
				//targetData->getParam(WCHDATA_RTHP,param);
				//float* rthp = (float *)param;
				//if(rthp && *rthp <= 0)
				//{//IS_Dead
				//	*m_useResult = UR_TargetDead;
				//	break;
				//}
			}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<=cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			thisData->getParam(WCHDATA_NeedMP,param);
			unsigned short needMP = *(unsigned short*)param;
			float *rtmp = NULL;
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			if(needMP>0)
			{
                userData->getParam(WCHDATA_RTMP,param);
				rtmp = (float*)param;
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<=needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			//UR_TargetInvalid check
			if(rtmp)
			{
                *rtmp -= needMP;
			}
			if(rthp)
			{
                *rthp -= needHP;
			}
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			*m_useResult = UR_Succeed;
			lastUseTime = t1;
			thisData->inputParam(WCHDATA_LastUseTime,&lastUseTime);
			/////UserExtra
			//crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
			//if(handle)
			//{
			//	thisData->getParam(WCHDATA_UserExtraID,param);
			//	_crInt32 userExtraID = *((_crInt32*)param);

			//	//userData->excHandle(MAKEINT64(WCH_LockData,1));
			//	userData->getParam(WCHDATA_ExtraData,param);
			//	crData *extraData = (crData *)param;
			//	if(extraData)
			//	{
			//		bool can = true;
			//		short extraid = LOINT32(userExtraID);
			//		short extrapri = HIINT32(userExtraID);
			//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
			//		extraData->getParam(WCHDATA_ExtraIDMap,param);
			//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
			//		ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
			//		if(exitr != extraIDMap->end())
			//		{
			//			if(extrapri<exitr->second)
			//			{
			//				can = false;
			//			}
			//		}
			//		if(can)
			//		{
			//			crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
			//			if(dynamic_cast<crNodeDrive *>(existhandle))
			//			{
			//				(dynamic_cast<crNodeDrive *>(existhandle))->releaseObjects(NULL);
			//			}
			//			crHandle *cloneHandle = handle->clone();
			//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
			//			(*extraIDMap)[extraid] = extrapri;
			//		}
			//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
			//	}
			//	//userData->excHandle(MAKEINT64(WCH_LockData,0));
			//}
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod"<<std::endl;
			//fire
			crNode *userNode = m_useItemParam->m_user->getRelNode();

			//ItemUsePair *itemUsePair = new ItemUsePair;
			ref_ptr<ItemUseParam> itemUseParam = new ItemUseParam;
			itemUseParam->m_itemid = m_this->getID();
			itemUseParam->m_dirOffset = m_useItemParam->m_dirOffset;
			//itemUsePair->first = dynamic_cast<crGroup *>(m_this->getNode());
			itemUseParam->m_weapon = dynamic_cast<crGroup *>(m_this->getNode());
			if(targetItem)
			{
				crNode *targetNode = targetItem->getRelNode();
				if(targetNode)
				{
					//itemUsePair->second.first = targetNode;
					itemUseParam->m_targetNode = targetNode;
					if(dynamic_cast<crMatterObject *>(targetNode))
					{
						//itemUsePair->second.second = (dynamic_cast<crMatrixTransform *>(targetNode))->getTrans();
						itemUseParam->m_targetPos = (dynamic_cast<crMatterObject *>(targetNode))->getPhysicsCenter();
					}
					else
					{
						//itemUsePair->second.second = targetNode->getBound().center();
						itemUseParam->m_targetPos = targetNode->getBound().center();
					}
				}
				else
				{
					itemUseParam->m_targetNode = NULL;
					itemUseParam->m_targetPos = targetItem->getPosition();
					if(userNode) itemUseParam->m_targetPos[2] += userNode->getBoundBox().zLength()*0.5f;
				}
			}
			else
			{
				//itemUsePair->second.first = NULL;
				itemUseParam->m_targetNode = NULL;
				userData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill/* || itemstate == IS_AttackToPos*/)
				{
					userData->getParam(WCHDATA_MoveToPos,param);
				}
				else
				{
					userData->getParam(WCHDATA_TargetPos,param);
				}
				//itemUsePair->second.second = *((crVector3*)param);
				itemUseParam->m_targetPos = *((crVector3*)param);
			}
			//if(!userNode->getVisiable()||!userNode->getEnableIntersect())
			//{
   //             userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,5));
			//}
			//userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
			//if(userNode)
			//    userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_ItemUse,itemUseParam/*itemUsePair*/));

			thisData->getParam(WCHDATA_UseItemProtectTime,param);//吟唱时间
			float itemProtectTime = *(float *)param;
			//userData->inputParam(WCHDATA_CurUseItemProtectTime,&itemProtectTime);
			thisData->getParam(WCHDATA_DataType,param);
			datatype = *(unsigned char *)param;
			if(datatype == DT_Attack)
			{//普通攻击，做暴击判断
				//命中率判定
				//m_useItemParam->m_user->doEvent(WCH_HitratioTest);
				//userData->getParam(WCHDATA_IsMiss,param);
				//bool isMiss = *(bool *)param;
				//if(!isMiss)
				//	m_useItemParam->m_user->doEvent(WCH_CritTest);
				userData->inputParam(WCHDATA_AttackUseParam,itemUseParam.get());
				m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&cdtime,m_this));
				//char gbuf[256];
				//sprintf(gbuf,"UseItem Weapon:%d,targetNode:%d\n\0",itemUseParam->m_weapon->getChild(0),itemUseParam->m_targetNode.get());
				//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
			}
			else
			{
				userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
				m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&itemProtectTime,m_this));
			}

			if(datatype == DT_AttackThing)
			{//道具数量减1
				char removeItem = -1;
				m_useItemParam->m_user->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
			}
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod "<<std::endl;
		}while(0);
		
		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crServerUseItemMethod
//
/////////////////////////////////////////
crServerUseItemMethod::crServerUseItemMethod():m_useItemParam(NULL){}
crServerUseItemMethod::crServerUseItemMethod(const crServerUseItemMethod& handle):
crMethod(handle),
m_useItemParam(NULL)
{
}
void crServerUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam *)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crServerUseItemMethod::addParam(int i, const std::string& str)
{
}

void crServerUseItemMethod::operator()(crHandle &handle)
{
	if(m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			crInstanceItem *targetItem = m_useItemParam->m_target.get();
			if(targetItem && targetItem->getDataClass())
			{
				crData *targetData = targetItem->getDataClass();
				targetData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *((unsigned char*)param);
				if(itemstate == IS_Dead)
				{//IS_Dead
					*m_useResult = UR_TargetDead;
					break;
				}
				//targetData->getParam(WCHDATA_RTHP,param);
				//float* rthp = (float *)param;
				//if(rthp && *rthp <= 0)
				//{//IS_Dead
				//	*m_useResult = UR_TargetDead;
				//	break;
				//}
			}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crServerUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			thisData->getParam(WCHDATA_NeedMP,param);
			unsigned short needMP = *(unsigned short*)param;
			float *rtmp = NULL;
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			if(needMP>0)
			{
				userData->getParam(WCHDATA_RTMP,param);
				rtmp = (float*)param;
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			//UR_TargetInvalid check

			if(rtmp)
			{
				*rtmp -= needMP;
			}
			if(rthp)
			{
				*rthp -= needHP;
			}
			userData->excHandle(MAKEINT64(WCH_LockData,0));

			*m_useResult = UR_Succeed;
			lastUseTime = t1;
			thisData->inputParam(WCHDATA_LastUseTime,&lastUseTime);
			if(datatype == DT_Skill)
			{///UserExtra
				//userData->excHandle(MAKEINT64(WCH_LockData,1));
				userData->getParam(WCHDATA_ExtraData,param);
				crData *extraData = (crData *)param;
				if(extraData)
				{
					crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Server));
					if(handle)
					{
						crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
						crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
						crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
						if(scene)
						{
							thisData->getParam(WCHDATA_UserExtraID,param);
							_crInt32 userExtraID = *((_crInt32*)param);

							bool can = true;
							short extraid = LOINT32(userExtraID);
							short extrapri = HIINT32(userExtraID);
							extraData->excHandle(MAKEINT64(WCH_LockData,1));
							extraData->getParam(WCHDATA_ExtraIDMap,param);
							ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
							ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
							if(exitr != extraIDMap->end())
							{
								if(extrapri<exitr->second)
								{
									can = false;
								}
							}
							if(can)
							{
								crHandle *cloneHandle = handle->clone();
								extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
								(*extraIDMap)[extraid] = extrapri;
							}
							extraData->excHandle(MAKEINT64(WCH_LockData,0));

							if(can)
							{
								unsigned char usertype = m_useItemParam->m_user->getItemtype();
								int userid = m_useItemParam->m_user->getID();
								int userroleid = m_useItemParam->m_user->getRoleID();
								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(4);
								stream->_writeInt(m_this->getInstanceItemID());
								if(usertype == crInstanceItem::Role)
								{
									crPlayerEventPacket packet;
									crPlayerEventPacket::buildRequestPacket(packet,userid,m_useItemParam->m_user.get(),WCH_RecvUserExtra,stream.get());
									ref_ptr<crSceneServerPlayerData> firePlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(userid));
									if(firePlayerData.valid())
									{
										sceneServerConductor->getNetManager()->sendPacket(firePlayerData->getPlayerConnectServerAddress(),packet);
									}
									scene->sendPacketToItemNeighbor(m_useItemParam->m_user.get(),packet);
								}
								else
								{
									crItemEventPacket packet;
									crItemEventPacket::buildRequestPacket(packet,0,m_useItemParam->m_user.get(),WCH_RecvUserExtra,stream.get());

									scene->sendPacketToItemNeighbor(m_useItemParam->m_user.get(),packet);
								}
							}
						}
					}
				}
				//userData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			//thisData->getParam(WCHDATA_UseItemProtectTime,param);
			//float itemProtectTime = *(float *)param;
			//userData->inputParam(WCHDATA_CurUseItemProtectTime,&itemProtectTime);
			//CRCore::notify(CRCore::ALWAYS)<<"crServerUseItemMethod"<<std::endl;
			//thisData->getParam(WCHDATA_DataType,param);
			//datatype = *(unsigned char*) param;
			//if(datatype == DT_AttackThing)
			//{//道具数量减1
			//	char removeItem = -1;
			//	m_useItemParam->m_user->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
			//}
			//else if(datatype == DT_Attack)
			//{//普通攻击，做暴击判断
			//	m_useItemParam->m_user->doEvent(WCH_HitratioTest);
			//	userData->getParam(WCHDATA_IsMiss,param);
			//	bool isMiss = *(bool *)param;
			//	if(!isMiss)
			//	{
			//		m_useItemParam->m_user->doEvent(WCH_CritTest);
			//		//目标做格挡躲避等判断
			//		if(targetItem && targetItem->getDataClass())
			//		{
			//			crData *targetData = targetItem->getDataClass();
			//			targetItem->doEvent(WCH_DodgeTest);
			//			targetData->getParam(WCHDATA_IsDodge,param);
			//			bool isDodge = *(bool *)param;
			//			if(!isDodge)
			//				targetItem->doEvent(WCH_ParryTest);
			//		}
			//	}
			//}
			//server要记录本次攻击
			crData *bulletitemData = m_this->getDataClass();
			if(bulletitemData)
			{
				bulletitemData->getParam(WCHDATA_DataType,param);
				unsigned char datatype = *(unsigned char*) param;
				if(datatype == DT_Attack && m_useItemParam->m_user->getItemtype() != crInstanceItem::Role)/* && !dynamic_cast<crRole *>(m_useItemParam->m_target.get()))*/
				{//NPC攻击NPC，或者攻击角色,立即命中
					CRCore::ref_ptr<HitParam> hitParam = new HitParam;
					hitParam->m_hitItem = m_useItemParam->m_target;
					hitParam->m_rate = 1.0f;
					hitParam->m_fireItem = m_useItemParam->m_user;
					//CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod "<<m_this->getID()<<std::endl;
					m_this->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));

					//if(datatype == DT_Attack)
					//{//普通攻击，做暴击判断
						m_useItemParam->m_user->doEvent(WCH_MissCritTest);
						if(m_useItemParam->m_target.valid())
							m_useItemParam->m_target->doEvent(WCH_DodgeParryTest);
					//}
				}
				else
				{
					thisData->getParam(WCHDATA_Duration,param);
					float duration = *(float *)param;
					ref_ptr<crUseItemRecord> userItemRecord = new crUseItemRecord;
					userItemRecord->setItem(m_this);
					userItemRecord->setUser(m_useItemParam->m_user.get());
					thisData->getParam(WCHDATA_DamageCount,param);
					unsigned char damagecount = *(unsigned char *)param;
					if(damagecount==1)
						userItemRecord->setTarget(m_useItemParam->m_target.get());//需要判断该技能是群攻还是单体攻击，如果是群攻则m_target＝NULL
					userItemRecord->setDamageCount(damagecount);
					userItemRecord->setDuration(duration);
					crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_UseItemRecordMap,param);
					UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
					useItemRecordMap->insert(std::make_pair(userItemRecord->getUser(),userItemRecord.get()));
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}while(0);
		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crNetUseItemMethod
//
/////////////////////////////////////////
crNetUseItemMethod::crNetUseItemMethod():m_usercdid(0){}
crNetUseItemMethod::crNetUseItemMethod(const crNetUseItemMethod& handle):
crMethod(handle),
m_usercdid(handle.m_usercdid)
{
}
void crNetUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_useItemParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam *)(LOINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
		}
		break;
	}
}

void crNetUseItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_usercdid = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crNetUseItemMethod::operator()(crHandle &handle)
{
	if(m_this->getNode() && m_useItemParam && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		///UserExtra
		void *param;
		crData *thisData = m_this->getDataClass();
		crData* userData = m_useItemParam->m_user->getDataClass();

		thisData->getParam(WCHDATA_NeedMP,param);
		unsigned short needMP = *(unsigned short*)param;
		float *rtmp = NULL;
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		if(needMP>0)
		{
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;
		}
		thisData->getParam(WCHDATA_NeedHP,param);
		unsigned short needHP = *(unsigned short*)param;
		float *rthp = NULL;
		if(needHP>0)
		{
			userData->getParam(WCHDATA_RTHP,param);
			rthp = (float*)param;
		}
		if(rtmp)
		{
			*rtmp -= needMP;
		}
		if(rthp)
		{
			*rthp -= needHP;
		}
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
		//if(handle)
		//{
		//	thisData->getParam(WCHDATA_UserExtraID,param);
		//	_crInt32 userExtraID = *((_crInt32*)param);

		//	//userData->excHandle(MAKEINT64(WCH_LockData,1));
		//	userData->getParam(WCHDATA_ExtraData,param);
		//	crData *extraData = (crData *)param;
		//	if(extraData)
		//	{
		//		bool can = true;
		//		short extraid = LOINT32(userExtraID);
		//		short extrapri = HIINT32(userExtraID);
		//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
		//		extraData->getParam(WCHDATA_ExtraIDMap,param);
		//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
		//		ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
		//		if(exitr != extraIDMap->end())
		//		{
		//			if(extrapri<exitr->second)
		//			{
		//				can = false;
		//			}
		//		}
		//		if(can)
		//		{
		//			crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
		//			if(dynamic_cast<crNodeDrive *>(existhandle))
		//			{
		//				(dynamic_cast<crNodeDrive *>(existhandle))->releaseObjects(NULL);
		//			}
		//			crHandle *cloneHandle = handle->clone();
		//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
		//			(*extraIDMap)[extraid] = extrapri;
		//		}
		//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
		//	}
		//	//userData->excHandle(MAKEINT64(WCH_LockData,0));
		//}
		//CRCore::notify(CRCore::ALWAYS)<<"crNetUseItemMethod"<<std::endl;
		//fire
		crNode *userNode = m_useItemParam->m_user->getRelNode();
		//ItemUsePair *itemUsePair = new ItemUsePair;
		ref_ptr<ItemUseParam> itemUseParam = new ItemUseParam;
		itemUseParam->m_itemid = m_this->getID();
		itemUseParam->m_dirOffset = m_useItemParam->m_dirOffset;
		//itemUsePair->first = dynamic_cast<crGroup *>(m_this->getNode());
		itemUseParam->m_weapon = dynamic_cast<crGroup *>(m_this->getNode());
		crInstanceItem *targetItem = m_useItemParam->m_target.get();
		if(targetItem)
		{
			crNode *targetNode = targetItem->getRelNode();
			if(targetNode)
			{
				//itemUsePair->second.first = targetNode;
				itemUseParam->m_targetNode = targetNode;
				if(dynamic_cast<crMatterObject *>(targetNode))
				{
					//itemUsePair->second.second = (dynamic_cast<crMatrixTransform *>(targetNode))->getTrans();
					itemUseParam->m_targetPos = (dynamic_cast<crMatterObject *>(targetNode))->getPhysicsCenter();
				}
				else
				{
					//itemUsePair->second.second = targetNode->getBound().center();
					itemUseParam->m_targetPos = targetNode->getBound().center();
				}
			}
			else
			{
				itemUseParam->m_targetNode = NULL;
				itemUseParam->m_targetPos = targetItem->getPosition();
				if(userNode) itemUseParam->m_targetPos[2] += userNode->getBoundBox().zLength()*0.5f;
			}
		}
		else
		{
			//itemUsePair->second.first = NULL;
			itemUseParam->m_targetNode = NULL;
			userData->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)param;
			if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill/* || itemstate == IS_AttackToPos*/)
			{
				userData->getParam(WCHDATA_MoveToPos,param);
			}
			else
			{
				userData->getParam(WCHDATA_TargetPos,param);
			}
			itemUseParam->m_targetPos = *((crVector3*)param);
		}
		//if(!userNode->getVisiable()||!userNode->getEnableIntersect())
		//{
		//	userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,5));
		//}
		//userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
		//if(userNode)
		//    userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_ItemUse,itemUseParam/*itemUsePair*/));

		//thisData->getParam(WCHDATA_CDTime,param);
		//float cdtime = *(float *)param;
		//float usercd = 0;
		//m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,m_usercdid),MAKEINT64(&usercd,NULL));
		//cdtime += usercd;
		thisData->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *(unsigned char*)param;
		if(datatype == DT_Attack)
		{
			userData->inputParam(WCHDATA_AttackUseParam,itemUseParam.get());
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&cdtime,m_this));
		}
		else
		{
			userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
			thisData->getParam(WCHDATA_UseItemProtectTime,param);
			float itemProtectTime = *(float *)param;
			m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&itemProtectTime,m_this));
		}
		//thisData->getParam(WCHDATA_DataType,param);
		//unsigned char datatype = *(unsigned char*) param;
		//if(datatype == DT_AttackThing)
		//{//道具数量减1
		//	char removeItem = -1;
		//	m_userAndTargetItem->first->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
		//}
		//发动攻击视野
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		char isEnemy = 0;
		me->doEvent(WCH_EnemyCheck,MAKEINT64(m_useItemParam->m_user.get(),&isEnemy));
		if(isEnemy!=1)
		{
			bool visable = true;
			//if(m_useItemParam->m_target.valid())
			//{
			//	if(m_useItemParam->m_target == m_useItemParam->m_user)
			//	{
			//		visable = false;
			//	}
			//	else
			//	{
			//		isEnemy = 0;
			//		me->doEvent(WCH_EnemyCheck,MAKEINT64(m_useItemParam->m_target.get(),&isEnemy));
			//		if(isEnemy!=1)
			//		{
			//			visable = false;
			//		}
			//	}
			//}
			crMyPlayerData::getInstance()->insertItemVisiable(m_useItemParam->m_user.get());
		}
	}
}
/////////////////////////////////////////
//
//crNetServerUseItemMethod
//
/////////////////////////////////////////
crNetServerUseItemMethod::crNetServerUseItemMethod(){}
crNetServerUseItemMethod::crNetServerUseItemMethod(const crNetServerUseItemMethod& handle):
crMethod(handle)
{
}
void crNetServerUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_useItemParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam *)(LOINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
		}
		break;
	}
}

void crNetServerUseItemMethod::addParam(int i, const std::string& str)
{
}

void crNetServerUseItemMethod::operator()(crHandle &handle)
{
	if(m_useItemParam && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		///UserExtra
		void *param;
		crData *thisData = m_this->getDataClass();
		crData* userData = m_useItemParam->m_user->getDataClass();

		thisData->getParam(WCHDATA_NeedMP,param);
		unsigned short needMP = *(unsigned short*)param;
		float *rtmp = NULL;
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		if(needMP>0)
		{
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;
		}
		thisData->getParam(WCHDATA_NeedHP,param);
		unsigned short needHP = *(unsigned short*)param;
		float *rthp = NULL;
		if(needHP>0)
		{
			userData->getParam(WCHDATA_RTHP,param);
			rthp = (float*)param;
		}
		if(rtmp)
		{
			*rtmp -= needMP;
		}
		if(rthp)
		{
			*rthp -= needHP;
		}
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Server));
		//if(handle)
		//{
		//	thisData->getParam(WCHDATA_UserExtraID,param);
		//	_crInt32 userExtraID = *((_crInt32*)param);

		//	//userData->excHandle(MAKEINT64(WCH_LockData,1));
		//	userData->getParam(WCHDATA_ExtraData,param);
		//	crData *extraData = (crData *)param;
		//	if(extraData)
		//	{
		//		//crHandle *cloneHandle = handle->clone();
		//		//extraData->insertHandle(MAKEINT64(WCH_DoExtra,userExtraID),cloneHandle);
		//		//extraData->inputParam(WCHDATA_ExtraIDSet,&userExtraID);
		//		bool can = true;
		//		short extraid = LOINT32(userExtraID);
		//		short extrapri = HIINT32(userExtraID);
		//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
		//		extraData->getParam(WCHDATA_ExtraIDMap,param);
		//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
		//		ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
		//		if(exitr != extraIDMap->end())
		//		{
		//			if(extrapri<exitr->second)
		//			{
		//				can = false;
		//			}
		//		}
		//		if(can)
		//		{
		//			crHandle *cloneHandle = handle->clone();
		//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
		//			(*extraIDMap)[extraid] = extrapri;
		//		}
		//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
		//	}
		//	//userData->excHandle(MAKEINT64(WCH_LockData,0));
		//}
		//CRCore::notify(CRCore::ALWAYS)<<"crNetServerUseItemMethod"<<std::endl;
		//thisData->getParam(WCHDATA_DataType,param);
		//unsigned char datatype = *(unsigned char*) param;
		//if(datatype == DT_AttackThing)
		//{//道具数量减1
		//	char removeItem = -1;
		//	m_useItemParam->m_user->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
		//}
		//else if(datatype == DT_Attack && m_useItemParam->m_target.valid())
		//{//普通攻击，目标做格挡躲避等判断
		//	crData *targetData = m_useItemParam->m_target->getDataClass();
		//	if(targetData)
		//	{
		//		m_useItemParam->m_target->doEvent(WCH_DodgeTest);
		//		targetData->getParam(WCHDATA_IsDodge,param);
		//		bool isDodge = *(bool *)param;
		//		if(!isDodge)
		//			m_useItemParam->m_target->doEvent(WCH_ParryTest);
		//	}
		//}
		//server要记录本次攻击
		thisData->getParam(WCHDATA_Duration,param);
		float duration = *(float *)param;
		ref_ptr<crUseItemRecord> userItemRecord = new crUseItemRecord;
		userItemRecord->setItem(m_this);
		userItemRecord->setUser(m_useItemParam->m_user.get());
		thisData->getParam(WCHDATA_DamageCount,param);
		unsigned char damagecount = *(unsigned char *)param;
		if(damagecount==1)
			userItemRecord->setTarget(m_useItemParam->m_target.get());//需要判断该技能是群攻还是单体攻击，如果是群攻则m_target＝NULL
		userItemRecord->setDamageCount(damagecount);
		userItemRecord->setDuration(duration);
		crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
		serverData->excHandle(MAKEINT64(WCH_LockData,1));
		serverData->getParam(WCHDATA_UseItemRecordMap,param);
		UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
		useItemRecordMap->insert(std::make_pair(userItemRecord->getUser(),userItemRecord.get()));
		serverData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crCheckCurrentAttackWeaponMethod
//
/////////////////////////////////////////
crCheckCurrentAttackWeaponMethod::crCheckCurrentAttackWeaponMethod(){}
crCheckCurrentAttackWeaponMethod::crCheckCurrentAttackWeaponMethod(const crCheckCurrentAttackWeaponMethod& handle):
crMethod(handle)
{
}
void crCheckCurrentAttackWeaponMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crCheckCurrentAttackWeaponMethod::addParam(int i, const std::string& str)
{
}

void crCheckCurrentAttackWeaponMethod::operator()(crHandle &handle)
{
	{
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		if(bot)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->getParam(WCHDATA_AboutToUseItemID,param);
			int itemid = *(int *)param;
			if(itemid==0)
			{
				thisData->getParam(WCHDATA_CurrentAttackID,param);
				itemid = *((int*)param);
			}
			if(itemid!=0)
			{
				crItemChild *itemChild = m_this->findChildItem(itemid);
				if(itemChild && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					crGroup *group = dynamic_cast<crGroup *>(item->getNode());
					if(group)
					{
						crWeaponMatterObject *weapon = dynamic_cast<crWeaponMatterObject *>(group->getChild(0));
						if(weapon) bot->selectWeaponMatterObject(weapon);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crItemUseMethod
//
/////////////////////////////////////////
crItemUseMethod::crItemUseMethod(){}
crItemUseMethod::crItemUseMethod(const crItemUseMethod& handle):
crMethod(handle)
{
}
void crItemUseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_itemUseParam = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_itemUseParam = (ItemUseParam *)(LOINT64(param64));
		}
		else
		{
			m_itemUseParam = NULL;
		}
		break;
	}
}

void crItemUseMethod::addParam(int i, const std::string& str)
{
}

void crItemUseMethod::operator()(crHandle &handle)
{
	if(m_itemUseParam.valid() && m_itemUseParam->m_weapon.valid())
	{
		double time = crFrameStamp::getInstance()->getReferenceTime();
		crWeaponMatterObject *weapon = dynamic_cast<crWeaponMatterObject *>(m_itemUseParam->m_weapon->getChild(0));
		if(weapon)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_Item,param);
			if(param)
			{
				ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
				if(item.valid())
				{
					weapon->doEvent(WCH_AdjustBulletSpeed,MAKEINT64(item.get(),NULL));
				}
			}
			m_this->selectWeaponMatterObject(weapon);//doEvent WCH_WEAPON_SELECT
			//CRCore::notify(CRCore::ALWAYS)<<"crItemUseMethod "<<std::endl;
			if(weapon->getBulletObject()->getAttrMask() & crBulletObject::Track)
			{
				crNode* targetNode = m_itemUseParam->m_targetNode.get();
				weapon->fire(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),targetNode,time);
				//char gbuf[256];
				//sprintf(gbuf,"ItemUse Weapon:%d,targetNode:%d\n\0",m_itemUseParam->m_weapon->getChild(0),m_itemUseParam->m_targetNode.get());
				//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
			}
			else if(weapon->getBulletObject()->getAttrMask() & crBulletObject::GravityEnable)
			{
				//crNode* targetNode = m_itemUseParam->m_targetNode.get();
				weapon->fire_noTarget(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),crVector3(0.0f,0.0f,0.0f),time);
				//m_itemUseParam->m_targetPos[2] = weapon->getGunPoint()[2];
				//weapon->fire(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),m_itemUseParam->m_targetPos,time);
			}
			else
			{
				crBulletObject::ExecutionPhysicsType pt = weapon->getBulletObject()->getExecutionPhysicsType();
				//if( pt == crBulletObject::Type_Collide ||
				//	pt == crBulletObject::Type_Explode ||
				//	pt == crBulletObject::Type_TimeExplode )
				//{//方向性攻击
				//	weapon->fire_noTarget(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),m_itemUseParam->m_dirOffset,time);
				//}
				//crNode* targetNode = m_itemUseParam->m_targetNode.get();
				//if(targetNode)
				//	m_itemUseParam->m_targetPos = targetNode->getBound().center();
				if(pt == crBulletObject::Type_Volume)
				{
					m_itemUseParam->m_targetPos[2] = weapon->getGunPoint()[2];
					weapon->fire(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),m_itemUseParam->m_targetPos,time);
				}
				else
				{//目标性攻击
					//crVector3 trackTarget;
					//if(dynamic_cast<crMatterObject *>(targetNode))
					//	trackTarget = dynamic_cast<crMatterObject *>(targetNode)->getPhysicsCenter();
					//else
					//	trackTarget = targetNode->getBound().center();
					weapon->fire(dynamic_cast<crMatterGroup *>(m_this->getParent(0)),m_itemUseParam->m_targetPos,time);
				}
			}
		}
		//m_itemUseParam->clear();
		//m_itemUseParam = NULL;
	}
	//if(m_itemUseParam)
	//{
	//	delete m_itemUseParam;
	//	m_itemUseParam = NULL;
	//}
}
/////////////////////////////////////////
//
//crBindWeaponMatrixMethod
//
/////////////////////////////////////////
crBindWeaponMatrixMethod::crBindWeaponMatrixMethod():
m_rotAngle(0.0f)
{
	m_scale.set(1.0f,1.0f,1.0f);
}
crBindWeaponMatrixMethod::crBindWeaponMatrixMethod(const crBindWeaponMatrixMethod& handle):
crMethod(handle),
m_offset(handle.m_offset),
m_scale(handle.m_scale),
m_rotAngle(handle.m_rotAngle),
m_boneName(handle.m_boneName),
m_dir(handle.m_dir)
{
}
void crBindWeaponMatrixMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_bot = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crWeaponMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_bot = (CRPhysics::crViewMatterObject *)(LOINT64(param64));
		}
		else
		{
			m_bot = NULL;
		}
		break;
	}
}

void crBindWeaponMatrixMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_offset);
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_scale);
		break;
	case 2:
		m_rotAngle = CRCore::DegreesToRadians(atof(str.c_str()));
		break;
	case 3:
		m_boneName = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_dir);
		break;
	}
}

void crBindWeaponMatrixMethod::operator()(crHandle &handle)
{
	if(m_bot.valid())
	{
		crData *data = m_this->getDataClass();
		crHandle *drive = data->getHandle(WCH_UPDATEVISITOR);
		if(drive)
		{
			crHandle *method = drive->getHandle("AttachNodeUpdate");
			if(method)
			{
				method->inputParam(3,(m_bot->getCurrentActiveBody()));
				method->inputParam(4,&m_offset);
				method->inputParam(5,&m_scale);
				method->inputParam(6,&m_rotAngle);
				method->inputParam(7,&m_boneName);
				method->inputParam(8,&m_dir);
			}
		}
		m_this->doEvent(WCH_UPDATEVISITOR);
	}
}
/////////////////////////////////////////
//
//crUnBindWeaponMatrixMethod
//
/////////////////////////////////////////
crUnBindWeaponMatrixMethod::crUnBindWeaponMatrixMethod()
{
}
crUnBindWeaponMatrixMethod::crUnBindWeaponMatrixMethod(const crUnBindWeaponMatrixMethod& handle):
crMethod(handle)
{
}
void crUnBindWeaponMatrixMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crWeaponMatterObject*)param;
		break;
	}
}

void crUnBindWeaponMatrixMethod::addParam(int i, const std::string& str)
{
}

void crUnBindWeaponMatrixMethod::operator()(crHandle &handle)
{
	{
		crData *data = m_this->getDataClass();
		crHandle *drive = data->getHandle(WCH_UPDATEVISITOR);
		if(drive)
		{
			crHandle *method = drive->getHandle("AttachNodeUpdate");
			if(method)
			{
				method->inputParam(3,NULL);
			}
		}
	}
}
/////////////////////////////////////////
//
//crShowAimUIMethod
//
/////////////////////////////////////////
crShowAimUIMethod::crShowAimUIMethod():
m_show(true),
m_aimui("ui_aim")
{
}
crShowAimUIMethod::crShowAimUIMethod(const crShowAimUIMethod& handle):
crMethod(handle),
m_show(handle.m_show),
m_aimui(handle.m_aimui)
{
}
void crShowAimUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_weapon = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_weapon = (CRPhysics::crWeaponMatterObject *)(LOINT64(param64));
		}
		else
		{
			m_weapon = NULL;
		}
		break;
	}
}

void crShowAimUIMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_show = (bool)(atoi(str.c_str()));
		break;
	case 1:
		m_aimui = str;
		break;
	}
}

void crShowAimUIMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	if(role && m_this == (CRPhysics::crViewMatterObject*)(role->getRelNode()) && m_weapon.valid())
	{
		void *param;
		crData *data = m_weapon->getDataClass();
		data->getParam(WCHDATA_Item,param);
		crInstanceItem *item = (crInstanceItem*)param;
		if(item && item->getDataClass())
		{
			crData *itemData = item->getDataClass();
			itemData->getParam(WCHDATA_AimID,param);
			short aimid = *(short *)(param);
			ref_ptr<crCanvasNode>aim = crFilterRenderManager::getInstance()->findCanvas(m_aimui);
			if(aim.valid())
			{
				ref_ptr<crMultiSwitch>aimsw = dynamic_cast<crMultiSwitch *>(dynamic_cast<crGroup *>(aim->getChild(0))->getChild(0));
				aimsw->setActiveSwitchSet(aimid);
				crFilterRenderManager::getInstance()->showCanvas(aim.get(),m_show);
			}
		}
	}
}
/////////////////////////////////////////
//
//crBotCollideMethod
//
/////////////////////////////////////////
crBotCollideMethod::crBotCollideMethod():
m_hurtActTime(0.5){}
crBotCollideMethod::crBotCollideMethod(const crBotCollideMethod& handle):
crMethod(handle)
{
}
void crBotCollideMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_collideNode = NULL;
			m_contactInfo = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_collideNode = (crNode *)(LOINT64(param64));
			m_contactInfo = (dContact *)(HIINT64(param64));
		}
		else
		{
			m_collideNode = NULL;
			m_contactInfo = NULL;
		}
		break;
	}
}
void crBotCollideMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_hurtActTime = atof(str.c_str());
		break;
	}
}
void crBotCollideMethod::operator()(crHandle &handle)
{
//	CRCore::notify(CRCore::ALWAYS)<<"crBotCollideMethod"<<std::endl;
	if(m_this && m_this->getDataClass() && m_collideNode && m_contactInfo)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Item,param);
		crInstanceItem *hititem = ((crInstanceItem*)param);
		if(hititem)
		{
			if(dynamic_cast<crBulletMatterObject *>(m_collideNode))
			{
				crBulletMatterObject *bullet = dynamic_cast<crBulletMatterObject *>(m_collideNode);
				if(bullet->getDataClass() && bullet->validExecution(m_this,m_contactInfo->geom.g2))
				{
					const crViewMatterObject *fireBot = bullet->getFireWeapon()->getFireBody();
					if(fireBot && fireBot->getDataClass())
					{
						crData *fireData = const_cast<crData *>(fireBot->getDataClass());
						fireData->getParam(WCHDATA_Item,param);
						crInstanceItem *fireItem = ((crInstanceItem*)param);
						if(!fireItem/* || hititem == fireItem*/)
						{//击中自己
							return;
						}
						//队友伤害校验
						//格挡和闪避动作判断
						//hititem->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Hurt,&m_hurtActTime));
						crData *bulletData = bullet->getDataClass();
						bulletData->getParam(WCHDATA_Item,param);
						crInstanceItem *bulletItem = ((crInstanceItem*)param);
						if(!bulletItem)
						{
							//char gbuf[256];
							//sprintf(gbuf,"crBotCollideMethod No bulletItem\n\0");
							//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
							return;
						}
						hititem->doEvent(WCH_BULLET_COLLIDE,MAKEINT64(bulletItem,NULL));

						bool sendevent = false;
						if(crMyPlayerData::getInstance()->ifItemIsMe(hititem))
						{
							if(fireItem->getItemtype()==crInstanceItem::Role)
								sendevent = true;
							else
							{
								crData *bulletitemData = bulletItem->getDataClass();
								bulletitemData->getParam(WCHDATA_DataType,param);
								unsigned char datatype = *(unsigned char*) param;
								if(datatype != DT_Attack)
									sendevent = true;
							}
						}
						else if(crMyPlayerData::getInstance()->ifItemIsMe(fireItem))
							sendevent = true;
						//else if(hititem->getItemtype() != crInstanceItem::Role)
						//{
						//	if(crMyPlayerData::getInstance()->ifItemIsMe(fireItem))
						//		sendevent = true;
						//}
						if(sendevent)
						{//通知服务器，被击中
							//char gbuf[256];
							//sprintf(gbuf,"BotCollide Weapon:%d,targetNode:%d\n\0",bullet->getFireWeapon(),bullet->getTrackTarget());
							//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);

							int fireid = fireItem->getID();
							int bulletItemID = bulletItem->getInstanceItemID();

							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(17);
							//stream->_writeUChar(hititem->getItemtype());
							//stream->_writeInt(hitid);
							stream->_writeUChar(fireItem->getItemtype());
							stream->_writeInt(fireid);
							if(fireItem->getItemtype() == crInstanceItem::Role)
								stream->_writeInt(fireItem->getRoleID());
							stream->_writeInt(bulletItemID);
							float rate = 1.0f;
							if(bullet->isExploding())
							{//计算bot受到爆炸伤害的影响
								//crVector3 contactPos(m_contactInfo->geom.pos[0],m_contactInfo->geom.pos[1],m_contactInfo->geom.pos[2]);
								rate = bullet->getExecutionRate(m_this->getTrans());
							}
							stream->_writeFloat(rate);
							crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
							if(netConductor)
							{
								//if(bulletItem->getAbstractItemID() == 28255)
								//	CRCore::notify(CRCore::ALWAYS)<<"crBotCollideMethod roleid="<<hititem->getRoleID()<<std::endl;
								crPlayerServerEventPacket packet;
								crPlayerServerEventPacket::buildRequestPacket(packet,WCH_NodeCollideWithItem,hititem,stream.get());
								netConductor->getNetManager()->sendPacket("all",packet);
							}
							//CRCore::notify(CRCore::ALWAYS)<<"crBotCollideMethod "<<hititem->getID()<<std::endl;
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crNodeCollideWithItemMethod
//
/////////////////////////////////////////
crNodeCollideWithItemMethod::crNodeCollideWithItemMethod(){}
crNodeCollideWithItemMethod::crNodeCollideWithItemMethod(const crNodeCollideWithItemMethod& handle):
crMethod(handle)
{
}
void crNodeCollideWithItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			//m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crNodeCollideWithItemMethod::addParam(int i, const std::string& str)
{
}
void crNodeCollideWithItemMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		void *param;
		ref_ptr<crData> thisData = m_this->getDataClass();
		if (!thisData.valid())
			return;
		thisData->getParam(WCHDATA_RTHP,param);
		float* rthp = (float *)param;
		if(!rthp || *rthp <= 0) return;
		thisData->getParam(WCHDATA_ItemState, param);
		unsigned char itemstate = *(unsigned char *)param;
		if (itemstate == IS_Dead || itemstate == IS_Relive)
			return;

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();

		unsigned char fireType = m_stream->_readUChar();
		int fireID = m_stream->_readInt();
		int fireroleid = 0;
		if(fireType == crInstanceItem::Role)
			fireroleid = m_stream->_readInt();
		int bulletItemID = m_stream->_readInt();
		float rate = m_stream->_readFloat();
		rate = CRCore::clampTo(rate,0.0f,1.0f);
		crInstanceItem *bulletitem = NULL;
		crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
		HitTestMap hitTestMap;
		if(fireType == crInstanceItem::Role)
		{
			ref_ptr<crRole> fireRole;
			if(fireID>0)
			{
				ref_ptr<crSceneServerPlayerData> netPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(fireID));
				if(netPlayerData.valid() && netPlayerData->getRoomID() == m_this->getRoomID())
				{
					fireRole = netPlayerData->getRole(fireroleid);
				}
			}
			else
			{
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				crScene *scene = netCallback->findScene(m_this->getSceneID());
				fireRole = dynamic_cast<crRole *>(scene->findSceneItem(fireID,m_this->getRoomID()));
			}
			if(fireRole.valid() && fireRole->getDataClass())
			{
				//bool hitValid = false;
				//bool fireSight = false;
				//bool hitSight = false;
				//攻击有效性判定
				//如果受击者不在攻击者视野范围内并且攻击者也不在收击者视野范围内则无效
				////crVector3 mypos = role->getPosition();
				////crVector3 hitpos = m_this->getPosition();
				////float dist = (hitpos - mypos).length();
				////float attackdist = role->getAttackDistance(m_this);
				////if(dist<attackdist+5.0f)
				////{
				////	hitValid = true;
				////}
				////受击者不在攻击者视野范围判定
				//crSightInfo *sightInfo = fireRole->getSightInfo();
				//if(sightInfo)
				//{
				//	int hitid = m_this->getID();
				//	crRole *hitRole = dynamic_cast<crRole *>(m_this);
				//	if(hitRole)
				//	{
				//		if(hitRole->getPlayerID() == fireID)
				//		{
				//			hitValid = true;
				//		}
				//		else if(hitid>0)
				//		{
				//			fireSight = sightInfo->isRoleInSight(hitRole)||sightInfo->isEyeRole(hitid);
				//		}
				//		else
				//		{
				//			fireSight = sightInfo->isItemInSight(hitRole)||sightInfo->isEyeItem(hitid);
				//		}
				//	}
				//	else
				//	{
				//		fireSight = sightInfo->isItemInSight(m_this)||sightInfo->isEyeItem(hitid);
				//	}
				//}
				////攻击者不在受击者视野范围判定
				//if(!hitValid)
				//{
				//	sightInfo = m_this->getSightInfo();
				//	if(sightInfo)
				//	{
				//		if(fireID>0)
				//		{
				//			hitSight = sightInfo->isRoleInSight(fireRole.get())||sightInfo->isEyeRole(fireID);
				//		}
				//		else
				//		{
				//			hitSight = sightInfo->isItemInSight(fireRole.get())||sightInfo->isEyeItem(fireID);
				//		}
				//	}
				//	hitValid = fireSight||hitSight;
				//}
				//if(hitValid)
				{
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_UseItemRecordMap,param);
					UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
					//crInstanceItem *target;
					for( UseItemRecordMap::iterator itr = useItemRecordMap->find(fireRole.get());
						itr != useItemRecordMap->end() && itr->first == fireRole.get();
						++itr )
					{
						if(itr->second->getItem()->getInstanceItemID() == bulletItemID)
						{
							//target = itr->second->getTarget();
							//if(!target || target == m_this)
							if(itr->second->getHitValid(m_this))
							{
								//HitMap &hitMap = itr->second->getHitMap();//击中者记录，防止重复击中
								//if(hitMap.find(m_this)==hitMap.end())
								hitTestMap.insert(std::make_pair(itr->second->duration(),itr->second.get()));
							}
						}
					}
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
					if(!hitTestMap.empty())
					{
						crUseItemRecord *record = hitTestMap.begin()->second.get();
						if(record)
						{
							HitMap &hitMap = record->getHitMap();
							hitMap[m_this] = rate;
							bulletitem = record->getItem();
							CRCore::ref_ptr<HitParam> hitParam = new HitParam;
							hitParam->m_hitItem = m_this;
							hitParam->m_rate = rate;
							hitParam->m_fireItem = fireRole.get();
							//if(bulletitem->getAbstractItemID() == 28255)
							//	CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod roleid="<<m_this->getRoleID()<<std::endl;
							bulletitem->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));

							crData *bulletitemData = bulletitem->getDataClass();
							if(bulletitemData)
							{
								bulletitemData->getParam(WCHDATA_DataType,param);
								unsigned char datatype = *(unsigned char*) param;
								if(datatype == DT_Attack)
								{//普通攻击，做暴击判断
									fireRole->doEvent(WCH_MissCritTest);
									m_this->doEvent(WCH_DodgeParryTest);
								}
							}
						}
					}
					//else
					//{
					//	CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod hitTestMap Empty "<<m_this->getID()<<std::endl;
					//}
					//crItemChild *itemChild = role->findChildItem(bulletItemID);
					//if(!itemChild)
					//{
					//	itemChild = role->findRemovedItemChild(bulletItemID);
					//}
					//if(itemChild)
					//{//DT_AttackThing最后一枚炮弹再射击后就被移除，会导致其击中无效
					//	bulletitem = itemChild->getInstanceItem();
					//	hitParam->m_fireItem = role;
					//	bulletitem->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));
					//}
				}
				//else
				//{
				//	CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod 目标不再视野内"<<std::endl;
				//}
			}
		}
		else
		{//firer is npc
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			crScene *scene = netCallback->findScene(m_this->getSceneID());
			if(scene)
			{
				crInstanceItem *fireitem = scene->findSceneItem(fireID,m_this->getRoomID());
				if(fireitem && fireitem->getDataClass())
				{
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_UseItemRecordMap,param);
					UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
					//crInstanceItem *target;
					for( UseItemRecordMap::iterator itr = useItemRecordMap->find(fireitem);
						itr != useItemRecordMap->end() && itr->first == fireitem;
						++itr )
					{
						if(itr->second->getItem()->getInstanceItemID() == bulletItemID)
						{
							//target = itr->second->getTarget();
							//if(!target || target == m_this)
							if(itr->second->getHitValid(m_this))
							{
								//HitMap &hitMap = itr->second->getHitMap();//击中者记录，防止重复击中
								//if(hitMap.find(m_this)==hitMap.end())
								hitTestMap.insert(std::make_pair(itr->second->duration(),itr->second.get()));
							}
						}
					}
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
					if(!hitTestMap.empty())
					{
						crUseItemRecord *record = hitTestMap.begin()->second.get();
						if(record)
						{
							HitMap &hitMap = record->getHitMap();
							hitMap[m_this] = rate;
							bulletitem = record->getItem();
							CRCore::ref_ptr<HitParam> hitParam = new HitParam;
							hitParam->m_hitItem = m_this;
							hitParam->m_rate = rate;
							hitParam->m_fireItem = fireitem;
							//CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod "<<m_this->getID()<<std::endl;
							bulletitem->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));
							
							crData *bulletitemData = bulletitem->getDataClass();
							if(bulletitemData)
							{
								bulletitemData->getParam(WCHDATA_DataType,param);
								unsigned char datatype = *(unsigned char*) param;
								if(datatype == DT_Attack)
								{//普通攻击，做暴击判断
									fireitem->doEvent(WCH_MissCritTest);
									m_this->doEvent(WCH_DodgeParryTest);
								}
							}
						}
					}
					else
					{
						//CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod hitTestMap Empty "<<m_this->getID()<<std::endl;
					}
				}
			}
			//crItemChild *itemChild = fireitem->findChildItem(bulletItemID);
			//if(!itemChild)
			//{
			//	itemChild = fireitem->findRemovedItemChild(bulletItemID);
			//}
			//if(itemChild)
			//{
			//	bulletitem = itemChild->getInstanceItem();
			//	hitParam->m_fireItem = fireitem;
			//	bulletitem->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));
			//}
		}
	}
}
/////////////////////////////////////////
//
//crDamageCollideFormula1Method
//
/////////////////////////////////////////
crDamageCollideFormula1Method::crDamageCollideFormula1Method():
m_dmtype(0),
m_lvfactor(0){}
crDamageCollideFormula1Method::crDamageCollideFormula1Method(const crDamageCollideFormula1Method& handle):
crMethod(handle),
m_dmtype(handle.m_dmtype),
m_lvfactor(handle.m_lvfactor)
{
}
void crDamageCollideFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crDamageCollideFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
        m_dmtype = unsigned char(atoi(str.c_str()));
		break;
	case 1:
		m_lvfactor = atof(str.c_str());
		break;
	}
}
void crDamageCollideFormula1Method::operator()(crHandle &handle)
{
	if(m_hitParam.valid())
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SkillLevel,param);
		unsigned char skilllevel = *((unsigned char*)param);
		
		data->getParam(WCHDATA_PhysicsDM,param);
		crVector2s physicsdm;
		if(param) physicsdm = *((crVector2s*)param);

		data->getParam(WCHDATA_MagicDM,param);
		crVector2s magicdm;
		if(param) magicdm = *((crVector2s*)param);
 
		CRCore::rangef pdmbase1(physicsdm[0],physicsdm[1]);
		CRCore::rangef mdmbase2(magicdm[0],magicdm[1]);
		float dmbase = pdmbase1.get_random();
		dmbase += mdmbase2.get_random();
        dmbase += (float)skilllevel * m_lvfactor;

		float fireDamage = 0;
		if(m_hitParam->m_fireItem.valid())
		{
		    m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetDamage,m_dmtype),MAKEINT64(&fireDamage,NULL));
		}
        
		float hitDefend = 0;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetDefend,m_dmtype),MAKEINT64(&hitDefend,NULL));

        float damage = dmbase + fireDamage - hitDefend;
		//if(damage>0.0f) damage = 0.0f;
		damage *= m_hitParam->m_rate;
		damage = CRCore::maximum(damage,1.0f);

		m_hitParam->m_hitItem->doEvent(WCH_AddDamage,MAKEINT64(&damage,m_hitParam->m_fireItem.get()));
	}
}
/////////////////////////////////////////
//
//crGetDamageFormula1Method
//
/////////////////////////////////////////
crGetDamageFormula1Method::crGetDamageFormula1Method():
m_output(NULL){}
crGetDamageFormula1Method::crGetDamageFormula1Method(const crGetDamageFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
//m_dice(handle.m_dice),
m_output(NULL)
{
}
void crGetDamageFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetDamageFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	//case 1:
	//	crArgumentParser::appAtoVec(str,m_dice);
	//	break;
	}
}
void crGetDamageFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Attack,param);
		int base = *((int*)param);
		data->getParam(WCHDATA_Strength,param);
		short strength = *((short*)param);
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *((unsigned char*)param);

		data->getParam(WCHDATA_ExtraAttack,param);
		short extraAttack = *((short*)param);
		data->getParam(WCHDATA_ExtraStrength,param);
		short extraStrength = *((short*)param);
		data->getParam(WCHDATA_ExtraLevel,param);
		char extraLevel = *((char*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipAttackSum = 0;
		float equipStrengthSum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			 itr != equipOnMap->end();
			 ++itr )
		{
            itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipAttack,MAKEINT64(m_this,&equip));
				equipAttackSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipStrength,MAKEINT64(m_this,&equip));
				equipStrengthSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
        data->excHandle(MAKEINT64(WCH_LockData,0));

		float fbase = (float)(base+extraAttack) + equipAttackSum;
		float fstrength = (float)(strength+extraStrength) + equipStrengthSum;
		float flv = (float)lv+(float)extraLevel + equipLvSum;

		*m_output = fbase + fstrength*m_factor[0]*(m_factor[1]*flv+m_factor[2]);
		//*m_output *= crGameDices::getInstance()->dicef(m_dice[0],m_dice[1]);
	}
}
/////////////////////////////////////////
//
//crGetDamageFormula2Method
//
/////////////////////////////////////////
crGetDamageFormula2Method::crGetDamageFormula2Method():
m_formulaid(1),
m_output(NULL){}
crGetDamageFormula2Method::crGetDamageFormula2Method(const crGetDamageFormula2Method& handle):
crMethod(handle),
m_formulaid(handle.m_formulaid),
m_output(NULL)
{
}
void crGetDamageFormula2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetDamageFormula2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_formulaid = atoi(str.c_str());
		break;
	}
}
void crGetDamageFormula2Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip;
		float equipSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				equip = 0;
				itemChild->getInstanceItem()->doEvent(MAKEINT64(WCH_GetEquipMagicDamage,m_formulaid),MAKEINT64(m_this,&equip));
				equipSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = equipSum;
	}
}
/////////////////////////////////////////
//
//crGetDefendFormula1Method
//
/////////////////////////////////////////
crGetDefendFormula1Method::crGetDefendFormula1Method():
m_output(NULL){}
crGetDefendFormula1Method::crGetDefendFormula1Method(const crGetDefendFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetDefendFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetDefendFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crGetDefendFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Defend,param);
		int base = *((int*)param);
		data->getParam(WCHDATA_Agility,param);
		short agility = *((short*)param);
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *((unsigned char*)param);

		data->getParam(WCHDATA_ExtraDefend,param);
		short extraDefend = *((short*)param);
		data->getParam(WCHDATA_ExtraAgility,param);
		short extraAgility = *((short*)param);
		data->getParam(WCHDATA_ExtraLevel,param);
		char extraLevel = *((char*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipDefendSum = 0;
		float equipAgilitySum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipDefend,MAKEINT64(m_this,&equip));
				equipDefendSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipAgility,MAKEINT64(m_this,&equip));
				equipAgilitySum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		float fbase = (float)(base+extraDefend) + equipDefendSum;
		float fagility = (float)(agility+extraAgility) + equipAgilitySum;
		float flv = (float)lv+(float)extraLevel + equipLvSum;

		*m_output = fbase + fagility*m_factor[0]*(m_factor[1]*flv+m_factor[2]);
	}
}
/////////////////////////////////////////
//
//crGetDefendFormula2Method
//
/////////////////////////////////////////
crGetDefendFormula2Method::crGetDefendFormula2Method():
m_formulaid(1),
m_output(NULL){}
crGetDefendFormula2Method::crGetDefendFormula2Method(const crGetDefendFormula2Method& handle):
crMethod(handle),
m_formulaid(handle.m_formulaid),
m_output(NULL)
{
}
void crGetDefendFormula2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetDefendFormula2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_formulaid = atoi(str.c_str());
		break;
	}
}
void crGetDefendFormula2Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip;
		float equipSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				equip = 0;
				itemChild->getInstanceItem()->doEvent(MAKEINT64(WCH_GetEquipMagicDefend,m_formulaid),MAKEINT64(m_this,&equip));
				equipSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = equipSum;
	}
}
/////////////////////////////////////////
//
//crGetSpeedFormula1Method
//
/////////////////////////////////////////
crGetSpeedFormula1Method::crGetSpeedFormula1Method():
m_factor(0.1f),
m_output(NULL){}
crGetSpeedFormula1Method::crGetSpeedFormula1Method(const crGetSpeedFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetSpeedFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetSpeedFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_factor = atof(str.c_str());
		break;
	}
}
void crGetSpeedFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Speed,param);
		short base = *((short*)param);
		data->getParam(WCHDATA_Agility,param);
		short agility = *((short*)param);

		//data->getParam(WCHDATA_ExtraSpeed,param);
		//short extraSpeed = *((short*)param);
		data->getParam(WCHDATA_ExtraAgility,param);
		short extraAgility = *((short*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipSpeedSum = 0;
		float equipAgilitySum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipSpeed,MAKEINT64(m_this,&equip));
				equipSpeedSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipAgility,MAKEINT64(m_this,&equip));
				equipAgilitySum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		float fbase = (float)(base) + equipSpeedSum;
		float fagility = (float)(agility+extraAgility) + equipAgilitySum;

		*m_output = fbase+fagility*m_factor;
	}
}
/////////////////////////////////////////
//
//crGetHPFormula1Method
//
/////////////////////////////////////////
crGetHPFormula1Method::crGetHPFormula1Method():
m_output(NULL){}
crGetHPFormula1Method::crGetHPFormula1Method(const crGetHPFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetHPFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetHPFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crGetHPFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_HP,param);
		int hp = *((int*)param);
		data->getParam(WCHDATA_Strength,param);
		short strength = *((short*)param);
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *((unsigned char*)param);

		data->getParam(WCHDATA_ExtraHP,param);
		short extrahp = *((short*)param);
		data->getParam(WCHDATA_ExtraStrength,param);
		short extraStrength = *((short*)param);
		data->getParam(WCHDATA_ExtraLevel,param);
		char extraLevel = *((char*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipHPSum = 0;
		float equipStrengthSum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipHP,MAKEINT64(m_this,&equip));
				equipHPSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipStrength,MAKEINT64(m_this,&equip));
				equipStrengthSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		float fhp = (float)(hp+extrahp) + equipHPSum;
		float fstrength = (float)(strength+extraStrength) + equipStrengthSum;
		float flv = (float)lv+(float)extraLevel + equipLvSum;

		*m_output = fhp + fstrength*m_factor[0]*(m_factor[1]*flv+m_factor[2]);
	}
}
/////////////////////////////////////////
//
//crGetMPFormula1Method
//
/////////////////////////////////////////
crGetMPFormula1Method::crGetMPFormula1Method():
m_output(NULL){}
crGetMPFormula1Method::crGetMPFormula1Method(const crGetMPFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetMPFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetMPFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crGetMPFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_MP,param);
		int mp = *((int*)param);
		data->getParam(WCHDATA_Intellect,param);
		short intellect = *((short*)param);
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *((unsigned char*)param);

		data->getParam(WCHDATA_ExtraMP,param);
		short extramp = *((short*)param);
		data->getParam(WCHDATA_ExtraIntellect,param);
		short extraIntellect = *((short*)param);
		data->getParam(WCHDATA_ExtraLevel,param);
		char extraLevel = *((char*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipMPSum = 0;
		float equipIntellectSum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipMP,MAKEINT64(m_this,&equip));
				equipMPSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipIntellect,MAKEINT64(m_this,&equip));
				equipIntellectSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		float fmp = (float)(mp+extramp) + equipMPSum;
		float fintellect = (float)(intellect+extraIntellect) + equipIntellectSum;
		float flv = (float)lv+(float)extraLevel + equipLvSum;

		*m_output = fmp + fintellect*m_factor[0]*(m_factor[1]*flv+m_factor[2]);
	}
}
/////////////////////////////////////////
//
//crGetHPRevertFormula1Method
//
/////////////////////////////////////////
crGetHPRevertFormula1Method::crGetHPRevertFormula1Method():
m_factor(0.1f),
m_output(NULL){}
crGetHPRevertFormula1Method::crGetHPRevertFormula1Method(const crGetHPRevertFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetHPRevertFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetHPRevertFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_factor = atof(str.c_str());
		break;
	}
}
void crGetHPRevertFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_RTHP,param);
		float base = *((float*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip;
		float equipSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				equip = 0;
				itemChild->getInstanceItem()->doEvent(WCH_GetEquipHPRevert,MAKEINT64(m_this,&equip));
				equipSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = base*m_factor + equipSum;
	}
}
/////////////////////////////////////////
//
//crGetMPRevertFormula1Method
//
/////////////////////////////////////////
crGetMPRevertFormula1Method::crGetMPRevertFormula1Method():
m_factor(0.1f),
m_output(NULL){}
crGetMPRevertFormula1Method::crGetMPRevertFormula1Method(const crGetMPRevertFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetMPRevertFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetMPRevertFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_factor = atof(str.c_str());
		break;
	}
}
void crGetMPRevertFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_RTMP,param);
		float base = *((float*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip;
		float equipSum = 0;
		EquipOnMap* equipOnVec = (EquipOnMap*)param;
		for( EquipOnMap::iterator itr = equipOnVec->begin();
			itr != equipOnVec->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				equip = 0;
				itemChild->getInstanceItem()->doEvent(WCH_GetEquipMPRevert,MAKEINT64(m_this,&equip));
				equipSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = base*m_factor + equipSum;
	}
}
/////////////////////////////////////////
//
//crAttackSpeedFormula1Method
//
/////////////////////////////////////////
crAttackSpeedFormula1Method::crAttackSpeedFormula1Method():
m_output(NULL){}
crAttackSpeedFormula1Method::crAttackSpeedFormula1Method(const crAttackSpeedFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crAttackSpeedFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crAttackSpeedFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crAttackSpeedFormula1Method::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_AttackSpeed,param);
		short attackSpeed = *((short*)param);
		data->getParam(WCHDATA_Agility,param);
		short agility = *((short*)param);
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *((unsigned char*)param);

		data->getParam(WCHDATA_ExtraAttackSpeed,param);
		float extraAttackSpeed = *((float*)param);
		data->getParam(WCHDATA_ExtraAgility,param);
		short extraAgility = *((short*)param);
		data->getParam(WCHDATA_ExtraLevel,param);
		char extraLevel = *((char*)param);

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipAttackSpeedSum = 0;
		float equipAgilitySum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipAttackSpeed,MAKEINT64(m_this,&equip));
				equipAttackSpeedSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipAgility,MAKEINT64(m_this,&equip));
				equipAgilitySum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		float fattackSpeed = attackSpeed+extraAttackSpeed + equipAttackSpeedSum;
		float fagility = (float)(agility+extraAgility) + equipAgilitySum;
		float flv = (float)lv+(float)extraLevel + equipLvSum;

		*m_output = fattackSpeed - fagility*m_factor[0]*(m_factor[1]*flv+m_factor[2]);
		if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crAddDamageFormula1Method
//
/////////////////////////////////////////
crAddDamageFormula1Method::crAddDamageFormula1Method():
m_damage(0.0f){}
crAddDamageFormula1Method::crAddDamageFormula1Method(const crAddDamageFormula1Method& handle):
crMethod(handle),
m_damage(0.0f)
{
}
void crAddDamageFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_damage = 0;
			m_fireItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_damage = *(float *)(LOINT64(param64));
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_damage = 0;
			m_fireItem = NULL;
		}
		break;
	}
}
void crAddDamageFormula1Method::addParam(int i, const std::string& str)
{
}
void crAddDamageFormula1Method::operator()(crHandle &handle)
{
	{
		crData *thisData = m_this->getDataClass();
		void *param;
        thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_RTHP,param);
		float *rthp = (float*)param;
		if(!rthp)
		{
		    thisData->excHandle(MAKEINT64(WCH_LockData,0));
	    	return;
		}
		*rthp -= m_damage;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//将信息传给m_this以及其附近玩家
		unsigned char hittype = m_this->getItemtype();
		int hitid = m_this->getID();

		unsigned char firetype = 0;
		int fireid = 0;
		if(m_fireItem.valid())
		{
			firetype = m_fireItem->getItemtype();
			fireid = m_fireItem->getID();
		}

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		ref_ptr<crStreamBuf> damageStream = new crStreamBuf;
		damageStream->createBuf(11);
		damageStream->_writeUChar(firetype);
		damageStream->_writeInt(fireid);
		damageStream->_writeShort((short)m_damage);
		damageStream->_writeFloat(*rthp);

		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket damagePacket;
			crPlayerEventPacket::buildRequestPacket(damagePacket,hitid,m_this,WCH_RecvDamage,damageStream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if(hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),damagePacket);
			}
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
			if(*rthp<=0)
			{
				ref_ptr<crStreamBuf> deadStream = new crStreamBuf;
				deadStream->createBuf(5);
				deadStream->_writeUChar(firetype);
				deadStream->_writeInt(fireid);

				crPlayerEventPacket deadPacket;
				crPlayerEventPacket::buildRequestPacket(deadPacket,hitid,m_this,WCH_RecvItemDead,deadStream.get());
				if(hitPlayerData.valid()) netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),deadPacket);
				scene->sendPacketToItemNeighbor(m_this,deadPacket);
			}
		}
		else
		{
			crItemEventPacket damagePacket;
			crItemEventPacket::buildRequestPacket(damagePacket,0,m_this,WCH_RecvDamage,damageStream.get());
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
			if(*rthp<=0)
			{
				ref_ptr<crStreamBuf> deadStream = new crStreamBuf;
				deadStream->createBuf(5);
				deadStream->_writeUChar(firetype);
				deadStream->_writeInt(fireid);

				crItemEventPacket deadPacket;
				crItemEventPacket::buildRequestPacket(deadPacket,0,m_this,WCH_RecvItemDead,deadStream.get());
				scene->sendPacketToItemNeighbor(m_this,deadPacket);
			}
		}

		if(*rthp<=0)
		{
			unsigned char itemstate = IS_Dead;
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			m_this->doEvent(WCH_ItemDead,MAKEINT64(m_fireItem.get(),NULL));
		}
	}
}

/////////////////////////////////////////
//
//crRecvDamageMethod
//
/////////////////////////////////////////
crRecvDamageMethod::crRecvDamageMethod(){}
crRecvDamageMethod::crRecvDamageMethod(const crRecvDamageMethod& handle):
crMethod(handle)
{
}
void crRecvDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvDamageMethod::addParam(int i, const std::string& str)
{
}

void crRecvDamageMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();

		unsigned char firetype = m_stream->_readUChar();
		int fireid = m_stream->_readInt();
		short damage = m_stream->_readShort();
		float rthp = m_stream->_readFloat();
		data->inputParam(WCHDATA_RTHP,&rthp);
		//客户端显示
		crNode *node = m_this->getRelNode();
		if(node)
		    node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvDamage,MAKEINT32(-damage,-1)));
	}
}
/////////////////////////////////////////
//
//crRecvItemDeadMethod
//
/////////////////////////////////////////
crRecvItemDeadMethod::crRecvItemDeadMethod(){}
crRecvItemDeadMethod::crRecvItemDeadMethod(const crRecvItemDeadMethod& handle):
crMethod(handle)
{
}
void crRecvItemDeadMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvItemDeadMethod::addParam(int i, const std::string& str)
{
}

void crRecvItemDeadMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		unsigned char killertype = m_stream->_readUChar();
		int killerid = m_stream->_readInt();

		crData *data = m_this->getDataClass();
		unsigned char itemstate = IS_Dead;
		data->inputParam(WCHDATA_ItemState,&itemstate);
		float rthp = -1;
		data->inputParam(WCHDATA_RTHP,&rthp);
		data->inputParam(WCHDATA_ControllerFlg,NULL);
		m_this->clearSyncPos();
		unsigned char targetType = Target_None;
		data->inputParam(WCHDATA_TargetType,&targetType);
		data->inputParam(WCHDATA_AboutToUseItemID,NULL);
		m_this->getOrCreatePathFinder()->dirty();
		m_this->clearExtra();
		if(m_this->getItemtype() == crInstanceItem::Npc)
		{
			void *param;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_InPatrolEnemyMap,param);
			InPatrolEnemyMap *inPatrolEnemyMap = (InPatrolEnemyMap *)param;
			if(inPatrolEnemyMap)
			{
				inPatrolEnemyMap->clear();
			}
			data->getParam(WCHDATA_EnmityMap,param);
			EnmityMap *enmityMap = (EnmityMap *)param;
			enmityMap->clear();
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		//if(m_this == crMyPlayerData::getInstance()->getRole())
		//{
		//	crMyPlayerData::getInstance()->removeAllInRanges();
		//}
	}
}
/////////////////////////////////////////
//
//crShowStateTextMethod
//
/////////////////////////////////////////
crShowStateTextMethod::crShowStateTextMethod():
m_msg(0),
m_value(0),
m_index(0),
m_riseSpeed(10.0f),
m_maxRange(50.0f),
m_characterSize(16.0f),
m_alignmentType(CRText::crText::CENTER_CENTER),
m_textRectSetted(false),
m_visiableTime(0),
m_font("simhei.ttf"){}
crShowStateTextMethod::crShowStateTextMethod(const crShowStateTextMethod& handle):
crNodeMethod(handle),
m_msg(handle.m_msg),
m_value(handle.m_value),
m_zRange(handle.m_zRange),
m_riseSpeed(handle.m_riseSpeed),
m_maxRange(handle.m_maxRange),
m_characterSize(handle.m_characterSize),
m_alignmentType(handle.m_alignmentType),
m_color(handle.m_color),
m_prestr(handle.m_prestr),
m_textRectSetted(handle.m_textRectSetted),
m_textRect(handle.m_textRect),
m_visiableTime(handle.m_visiableTime),
m_font(handle.m_font)
{
}
void crShowStateTextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_value = 0;
			m_index = 0;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			_crInt32 param32 = LOINT64(param64);
			m_value = LOINT32(param32);
			m_index = HIINT32(param32);
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(HIINT64(param64));
		}
		else
		{
			m_value = 0;
			m_index = 0;
			m_updateVisitor = NULL;
		}
		break;
	}
}

void crShowStateTextMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_msg = CREncapsulation::parseEventMsg(str);
		break;
	case 1:
        crArgumentParser::appAtoVec(str,m_zRange);
		break;
	case 2:
		m_riseSpeed = atof(str.c_str());
		break;
	case 3:
		m_maxRange = atof(str.c_str());
		break;
	case 4:
		m_characterSize = atof(str.c_str());
		break;
	case 5:
		if(str.compare("LEFT_TOP")==0)
			m_alignmentType = CRText::crText::LEFT_TOP;
		else if(str.compare("LEFT_CENTER")==0)
			m_alignmentType = CRText::crText::LEFT_CENTER;
		else if(str.compare("LEFT_BOTTOM")==0)
			m_alignmentType = CRText::crText::LEFT_BOTTOM;
		else if(str.compare("CENTER_TOP")==0)
			m_alignmentType = CRText::crText::CENTER_TOP;
		else if(str.compare("CENTER_CENTER")==0)
			m_alignmentType = CRText::crText::CENTER_CENTER;
		else if(str.compare("CENTER_BOTTOM")==0)
			m_alignmentType = CRText::crText::CENTER_BOTTOM;
		else if(str.compare("RIGHT_TOP")==0)
			m_alignmentType = CRText::crText::RIGHT_TOP;
		else if(str.compare("RIGHT_CENTER")==0)
			m_alignmentType = CRText::crText::RIGHT_CENTER;
		else if(str.compare("RIGHT_BOTTOM")==0)
			m_alignmentType = CRText::crText::RIGHT_BOTTOM;
		else if(str.compare("LEFT_BASE_LINE")==0)
			m_alignmentType = CRText::crText::LEFT_BASE_LINE;
		else if(str.compare("CENTER_BASE_LINE")==0)
		    m_alignmentType = CRText::crText::CENTER_BASE_LINE;
		else if(str.compare("RIGHT_BASE_LINE")==0)
			m_alignmentType = CRText::crText::RIGHT_BASE_LINE;
		else if(str.compare("BASE_LINE")==0)
			m_alignmentType = CRText::crText::BASE_LINE;
		break;
	case 6:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	case 7:
		m_font = str;
		break;
	case 8:
		m_prestr = str;
		break;
	case 9:
		m_visiableTime = atof(str.c_str());
		break;
	case 10:
		crArgumentParser::appAtoVec(str,m_textRect);
		m_textRectSetted = true;
		break;
	case 11:
		m_msg = parseEventMsg16(str);
		break;
	case 12:
		m_msg = MAKEINT32(LOINT32(m_msg),parseEventMsg16(str));
		break;
	}
}
void crShowStateTextMethod::operator()(crHandle &handle)
{
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(m_updateVisitor.valid() && bindview && bindview->isInited())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crShowDamageTextMethod"<<std::endl;
        CRText::crText *text;
		if(m_index < 0)
		{
			short index = m_index;
			TextPair textPair;
			bool found = false;
			for( int i = 0; i<m_textVec.size(); i++ )
			{
				if(!(m_textVec[i].first->getVisiable()))
				{
                    text = m_textVec[i].first.get();
					m_index = i;
					found = true;
					break;
				}
			}
			if(!found)
			{
				text = new CRText::crText;
				text->setName("StateText");
				text->setFont(m_font);
				text->setFontResolution((unsigned int)m_characterSize,(unsigned int)m_characterSize);
				text->setCharacterSize(m_characterSize);
				text->setAlignment((CRText::crText::AlignmentType)m_alignmentType);
				if(index == -1)
				{
					std::string str = m_prestr+crArgumentParser::appItoa(m_value);
					text->setText(CRIOManager::convertUTF8toUTF16(str.c_str()).c_str());
				}
				else if(index == -2)
				{
					text->setText(CRIOManager::convertUTF8toUTF16(m_prestr.c_str()).c_str());
				}
				crFilterRenderManager::getInstance()->addDrawable(text,true);
				m_index = m_textVec.size();
				m_textVec.push_back(TextPair(text,crVector2(m_zRange[0],m_visiableTime)));
			}
			else
			{
				text->setFontResolution((unsigned int)m_characterSize,(unsigned int)m_characterSize);
				text->setCharacterSize(m_characterSize);
				text->setAlignment((CRText::crText::AlignmentType)m_alignmentType);
				if(index == -1)
				{
					std::string str = m_prestr+crArgumentParser::appItoa(m_value);
					text->setText(CRIOManager::convertUTF8toUTF16(str.c_str()).c_str());
				}
				else if(index == -2)
				{
					text->setText(CRIOManager::convertUTF8toUTF16(m_prestr.c_str()).c_str());
				}
				m_textVec[m_index].second.set(m_zRange[0],m_visiableTime);
			}
			text->setColor(m_color);
			text->setBackdropColor(m_color);
			text->setBackdropType(CRText::crText::OUTLINE);
			if(m_textRectSetted)
			{
				crVector4 rect = m_textRect;
				crVector3 texPos(rect[0],rect[1],0.0f);
				texPos = texPos * crFilterRenderManager::getInstance()->getMVPW();
				crVector3 pos2(rect[2],rect[3],0.0f);
				pos2 = pos2 * crFilterRenderManager::getInstance()->getMVPW();
				text->setMaximumWidth(fabs(pos2[0] - texPos[0]));
				text->setMaximumHeight(fabs(pos2[1] - texPos[1]));
			}
		}
		else
		{
			text = m_textVec[m_index].first.get();
			m_textVec[m_index].second[0] += m_riseSpeed * crFrameStamp::getInstance()->getFrameInterval();
			if(m_visiableTime>0.0f) m_textVec[m_index].second[1] -= crFrameStamp::getInstance()->getFrameInterval();
		}

		if(m_textVec[m_index].second[0]>m_zRange[1] || (m_visiableTime>0.0f && m_textVec[m_index].second[1] < 0.0f))
		{
			text->setVisiable(false);
		}
		else
		{
			if(m_this->getVisiable())
			{
				//std::string str = m_prestr+crArgumentParser::appItoa(m_value);
				//text->setText(CRIOManager::convertUTF8toUTF16(str.c_str()).c_str());
				crVector3 texPos;
				if(m_textRectSetted)
				{
					crVector4 rect = m_textRect;
					texPos.set(rect[0],rect[1],0.0f);
					texPos[1] += m_textVec[m_index].second[0];
					texPos = texPos * crFilterRenderManager::getInstance()->getMVPW();
				}
				else
				{
					texPos = m_this->getTrans();
					texPos[2] += m_this->getPhysicsBox()[2] * 0.5f + m_textVec[m_index].second[0];
					if(crBrain::getInstance()->getCameraFrustum().contains(texPos))
					{
						crVector3 window;
						bindview->getDefaultSceneHandler()->getSceneView()->projectObjectIntoWindow(texPos,window);
						texPos = window;
					}
					else
					{
						text->setVisiable(false);
						return;
					}
				}
				//crVector3 cameraPos = crBrain::getInstance()->getCameraPosition();
				//float dist = (botPos-cameraPos).length();
				//if(dist<m_maxRange)
				//{
					texPos[2] = 0.0f;
					text->setPosition(texPos);
					text->setVisiable(true);

					m_this->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(m_msg,MAKEINT32(m_value,m_index)));
				//}
				//else
				//{
				//	m_text->setVisiable(false);
				//}
			}
			else
			{
                text->setVisiable(false);
			}
		}
	}
}
void crShowStateTextMethod::releaseObjects(crState* state)
{
	for( TextVec::iterator itr = m_textVec.begin();
		 itr != m_textVec.end();
		 ++itr )
	{
		//itr->first->setVisiable(false);
		//itr->first->releaseObjects(state);
		crFilterRenderManager::getInstance()->removeDrawable(itr->first.get());
	}
    m_textVec.clear();
}

/////////////////////////////////////////
//
//crShowHeadTextMethod
//
/////////////////////////////////////////
crShowHeadTextMethod::crShowHeadTextMethod():
m_maxRange(50.0f),
m_zoffset(0.0f),
m_characterSize(16.0f),
m_alignmentType(CRText::crText::CENTER_CENTER),
m_font("simhei.ttf"){}
crShowHeadTextMethod::crShowHeadTextMethod(const crShowHeadTextMethod& handle):
crNodeMethod(handle),
m_maxRange(handle.m_maxRange),
m_zoffset(handle.m_zoffset),
m_characterSize(handle.m_characterSize),
m_alignmentType(handle.m_alignmentType),
m_color(handle.m_color),
m_font(handle.m_font)
{
}
void crShowHeadTextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crShowHeadTextMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_maxRange = atof(str.c_str());
		break;
	case 1:
		m_zoffset = atof(str.c_str());
		break;
	case 2:
		m_characterSize = atof(str.c_str());
		break;
	case 3:
		if(str.compare("LEFT_TOP")==0)
			m_alignmentType = CRText::crText::LEFT_TOP;
		else if(str.compare("LEFT_CENTER")==0)
			m_alignmentType = CRText::crText::LEFT_CENTER;
		else if(str.compare("LEFT_BOTTOM")==0)
			m_alignmentType = CRText::crText::LEFT_BOTTOM;
		else if(str.compare("CENTER_TOP")==0)
			m_alignmentType = CRText::crText::CENTER_TOP;
		else if(str.compare("CENTER_CENTER")==0)
			m_alignmentType = CRText::crText::CENTER_CENTER;
		else if(str.compare("CENTER_BOTTOM")==0)
			m_alignmentType = CRText::crText::CENTER_BOTTOM;
		else if(str.compare("RIGHT_TOP")==0)
			m_alignmentType = CRText::crText::RIGHT_TOP;
		else if(str.compare("RIGHT_CENTER")==0)
			m_alignmentType = CRText::crText::RIGHT_CENTER;
		else if(str.compare("RIGHT_BOTTOM")==0)
			m_alignmentType = CRText::crText::RIGHT_BOTTOM;
		else if(str.compare("LEFT_BASE_LINE")==0)
			m_alignmentType = CRText::crText::LEFT_BASE_LINE;
		else if(str.compare("CENTER_BASE_LINE")==0)
			m_alignmentType = CRText::crText::CENTER_BASE_LINE;
		else if(str.compare("RIGHT_BASE_LINE")==0)
			m_alignmentType = CRText::crText::RIGHT_BASE_LINE;
		else if(str.compare("BASE_LINE")==0)
			m_alignmentType = CRText::crText::BASE_LINE;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	case 5:
		m_font = str;
		break;
	}
}

void crShowHeadTextMethod::operator()(crHandle &handle)
{
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview && bindview->isInited())
	{
		if(!m_text.valid())
		{
			m_text = new CRText::crText;
			m_text->setName("HeadText");
			m_text->setFont(m_font);
			m_text->setFontResolution((unsigned int)m_characterSize,(unsigned int)m_characterSize);
			m_text->setCharacterSize(m_characterSize);
			m_text->setAlignment((CRText::crText::AlignmentType)m_alignmentType);
			m_text->setColor(m_color);
			m_text->setText(CRIOManager::convertUTF8toUTF16(m_this->getName()).c_str());
			crFilterRenderManager::getInstance()->addDrawable(m_text.get(),true);
		}
		if(m_this->getVisiable())
		{
			crVector3 pos = m_this->getTrans();
			crVector3 cameraPos = crBrain::getInstance()->getCameraPosition();
			float dist = (pos-cameraPos).length();
			if(dist<m_maxRange)
			{
				pos[2] += m_this->getBoundBox().zMax() + m_zoffset;
				if(crBrain::getInstance()->getCameraFrustum().contains(pos))
				{
					crVector3 window;
					bindview->getDefaultSceneHandler()->getSceneView()->projectObjectIntoWindow(pos,window);
					window[2] = 0.0f;
					m_text->setPosition(window);
					crData *data = m_this->getDataClass();
					void *param;
					data->getParam(WCHDATA_Item,param);
					crInstanceItem *item = (crInstanceItem *)param;
					if(!item) return;
					std::string name = item->getIName();
					std::string headText = name;
					crData *itemData = item->getDataClass();
					float maxhp = 0;
					item->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
					if(maxhp>0.0f)
					{
						itemData->getParam(WCHDATA_RTHP,param);
						float rthp = *(float*)param;
						int progress = rthp/maxhp * 100.0f;
						headText += "[" + crArgumentParser::appItoa(progress) + "%]";
					}
					m_text->setText(CRIOManager::convertUTF8toUTF16(headText/*m_this->getName()*/).c_str());

					crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
					crVector4 color;
					if(!me || crMyPlayerData::getInstance()->ifItemIsMe(item) || crRunGameHandle::getInstance()->getRunningCode()<crRunGameHandle::NetGame)
					{
						color = crVector4(0.0f,1.0f,0.0f,1.0f);
					}
					else
					{
						char isEnemy = 0;
						me->doEvent(WCH_EnemyCheck,MAKEINT64(item,&isEnemy));
						if(isEnemy==1)
						{//队友
							color = crVector4(0.0f,0.0f,1.0f,1.0f);
						}
						else if(isEnemy == 0)
						{//和平
							color = crVector4(1.0f,1.0f,0.0f,1.0f);
						}
						else
						{//敌人
							color = crVector4(1.0f,0.0f,0.0f,1.0f);
						}
					}
					m_text->setColor(color);
					//m_text->setBackdropColor(color);
					//m_text->setBackdropType(CRText::crText::OUTLINE);
					m_text->setVisiable(true);
				}
				else
				{
					m_text->setVisiable(false);
				}
			}
			else
			{
				m_text->setVisiable(false);
			}
		}
		else
		{
            m_text->setVisiable(false);
		}
	}
}
void crShowHeadTextMethod::releaseObjects(crState* state)
{
	//m_text->setVisiable(false);
	//m_text->releaseObjects(state);
	crFilterRenderManager::getInstance()->removeDrawable(m_text.get());
	m_text = NULL;
}
/////////////////////////////////////////
//
//crLoadAndCloneNodeMethod
//
/////////////////////////////////////////
crLoadAndCloneNodeMethod::crLoadAndCloneNodeMethod():
m_copyop(crCopyOp::DEEP_COPY_NODES){}
crLoadAndCloneNodeMethod::crLoadAndCloneNodeMethod(const crLoadAndCloneNodeMethod& handle):
crMethod(handle),
m_copyop(handle.m_copyop)
{
}
void crLoadAndCloneNodeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_root = NULL;
			m_dataFile = NULL;
			m_addDescription = NULL;
		}
		break;
	case 1:
		m_root = (crGroup*)param;
		break;
	case 2:
		m_dataFile = (std::string*)param;
		break;
	case 3:
		m_addDescription = (std::string*)param;
		break;
	case 4:
		m_copyop = *(unsigned short*)param;
		break;
	}
}

void crLoadAndCloneNodeMethod::addParam(int i, const std::string& str)
{
}

void crLoadAndCloneNodeMethod::operator()(crHandle &handle)
{
	if(m_root.valid() && m_dataFile)
	{
		CRCore::ref_ptr<crGroup> proxyNode = new crGroup;
		proxyNode->setName("ProxyNode");
		proxyNode->setDescriptionsInString("DataFile "+*m_dataFile);
		CRIOManager::crLoadManager::getInstance()->requestNode(*m_dataFile,proxyNode.get(),false);
		if(proxyNode->getNumChildren()==1)
		{
			crGroup *cloneGroup = dynamic_cast<crGroup *>(proxyNode->clone(m_copyop));
			crNode *loadedNode = cloneGroup->getChild(0);
			if(m_addDescription && !m_addDescription->empty())
				loadedNode->addDescription(*m_addDescription);

			CRIOManager::crLoadManager::getInstance()->requestAddNode(m_root.get(),cloneGroup,true);
			handle.outputParam(1,loadedNode);
		}
	}
}
/////////////////////////////////////////
//
//crCreateDecalMethod
//
/////////////////////////////////////////
crCreateDecalMethod::crCreateDecalMethod():
m_textureFile(NULL),
m_Ithis(NULL){}
crCreateDecalMethod::crCreateDecalMethod(const crCreateDecalMethod& handle):
crMethod(handle),
m_textureFile(NULL),
m_Ithis(NULL)
{
}
void crCreateDecalMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_root = NULL;
			m_textureFile = NULL;
		}
		break;
	case 1:
		m_root = (crGroup*)param;
		break;
	case 2:
		m_textureFile = (std::string*)param;
		break;
	case 5:
		m_Ithis = (crInstanceItem *)param;
		break;
	case 6:
		m_createNodeName = *(std::string *)param;
		break;
	}
}

void crCreateDecalMethod::addParam(int i, const std::string& str)
{
}

void crCreateDecalMethod::operator()(crHandle &handle)
{
	if(m_root.valid() && m_textureFile)
	{
		ref_ptr<crHeightField> heightField = new crHeightField;
		//crSceneLayer *layer = crMyPlayerData::getInstance()->getSceneLayer();
		//float dx = layer->getXInterval();
		//float dy = layer->getYInterval();
		//int numColumns = m_size[0] * dx;
		//int numRows = m_size[1] * dy;
		//if(numColumns<2) numColumns = 2;
		//if(numRows<2) numRows = 2;
		//heightField->allocate(numColumns,numRows);
		//heightField->setXInterval(dx);
		//heightField->setYInterval(dy);
		ref_ptr<crShapeDrawable> shapeDrawable = new crShapeDrawable(heightField.get());
		shapeDrawable->setColor(crVector4(0.0f,0.0f,1.0f,1.0f));
		crStateSet *stateset = shapeDrawable->getOrCreateStateSet();
		//stateset->setMode(GL_DEPTH_TEST,CRCore::crStateAttribute::OFF);
		crTexture2D *tex2d = new crTexture2D;
		tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
		tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
		tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP);
		tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(*m_textureFile,tex2d));
		stateset->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
		crAlphaFunc *alphaFunc = new crAlphaFunc;
		alphaFunc->setFunction(crAlphaFunc::GREATER,0.01f);
		stateset->setAttributeAndModes(alphaFunc,crStateAttribute::ON);
		crBlendFunc *blendFunc = new crBlendFunc(crBlendFunc::SRC_ALPHA,crBlendFunc::ONE_MINUS_SRC_ALPHA);
		stateset->setAttributeAndModes(blendFunc,crStateAttribute::ON);
		stateset->setRenderingHint(CRCore::crStateSet::FX_BIN);
		shapeDrawable->setUseDisplayList(false);

		ref_ptr<crObject> object = new crObject;
		object->addDrawable(shapeDrawable.get());
		object->setCollideMode(crNode::CollideNone);
		object->setName(m_createNodeName);
		object->setEnableIntersect(false);
		object->setEffectByShadow(false);
		object->setCalcShadow(false);
		object->setAcceptGI(-1);
		crDecalUpdateCallback *callback = new crDecalUpdateCallback;
		object->setUpdateCallback(callback);
		if(m_Ithis) m_Ithis->addSceneFxNode(object.get());
		ref_ptr<CRCore::crTraverseStringNode> tsNode = new CRCore::crTraverseStringNode;
		tsNode->setName("NoLight");
		tsNode->addChild(object.get());
		CRIOManager::crLoadManager::getInstance()->requestAddNode(m_root.get(),tsNode.get(),true);
		handle.outputParam(1,object.get());
	}
}
/////////////////////////////////////////
//
//crCreateLightMethod
//
/////////////////////////////////////////
crCreateLightMethod::crCreateLightMethod(){}
crCreateLightMethod::crCreateLightMethod(const crCreateLightMethod& handle):
crMethod(handle)
{
}
void crCreateLightMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_root = NULL;
		}
		break;
	case 1:
		m_root = (crGroup*)param;
		break;
	}
}
void crCreateLightMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		if(str.compare("LIGHT_LOCAL") == 0)
			m_lightType = crLight::LIGHT_LOCAL;
		else if(str.compare("LIGHT_SPOT") == 0)
			m_lightType = crLight::LIGHT_SPOT;
		break;
	case 1:
		CRCore::crArgumentParser::appAtoVec(str,m_ambient);
		m_ambient /= 255.0f;
		break;
	case 2:
		CRCore::crArgumentParser::appAtoVec(str,m_diffuse);
		m_diffuse /= 255.0f;
		break;
	case 3:
		CRCore::crArgumentParser::appAtoVec(str,m_specular);
		m_specular /= 255.0f;
		break;
	case 4:
		CRCore::crArgumentParser::appAtoVec(str,m_position);
		break;
	case 5:
		CRCore::crArgumentParser::appAtoVec(str,m_direction);
		break;
	case 6:
		m_spotExponent = atof(str.c_str());
		break;
	case 7:
		m_spotCutoff = atof(str.c_str());
		break;
	case 8:
		m_constantAttenuation = atof(str.c_str());
		break;
	case 9:
		m_linearAttenuation = atof(str.c_str());
		break;
	case 10:
		m_quadraticAttenuation = atof(str.c_str());
		break; 
	case 11:
		m_lowestLum = atof(str.c_str());
		break;
	}
}
void crCreateLightMethod::operator()(crHandle &handle)
{
	if(m_root.valid())
	{
		ref_ptr<crLight> light = new crLight;
		ref_ptr<crLightSource> ls = new crLightSource;
		ls->setLight(light.get());
		light->setLightType((crLight::LightType)m_lightType);
		light->setAmbient(crVector4(m_ambient,1.0f));
		light->setDiffuse(crVector4(m_diffuse,1.0f));
		light->setSpecular(crVector4(m_specular,1.0f));
		light->setPosition(crVector4(m_position,1.0f));
		light->setDirection(m_direction);
		light->setConstantAttenuation(m_constantAttenuation);
		light->setLinearAttenuation(m_linearAttenuation);
		light->setQuadraticAttenuation(m_quadraticAttenuation);
		light->setSpotExponent(m_spotExponent);
		light->setSpotCutoff(m_spotCutoff);
		light->setLoweastLum(m_lowestLum);
		crLightSourceManager::getInstance()->insertLightSource(ls.get());
		ls->initLightParamStruct();
        CRIOManager::crLoadManager::getInstance()->requestAddNode(m_root.get(),ls.get(),false);
		handle.outputParam(1,ls.get());
	}
}
/////////////////////////////////////////
//
//crLoadParticleMethod
//
/////////////////////////////////////////
crLoadParticleMethod::crLoadParticleMethod(){}
crLoadParticleMethod::crLoadParticleMethod(const crLoadParticleMethod& handle):
crMethod(handle)
{
}
void crLoadParticleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_root = NULL;
			m_dataFile = NULL;
		}
		break;
	case 1:
		m_root = (crGroup*)param;
		break;
	case 2:
		m_dataFile = (std::string*)param;
		break;
	}
}
void crLoadParticleMethod::addParam(int i, const std::string& str)
{
}
void crLoadParticleMethod::operator()(crHandle &handle)
{
	if(m_root.valid() && m_dataFile)
	{
		loadParticle(*m_dataFile,m_root.get());
	}
}
/////////////////////////////////////////
//
//crLoadSoundMethod
//
/////////////////////////////////////////
crLoadSoundMethod::crLoadSoundMethod():
m_stream(false){}
crLoadSoundMethod::crLoadSoundMethod(const crLoadSoundMethod& handle):
crMethod(handle),
m_stream(handle.m_stream)
{
}
void crLoadSoundMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		if(param)
			m_dataFile = *(std::string*)param;
		break;
	}
}

void crLoadSoundMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stream = (bool)atoi(str.c_str());
		break;
	}
}

void crLoadSoundMethod::operator()(crHandle &handle)
{
	if(CRIOManager::fileExists(m_dataFile.c_str()))
	{
		//if(crStartHandler::getInstance()->isRunning())
		crSound *sound = crSoundSystem::getInstance()->createSound(m_dataFile);
		handle.outputParam(1,sound);
	}
	else
	{//如果音乐文件不存在则加入到下载队列
		crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
		if(data)
		{
			crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(m_dataFile));
			data->insertHttpDownloadFile(HttpD_None,m_dataFile);
			data->startHttpDownloadTask(HttpD_None);
		}
		handle.outputParam(1,NULL);
	}
}
/////////////////////////////////////////
//
//crInPatrolTestMethod
//
/////////////////////////////////////////
crInPatrolTestMethod::crInPatrolTestMethod():m_dist(0){}
crInPatrolTestMethod::crInPatrolTestMethod(const crInPatrolTestMethod& handle):
m_dist(0),
crMethod(handle)
{
}
void crInPatrolTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_dist = HIINT64(param64);
			//m_distEnmity = *(_crInt64 *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_dist = 0;
		}
		break;
	}
}
void crInPatrolTestMethod::addParam(int i, const std::string& str)
{
}
void crInPatrolTestMethod::operator()(crHandle &handle)
{
	if(m_item.valid())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_PatrolPointVec,param);
		PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
		bool inPatrol = false;
		if(!patrolPointVec->empty())
		{
			data->getParam(WCHDATA_GuardRange,param);
			int guardRange = *((short*)param);
			guardRange *= guardRange;
			//float _guardRange = (float)guardRange * crGlobalHandle::gData()->gUnitScale();
			crVector2i itmePos(m_item->getPosx(),m_item->getPosy());
			crVector2i point;
			//itmePos *= crGlobalHandle::gData()->gUnitScale();
			for( PatrolPointVec::iterator itr = patrolPointVec->begin();
				itr != patrolPointVec->end();
				++itr )
			{
				point = *itr;
				if((point - itmePos).length2() < guardRange)
				{
					inPatrol = true;
					break;
				}
			}
		}
		else
			inPatrol = true;
		if(inPatrol)
		{
			data->getParam(WCHDATA_InPatrolEnemyMap,param);
			InPatrolEnemyMap *enemyMap = (InPatrolEnemyMap *)param;
			if(enemyMap)
			{
				enemyMap->insert(std::make_pair(m_dist,m_item));
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"(错误)crInstanceItem::serverUpdate NPC没有Patrol instanceid="<<m_this->getInstanceItemID()<<std::endl;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crCalcEnmityByDistRateMethod
//
/////////////////////////////////////////
crCalcEnmityByDistRateMethod::crCalcEnmityByDistRateMethod():
m_distFactor(0.0f),
m_distRate(0.0f)
{}
crCalcEnmityByDistRateMethod::crCalcEnmityByDistRateMethod(const crCalcEnmityByDistRateMethod& handle):
crMethod(handle),
m_distFactor(handle.m_distFactor),
m_distRate(handle.m_distRate)
{
}
void crCalcEnmityByDistRateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_distRate = param?*(float*)param:0.0f;
		break;
	}
}
void crCalcEnmityByDistRateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_distFactor = atof(str.c_str());
		break;
	}
}
void crCalcEnmityByDistRateMethod::operator()(crHandle &handle)
{
    float enmity = m_distFactor * m_distRate;
	handle.outputParam(2,&enmity);
}
///////////////////////////////////////////
////
////crGetEnemy1Method
////
///////////////////////////////////////////
//crGetEnemy1Method::crGetEnemy1Method(){}
//crGetEnemy1Method::crGetEnemy1Method(const crGetEnemy1Method& handle):
//crMethod(handle)
//{
//}
//void crGetEnemy1Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	}
//}
//void crGetEnemy1Method::addParam(int i, const std::string& str)
//{
//}
//void crGetEnemy1Method::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_PlayerEnmityMap,param);
//		PlayerEnmityMap* playerEnmityMap = (PlayerEnmityMap*)param;
//		float maxEnmity = 0.0f;
//		_crInt64 enemy = 0;
//		for( PlayerEnmityMap::iterator itr = playerEnmityMap->begin();
//			 itr != playerEnmityMap->end();
//			 ++itr )
//		{
//            if(maxEnmity<itr->second)
//			{
//				maxEnmity = itr->second;
//				enemy = itr->first;
//			}
//		}
//		handle.outputParam(1,&enemy);
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
///////////////////////////////////////////
////
////crSelectSkill1Method
////
///////////////////////////////////////////
//crSelectSkill1Method::crSelectSkill1Method(){}
//crSelectSkill1Method::crSelectSkill1Method(const crSelectSkill1Method& handle):
//crMethod(handle)
//{
//}
//void crSelectSkill1Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_item = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		m_item = (crInstanceItem*)param;
//		break;
//	}
//}
//void crSelectSkill1Method::addParam(int i, const std::string& str)
//{
//}
//void crSelectSkill1Method::operator()(crHandle &handle)
//{
//	if(m_this && m_item.valid())
//	{
//		bool isAboutToUseItem = false;
//		handle.outputParam(2,&isAboutToUseItem);
//		//void *param;
//		//crData *data = m_this->getDataClass();
//		//data->getParam(WCHDATA_CurrentUseItem,param);
//		//int currentSkill = *((int*)param);
//		//data->getParam(WCHDATA_DefaultAttack,param);
//		//int defaultSkill = *((int*)param);
//		//int selectSkill = defaultSkill;
//		//data->excHandle(MAKEINT64(WCH_LockData,1));
//		//data->getParam(WCHDATA_SkillVec,param);
//		//SkillVec* skillVec = (SkillVec*)param;
//		//for( SkillVec::iterator itr = skillVec->begin();
//		//	 itr != skillVec->end();
//		//	 ++itr )
//		//{
//
//		//}
//		//data->excHandle(MAKEINT64(WCH_LockData,0));
//		//if(currentSkill != selectSkill)
//		//{
//		//	data->inputParam(WCHDATA_CurrentUseItem,&selectSkill);
//		//	//sendpacket to neible
//		//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
//		//	stream->createBuf(4);
//		//	stream->_writeInt(selectSkill);
//
//		//	crItemEventPacket packet;
//		//	crItemEventPacket::buildRequestPacket(packet,0,m_this->getItemtype(),m_this->getInstanceItemID(),WCH_SetCurrentUseItem,stream.get());
//		//	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//		//	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//		//	crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//		//	callback->sendPacketToItemNeighbor(m_this,packet);
//		//}
//	}
//}
crPatrolMethod::crPatrolMethod():
m_taskPointRange(1.0f){}
crPatrolMethod::crPatrolMethod(const crPatrolMethod& handle):
crMethod(handle),
m_taskPointRange(handle.m_taskPointRange)
{
}
void crPatrolMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crPatrolMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskPointRange = atof(str.c_str())/crGlobalHandle::gData()->gUnitScale();
		m_taskPointRange *= m_taskPointRange;
		break;
	}
}
void crPatrolMethod::operator()(crHandle &handle)
{
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());

		void *param;
		crData *data = m_this->getDataClass();
		
		bool patrol = false;
		unsigned char count = 0;
		crVector2i targetPos;
		//float scale = crGlobalHandle::gData()->gUnitScale();
		crVector2i myPos(m_this->getPosx(), m_this->getPosy());// , 0.0f);
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_PatrolPointVec,param);
		PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
		count = patrolPointVec->size();
		if(count == 1)
		{
			targetPos[0] = (*patrolPointVec)[0][0];
			targetPos[1] = (*patrolPointVec)[0][1];
			patrol = true;
		}
		else
		{
			data->getParam(WCHDATA_PatrolIndex,param);
			char* idx = (char*)param;
			if(*idx<count)
			{
				targetPos[0] = (*patrolPointVec)[*idx][0];
				targetPos[1] = (*patrolPointVec)[*idx][1];
				crVector2i vec = targetPos - myPos;
				if(vec.length2()<m_taskPointRange)
				{
					(*idx)++;
					if(*idx>=count)
						*idx = 0;
					targetPos[0] = (*patrolPointVec)[*idx][0];
					targetPos[1] = (*patrolPointVec)[*idx][1];
					patrol = true;
				}
			}
			else
			{
				*idx = 0;
				targetPos[0] = (*patrolPointVec)[*idx][0];
				targetPos[1] = (*patrolPointVec)[*idx][1];
				patrol = true;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		//targetPos[2] = scene->getPosZ(m_this->getLayerID(),targetPos[0],targetPos[1],m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale());
		if(patrol)
		{
			float scale = crGlobalHandle::gData()->gUnitScale();
			crVector3 _targetPos((float)targetPos[0] * scale, (float)targetPos[1] * scale, 0.0f);
			data->getParam(WCHDATA_TargetPos,param);
			crVector3 oldtargetpos = *(crVector3 *)param;
			if ((oldtargetpos - _targetPos).length2()>1.0f)
			{
				unsigned char itemstate = IS_Move;
				unsigned char targettype = Target_Coord;
				data->inputParam(WCHDATA_ItemState,&itemstate);
				data->inputParam(WCHDATA_TargetType,&targettype);
				data->inputParam(WCHDATA_TargetPos, &_targetPos);
				scene->getPathFindingManager()->addPathFindRequest(m_this);
			}
		}
		//data->getParam(WCHDATA_ItemState,param);
		//unsigned char lastState = *(unsigned char*)param;
		//if(lastState != IS_Patrol && count>0)
		//{
		//	sendState = true;
		//}

		//if(sendState)
		//{
		//	//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		//	//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		//	//crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		//	//crItemEventPacket packet;
		//	//ref_ptr<crStreamBuf> stream = new crStreamBuf;
		//	unsigned char itemstate = IS_Patrol;
		//	unsigned char targettype = Target_Coord;

		//	//stream->createBuf(26);
		//	//stream->_writeInt(m_this->getPosx());
		//	//stream->_writeInt(m_this->getPosy());
		//	//stream->_writeInt(m_this->getPosz());
		//	////stream->_writeFloat(m_this->getDirx());
		//	////stream->_writeFloat(m_this->getDiry());
		//	////stream->_writeFloat(m_this->getDirz());

		//	//stream->_writeUChar(itemstate);
		//	//stream->_writeUChar(targettype);
		//	//stream->_writeVec3(targetPos);
		//	data->inputParam(WCHDATA_ItemState,&itemstate);
		//	data->inputParam(WCHDATA_TargetType,&targettype);
		//	data->inputParam(WCHDATA_TargetPos,&targetPos);
		//	scene->getPathFindingManager()->addPathFindRequest(m_this);

		//	//crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_Patrol,stream.get());
		//	//callback->findScene(m_this->getSceneID())->sendPacketToItemNeighbor(m_this,packet);
		//}
	}
}
/////////////////////////////////////////
//
//crRecvPatrolMethod
//
/////////////////////////////////////////
crRecvPatrolMethod::crRecvPatrolMethod(){}
crRecvPatrolMethod::crRecvPatrolMethod(const crRecvPatrolMethod& handle):
crMethod(handle)
{
}
void crRecvPatrolMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvPatrolMethod::addParam(int i, const std::string& str)
{
}
void crRecvPatrolMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_Dead)
		{
			return;
		}

		crVector3i pos;
		pos[0] = m_stream->_readInt();
		pos[1] = m_stream->_readInt();
		pos[2] = m_stream->_readInt();
		//pos 合法性检查
		m_this->setPosxy(pos[0],pos[1]);
		m_this->setPosz(pos[2]);
		//m_this->setDirx(m_stream->_readFloat());
		//m_this->setDiry(m_stream->_readFloat());
		//m_this->setDirz(m_stream->_readFloat());
		itemstate = m_stream->_readUChar();
		data->inputParam(WCHDATA_ItemState,&itemstate);
		unsigned char targettype = m_stream->_readUChar();
		data->inputParam(WCHDATA_TargetType,&targettype);
		crVector3 targetPos = m_stream->_readVec3();
        data->inputParam(WCHDATA_TargetPos,&targetPos);

		//if(m_netType == GameClient_Game)
		//{
		//	crNode *this_bot = m_this->getRelNode();
		//	if(this_bot)
		//	{
		//		m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(this_bot,crMatterObject::MD_TransMatrix));

		//		//if(itemstate = IS_Patrol)
		//		//{
		//		//	//float speed = 0;
		//		//	//m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
		//		//	//float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
  //  // //               this_bot->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&targetPos,&relspeed));
		//		//	crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
		//		//}
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crHideBodyMethod
//
/////////////////////////////////////////
crHideBodyMethod::crHideBodyMethod():m_visiable(false),m_intersectable(false){}
crHideBodyMethod::crHideBodyMethod(const crHideBodyMethod& handle):
crMethod(handle),
m_visiable(false),m_intersectable(false)
{
}
void crHideBodyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			_crInt32 lparam = LOINT64(param64);
			m_visiable = (bool)(LOINT32(lparam));
			m_intersectable = (bool)(HIINT32(lparam));
		}
		else
		{
			m_visiable = false;
			m_intersectable = false;
		}
		break;
	}
}
void crHideBodyMethod::addParam(int i, const std::string& str)
{
}
void crHideBodyMethod::operator()(crHandle &handle)
{
	{
	    m_this->setVisiable(m_visiable);
		m_this->setEnableIntersect(m_intersectable);
	}
}
/////////////////////////////////////////
//
//crRecvTargetExtraMethod
//
/////////////////////////////////////////
crRecvTargetExtraMethod::crRecvTargetExtraMethod(){}
crRecvTargetExtraMethod::crRecvTargetExtraMethod(const crRecvTargetExtraMethod& handle):
crMethod(handle)
{
}
void crRecvTargetExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvTargetExtraMethod::addParam(int i, const std::string& str)
{
}

void crRecvTargetExtraMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();

		unsigned char firetype = m_stream->_readUChar();
		int fireid = m_stream->_readInt();
		int fireroleid = firetype == crInstanceItem::Role?m_stream->_readInt():0;
		int bulletitemid = m_stream->_readInt();

		ref_ptr<crInstanceItem> fireItem;
		if(firetype == crInstanceItem::Role)
		{
			if(fireid == crMyPlayerData::getInstance()->getPlayerID())
			{
				fireItem = crMyPlayerData::getInstance()->getRole(fireroleid);
			}
			else
			{
				crMyPlayerData::RoleNpcPair roleNpcPair;
				if(crMyPlayerData::getInstance()->findInRangePlayer(fireid,fireroleid,roleNpcPair))
				{
					fireItem = roleNpcPair.first.get();
				}
				else if(crMyPlayerData::getInstance()->findOutRangePlayer(fireid,fireroleid,roleNpcPair))
				{
					fireItem = roleNpcPair.first.get();
				}
			}
		}
		else if(firetype == crInstanceItem::Npc)
		{
			crMyPlayerData::ItemNpcPair itemNpcPair;
			if(crMyPlayerData::getInstance()->findInRangeNpc(fireid,itemNpcPair))
			{
				fireItem = itemNpcPair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeNpc(fireid,itemNpcPair))
			{
				fireItem = itemNpcPair.first.get();
			}
		}
		else
		{
			crMyPlayerData::ItemNodePair itemNodePair;
			if(crMyPlayerData::getInstance()->findInRangeItem(fireid,itemNodePair))
			{
				fireItem = itemNodePair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeItem(fireid,itemNodePair))
			{
				fireItem = itemNodePair.first.get();
			}
		}
		do 
		{
			if(!fireItem.valid()) break;
			crItemChild *itemChild = fireItem->findChildItem(bulletitemid);
            if(!itemChild || !itemChild->isLoaded()) break;
			crInstanceItem *bulletitem = itemChild->getInstanceItem();
			if(!bulletitem) break;

			void *param;
			crData *bulletData = bulletitem->getDataClass();
			if(!bulletData) break;
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_TargetExtra,WCH_Client));
			if(!handle) break;

			bulletData->getParam(WCHDATA_TargetExtraID,param);
			_crInt32 targetExtraID = *((_crInt32*)param);

			//crRole *myrole = crMyPlayerData::getInstance()->getLoadedRoleByIndex(0);
			//if(myrole && myrole->getDataClass())
			//{//缓存bufhandle
			//	crData *myroledata = myrole->getDataClass();
			//	crHandle *existhandle = myroledata->getHandle(MAKEINT64(WCH_ClientExtraHandle,targetExtraID));
			//	if(!existhandle)
			//	{
			//		myroledata->insertHandle(MAKEINT64(WCH_ClientExtraHandle,targetExtraID),handle->clone());
			//	}
			//}

			crData *hitData = m_this->getDataClass();
			//hitData->excHandle(MAKEINT64(WCH_LockData,1));
			hitData->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;
			if(extraData)
			{
				//extraData->insertHandle(MAKEINT64(WCH_DoExtra,targetExtraID),cloneHandle);
				//extraData->inputParam(WCHDATA_ExtraIDSet,&targetExtraID);
				bool can = true;
				short extraid = LOINT32(targetExtraID);
				short extrapri = HIINT32(targetExtraID);
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
				if(exitr != extraIDMap->end())
				{
					if(extrapri<exitr->second)
					{
						can = false;
					}
				}
				if(can)
				{
					crHandle *cloneHandle = handle->clone();
					crVector3 dir = m_this->getPosition() - fireItem->getPosition();
					dir.normalize();
					cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
					cloneHandle->inputParam(WCHDATA_FireItem,fireItem.get());
					crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
					if(existhandle)
					{
						existhandle->releaseObjects(NULL);
					}

					extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
					(*extraIDMap)[extraid] = extrapri;
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			//hitData->excHandle(MAKEINT64(WCH_LockData,0));
		} while (0);
	}
}
/////////////////////////////////////////
//
//crRecvUserExtraMethod
//
/////////////////////////////////////////
crRecvUserExtraMethod::crRecvUserExtraMethod(){}
crRecvUserExtraMethod::crRecvUserExtraMethod(const crRecvUserExtraMethod& handle):
	crMethod(handle)
{
}
void crRecvUserExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvUserExtraMethod::addParam(int i, const std::string& str)
{
}

void crRecvUserExtraMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();

		int bulletitemid = m_stream->_readInt();
		do 
		{
			//if(!fireItem) break;
			crItemChild *itemChild = m_this->findChildItem(bulletitemid);
			if(!itemChild || !itemChild->isLoaded()) break;
			crInstanceItem *bulletitem = itemChild->getInstanceItem();
			if(!bulletitem) break;

			void *param;
			crData *bulletData = bulletitem->getDataClass();
			if(!bulletData) break;
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
			if(!handle) break;

			bulletData->getParam(WCHDATA_UserExtraID,param);
			_crInt32 userExtraID = *((_crInt32*)param);

			//crRole *myrole = crMyPlayerData::getInstance()->getLoadedRoleByIndex(0);
			//if(myrole && myrole->getDataClass())
			//{//缓存bufhandle
			//	crData *myroledata = myrole->getDataClass();
			//	crHandle *existhandle = myroledata->getHandle(MAKEINT64(WCH_ClientExtraHandle,userExtraID));
			//	if(!existhandle)
			//	{
			//		myroledata->insertHandle(MAKEINT64(WCH_ClientExtraHandle,userExtraID),handle->clone());
			//	}
			//}

			crData *hitData = m_this->getDataClass();
			//hitData->excHandle(MAKEINT64(WCH_LockData,1));
			hitData->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;
			if(extraData)
			{
				//extraData->insertHandle(MAKEINT64(WCH_DoExtra,targetExtraID),cloneHandle);
				//extraData->inputParam(WCHDATA_ExtraIDSet,&targetExtraID);
				bool can = true;
				short extraid = LOINT32(userExtraID);
				short extrapri = HIINT32(userExtraID);
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
				if(exitr != extraIDMap->end())
				{
					if(extrapri<exitr->second)
					{
						can = false;
					}
				}
				if(can)
				{
					crHandle *cloneHandle = handle->clone();
					crVector3 dir = m_this->getDir();
					cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
					cloneHandle->inputParam(WCHDATA_FireItem,m_this);
					crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
					if(existhandle)
					{
						existhandle->releaseObjects(NULL);
					}

					extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
					(*extraIDMap)[extraid] = extrapri;
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			//hitData->excHandle(MAKEINT64(WCH_LockData,0));
		} while (0);
	}
}
/////////////////////////////////////////
//
//crExtraUpdateMethod
//
/////////////////////////////////////////
crExtraUpdateMethod::crExtraUpdateMethod():
m_time(0.0f),
m_interval(0.25){}
crExtraUpdateMethod::crExtraUpdateMethod(const crExtraUpdateMethod& handle):
crMethod(handle),
m_time(0.0f),
m_interval(handle.m_interval)
{
}
void crExtraUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		m_param = param?*(_crInt64*)param:NULL;
		break;
	}
}

void crExtraUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}

void crExtraUpdateMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(!m_param) return;
	float *dt = (float *)(LOINT64(m_param));
	if(m_time + *dt > m_interval)
	{
		*dt += m_time;
		m_time = 0.0f;

		void *param;
		ref_ptr<crData> data = m_this->getDataClass();
		data->getParam(WCHDATA_ExtraData,param);
		if(param)
		{
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			data->excHandle(MAKEINT64(WCH_ResetExtra,NULL));
			ref_ptr<crData> extraData = (crData *)param;
			short id = 0;
			short pri = 0;
			int itemid = m_this->getInstanceItemID();
			int playerid = m_this->getPlayerID();
			bool removeExtra = false;
			std::vector<short> EraseVec;
			ref_ptr<crHandle>handle;
			extraData->excHandle(MAKEINT64(WCH_LockData,1));
			extraData->getParam(WCHDATA_ExtraIDMap,param);
			ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
			ExtraIDMap extraIDMap_copy = *extraIDMap;
			for( ExtraIDMap::iterator itr = extraIDMap_copy.begin();
				itr != extraIDMap_copy.end();
				++itr )
			{
				id = itr->first;
				pri = itr->second;
				handle = extraData->getHandle(MAKEINT64(WCH_DoExtra,id));
				if(handle.valid())
				{
					removeExtra = true;
					crHandleManager::getInstance()->waitToExecuteHandle(handle.get());
					try
					{
						handle->inputParam(1,m_this);
						handle->inputParam(2,&m_param);
						handle->inputParam(3,&removeExtra);
						extraData->excHandle(handle.get());
					}
					catch (...)
					{
						CRCore::notify(CRCore::ALWAYS)<<"crExtraUpdateMethod::doEvent error ExtraID = "<<id<<std::endl;
					}
					crHandleManager::getInstance()->endExecuteHandle(handle.get());
					if(removeExtra)
					{
						EraseVec.push_back(id);
					}
				}
			}
			for( std::vector<short>::iterator itr = EraseVec.begin();
				itr != EraseVec.end();
				++itr )
			{
				if(crGlobalHandle::isClient())
				{
					handle = extraData->getHandle(MAKEINT64(WCH_DoExtra,*itr));
					if(handle.valid())
					{
						handle->releaseObjects(NULL);
					}
				}
				extraData->removeHandle(MAKEINT64(WCH_DoExtra,*itr));
				extraIDMap->erase(*itr);
			}
			extraData->excHandle(MAKEINT64(WCH_LockData,0));

			//data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
	else
	{
		m_time += *dt;
	}
}
/////////////////////////////////////////
//
//crExtraLifeTimeMethod
//
/////////////////////////////////////////
crExtraLifeTimeMethod::crExtraLifeTimeMethod():
	m_dt(NULL),
	m_output(NULL),
	m_duration(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crExtraLifeTimeMethod::crExtraLifeTimeMethod(const crExtraLifeTimeMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_output(NULL),
	m_duration(handle.m_duration),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crExtraLifeTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case 3:
		m_output = (bool*)param;
		break;
	case WCHDATA_OverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap;
		}
		break;
	}
}

void crExtraLifeTimeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	}
}

void crExtraLifeTimeMethod::operator()(crHandle &handle)
{
	*m_output = false;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_duration>0.0f)
	{
		m_timer -= *m_dt;
		if(m_timer<0.0f)
		{
			*m_output = true;
			m_start = false;
			m_timer = 0.0f;
		}
	}
}
///////////////////////////////////////////
////
////crExtraDefendMethod
////
///////////////////////////////////////////
//crExtraDefendMethod::crExtraDefendMethod():
//m_dt(NULL),
//m_output(NULL),
//m_duration(0.0f),
//m_extraValue(0.0f),
//m_start(false),
//m_timer(0.0f){}
//crExtraDefendMethod::crExtraDefendMethod(const crExtraDefendMethod& handle):
//crMethod(handle),
//m_dt(NULL),
//m_output(NULL),
//m_duration(handle.m_duration),
//m_extraValue(handle.m_extraValue),
//m_start(false),
//m_timer(0.0f)
//{
//}
//void crExtraDefendMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = (float*)(LOINT64(param64));
//		}
//		else
//		{
//			m_dt = NULL;
//		}
//		break;
//	case 3:
//		m_output = (bool*)param;
//		break;
//	}
//}
//
//void crExtraDefendMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_duration = atof(str.c_str());
//		break;
//	case 1:
//		m_extraValue = (short)(atoi(str.c_str()));
//		break;
//	}
//}
//
//void crExtraDefendMethod::operator()(crHandle &handle)
//{
//	if(!m_start)
//	{
//		void *param;
//		crData *thisData = m_this->getDataClass();
//		thisData->excHandle(MAKEINT64(WCH_LockData,1));
//		thisData->getParam(WCHDATA_ExtraDefend,param);
//		short* extra = (short *)param;
//		*extra += m_extraValue;
//		thisData->excHandle(MAKEINT64(WCH_LockData,0));
//		m_start = true;
//		m_timer = m_duration;
//	}
//	else
//	{
//		m_timer -= *m_dt;
//		if(m_timer<0.0f)
//		{
//			*m_output = true;
//			m_start = false;
//			m_timer = 0.0f;
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			thisData->excHandle(MAKEINT64(WCH_LockData,1));
//			thisData->getParam(WCHDATA_ExtraDefend,param);
//			short* extra = (short *)param;
//			*extra -= m_extraValue;
//			thisData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
///////////////////////////////////////////
////
////crExtraGuiseMethod
////
///////////////////////////////////////////
//crExtraGuiseMethod::crExtraGuiseMethod():
//	m_dt(NULL),
//	m_output(NULL),
//	m_duration(0.0f),
//m_guise(GS_Normal),
//m_start(false),
//m_timer(0.0f){}
//crExtraGuiseMethod::crExtraGuiseMethod(const crExtraGuiseMethod& handle):
//	crMethod(handle),
//	m_dt(NULL),
//	m_output(NULL),
//	m_duration(handle.m_duration),
//	m_guise(handle.m_guise),
//	m_start(false),
//	m_timer(0.0f)
//{
//}
//void crExtraGuiseMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = (float*)(LOINT64(param64));
//		}
//		else
//		{
//			m_dt = NULL;
//		}
//		break;
//	case 3:
//		m_output = (bool*)param;
//		break;
//	}
//}
//
//void crExtraGuiseMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_duration = atof(str.c_str());
//		break;
//	case 1:
//		m_guise = (unsigned int)(atoi(str.c_str()));
//		break;
//	}
//}
//
//void crExtraGuiseMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crData *data = m_this->getDataClass();
//	data->excHandle(MAKEINT64(WCH_LockData,1));
//	data->getParam(WCHDATA_ExtraGuise,param);
//	unsigned int* extra = (unsigned int *)param;
//	if(!m_start)
//	{
//		m_start = true;
//		m_timer = m_duration;
//		*extra |= m_guise;
//	}
//	else
//	{
//		m_timer -= *m_dt;
//		if(m_timer<0.0f)
//		{
//			*m_output = true;
//			m_start = false;
//			m_timer = 0.0f;
//			*extra &= ~m_guise;
//		}
//		else
//		{
//			*extra |= m_guise;
//		}
//	}
//	data->excHandle(MAKEINT64(WCH_LockData,0));
//}
/////////////////////////////////////////
//
//crExtraRadiusMethod
//
/////////////////////////////////////////
crExtraRadiusMethod::crExtraRadiusMethod():
	m_dt(NULL),
	m_output(NULL),
	m_duration(0.0f),
	m_radius(100),
	m_start(false),
	m_timer(0.0f){}
crExtraRadiusMethod::crExtraRadiusMethod(const crExtraRadiusMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_output(NULL),
	m_duration(handle.m_duration),
	m_radius(handle.m_radius),
	m_start(false),
	m_timer(0.0f)
{
}
void crExtraRadiusMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case 3:
		m_output = (bool*)param;
		break;
	}
}

void crExtraRadiusMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_radius = (char)(atoi(str.c_str()));
		break;
	}
}

void crExtraRadiusMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_ExtraRadius,param);
	char* extra = (char *)param;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		*extra = m_radius;
	}
	else
	{
		m_timer -= *m_dt;
		if(m_timer<0.0f)
		{
			*m_output = true;
			m_start = false;
			m_timer = 0.0f;
			*extra = 100;
		}
		else
		{
			*extra = m_radius;
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crEnableBulletVolumeMethod
//
/////////////////////////////////////////
crEnableBulletVolumeMethod::crEnableBulletVolumeMethod():
m_enable(false){}
crEnableBulletVolumeMethod::crEnableBulletVolumeMethod(const crEnableBulletVolumeMethod& handle):
crMethod(handle),
m_enable(false)
{
}
void crEnableBulletVolumeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crVolumeNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_enable = LOINT64(param64)==0?false:true;
		}
		else
		{
			m_enable = false;
		}
		break;
	}
}
void crEnableBulletVolumeMethod::addParam(int i, const std::string& str)
{
}
void crEnableBulletVolumeMethod::operator()(crHandle &handle)
{
	{
		m_this->setEnable(m_enable);
	}
}
/////////////////////////////////////////
//
//crNodeInBulletVolumeMethod
//
/////////////////////////////////////////
crNodeInBulletVolumeMethod::crNodeInBulletVolumeMethod():
m_targetType(Target_Enemy),
m_isvalid(NULL){}
crNodeInBulletVolumeMethod::crNodeInBulletVolumeMethod(const crNodeInBulletVolumeMethod& handle):
crMethod(handle),
m_targetType(handle.m_targetType),
m_isvalid(NULL)
{
}
void crNodeInBulletVolumeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crVolumeNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_inVolumeNode = (crMatterObject *)(LOINT64(param64));
			m_isvalid = (bool *)(HIINT64(param64));
		}
		else
		{
			m_inVolumeNode = NULL;
			m_isvalid = NULL;
		}
		break;
	}
}
void crNodeInBulletVolumeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_targetType = (char)(atoi(str.c_str()));
		break;
	}
}
void crNodeInBulletVolumeMethod::operator()(crHandle &handle)
{
	//CRCore::notify(CRCore::ALWAYS)<<"crBulletCollideMethod"<<std::endl;
	if(m_inVolumeNode.valid() && m_inVolumeNode->getDataClass())
	{
		void *param;
		crData *hitData = m_inVolumeNode->getDataClass();
		hitData->getParam(WCHDATA_Item,param);
		if(!param) return;
		ref_ptr<crInstanceItem> hititem = ((crInstanceItem*)param);
		//int hitid = hititem->getID();
		ref_ptr<crBulletMatterObject> bullet = dynamic_cast<crBulletMatterObject *>(m_this->getMainBody());
		if(bullet.valid() && bullet->getDataClass() && bullet->getFireWeapon() && bullet->getFireWeapon()->getFireBody())
		{
			const crViewMatterObject *fireBot = bullet->getFireWeapon()->getFireBody();
			crData *fireData = const_cast<crData *>(fireBot->getDataClass());
			if(!fireData) return;
			fireData->getParam(WCHDATA_Item,param);
			if(!param) return;
			ref_ptr<crInstanceItem> fireItem = ((crInstanceItem*)param);
			//bool hitvalid = true;
			*m_isvalid = true;
			if(m_targetType!=0)
			{
				if( fireItem->getItemtype()==crInstanceItem::Role && 
					hititem->getItemtype()==crInstanceItem::Role &&
					hititem->getID() == fireItem->getID())
				{//击中自己
					if(!(m_targetType & Target_Self))
						*m_isvalid = false;
				}
				else
				{
					char isEnemy = 0;
					fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(hititem.get(),&isEnemy));
					if(isEnemy == -1)
					{//敌对
						if(m_targetType & Target_Friend)
							*m_isvalid = false;
					}
					else if(isEnemy == 1)
					{
						if(m_targetType & Target_Enemy)
							*m_isvalid = false;
						else if(m_targetType == Target_Self)
						{//只能对自己使用
							if( fireItem->getItemtype()!=crInstanceItem::Role || 
								hititem->getItemtype()!=crInstanceItem::Role ||
								hititem->getID() != fireItem->getID())
							{
								*m_isvalid = false;
							}
						}
					}
					else
					{
						*m_isvalid = false;
					}
				}
			}
			if(*m_isvalid)
			{
				//unsigned char hitItemType = hititem->getItemtype();
				unsigned char fireType = fireItem->getItemtype();
				bool sendevent = false;
				if(crMyPlayerData::getInstance()->ifItemIsMe(hititem.get()) || crMyPlayerData::getInstance()->ifItemIsMe(fireItem.get()))
					sendevent = true;
				if(sendevent)
				{//通知服务器，被击中
					int fireid = fireItem->getID();
					crData *bulletData = bullet->getDataClass();
					bulletData->getParam(WCHDATA_Item,param);
					crInstanceItem *bulletItem = ((crInstanceItem*)param);
					if(!bulletItem) return;
					int bulletItemID = bulletItem->getInstanceItemID();

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(17);
					//stream->_writeUChar(hititem->getItemtype());
					//stream->_writeInt(hitid);
					stream->_writeUChar(fireType);
					stream->_writeInt(fireid);
					if(fireType == crInstanceItem::Role)
						stream->_writeInt(fireItem->getRoleID());
					stream->_writeInt(bulletItemID);
					float rate = 1.0f;
					stream->_writeFloat(rate);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{
						//if(bulletItem->getAbstractItemID() == 28255)
						//	CRCore::notify(CRCore::ALWAYS)<<"crNodeInBulletVolumeMethod roleid="<<hititem->getRoleID()<<std::endl;
						crPlayerServerEventPacket packet;
						crPlayerServerEventPacket::buildRequestPacket(packet,WCH_NodeCollideWithItem,hititem.get(),stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crCloseTargetItemMethod
////
///////////////////////////////////////////
//crCloseTargetItemMethod::crCloseTargetItemMethod():
//m_dt(0.0f),
//m_interval(2.0f),
//m_time(0.0f){}
//crCloseTargetItemMethod::crCloseTargetItemMethod(const crCloseTargetItemMethod& handle):
//crMethod(handle),
//m_dt(0.0f),
//m_interval(handle.m_interval),
//m_time(0.0f)
//{
//}
//void crCloseTargetItemMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((float*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0.0f;
//		}
//		break;
//	}
//}
//void crCloseTargetItemMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_interval = atof(str.c_str());
//		break;
//	}
//}
//void crCloseTargetItemMethod::operator()(crHandle &handle)
//{
//	crData *thisData = m_this->getDataClass();
//	do 
//	{
//		if(!crMyPlayerData::getInstance()->ifItemIsMe(m_this))
//			return;
//		void *param;
//		thisData->getParam(WCHDATA_ItemState,param);
//		unsigned char itemstate = *(unsigned char *)param;
//		if(itemstate < IS_CloseTarget || itemstate > IS_CloseTargetTouch)
//			return;
//		thisData->getParam(WCHDATA_TargetType,param);
//		unsigned char targetType = *(unsigned char *)param;
//		if(!(targetType & Target_Instance))
//			break;
//		ref_ptr<crInstanceItem> targetItem;
//		ref_ptr<crMatrixTransform> targetNode;
//		m_this->clientGetTarget(targetItem,targetNode);
//		if(!targetItem.valid() || targetItem == m_this)
//			break;
//		crVector3 myPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
//		myPos *= crGlobalHandle::gData()->gUnitScale();
//		crVector3 targetPos(targetItem->getPosx(),targetItem->getPosy(),targetItem->getPosz());
//		targetPos *= crGlobalHandle::gData()->gUnitScale();
//		crVector3 targetDir = targetPos - myPos;
//		targetDir[2] = 0.0f;
//		float dist = targetDir.length();
//		thisData->getParam(WCHDATA_FollowDistance,param);
//		float followDistance = *(float *)param;
//		if(dist>followDistance)
//		{
//			m_time += m_dt;
//			if(m_time>m_interval)
//			{//每隔一个时间间隔更新目标点
//				m_time = 0.0f;
//				//thisData->getParam(WCHDATA_TargetPos,param);
//				//crVector3 curTargetPos = *(crVector3 *)param;
//				//curTargetPos[2] = targetPos[2];
//				crInstanceItem::crPathFinder *pathFinder = m_this->getOrCreatePathFinder();
//				if(/* m_this->getOrCreatePathFinder()->getPathStatus()!=crInstanceItem::crPathFinder::Found ||*/
//					pathFinder->isPortPathEmpty() && pathFinder->isWaypointEmpty()/* && (curTargetPos - targetPos).length2() >= 1.0f */)
//				{
//					thisData->inputParam(WCHDATA_TargetPos,&targetPos);
//					crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
//				}
//			}
//			return;
//		}
//		else if(itemstate != IS_CloseTarget)
//		{
//			return;
//		}
//	} while (0);
//	//unsigned char itemstate = IS_Stop;
//	//thisData->inputParam(WCHDATA_ItemState,&itemstate);
//}
/////////////////////////////////////////
//
//crServerCloseTargetItemMethod
//
/////////////////////////////////////////
crServerCloseTargetItemMethod::crServerCloseTargetItemMethod():
m_dt(0.0f),
m_interval(2.0f),
m_time(0.0f){}
crServerCloseTargetItemMethod::crServerCloseTargetItemMethod(const crServerCloseTargetItemMethod& handle):
crMethod(handle),
m_dt(0.0f),
m_interval(handle.m_interval),
m_time(0.0f)
{
}
void crServerCloseTargetItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}
void crServerCloseTargetItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crServerCloseTargetItemMethod::operator()(crHandle &handle)
{
	crData *thisData = m_this->getDataClass();
	do 
	{
		//if(m_this->getItemtype() == crInstanceItem::Role)
		//	return;
		void *param;
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate < IS_CloseTarget || itemstate > IS_CloseTargetTouch)
			return;
		thisData->getParam(WCHDATA_TargetType,param);
		unsigned char targetType = *(unsigned char *)param;
		if(!(targetType & Target_Instance) && !(targetType & Target_StaticNpc)/* && !(targetType & Target_StaticItem)*/)
			break;
		ref_ptr<crInstanceItem> targetItem;
		targetItem = m_this->serverGetTarget();
		if(!targetItem.valid())
		{
			itemstate = IS_Stop;
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			break;
		}
		crVector3 myPos = m_this->getPosition();
		crVector3 targetPos = targetItem->getPosition();
		crVector3 targetDir = targetPos - myPos;
		//targetDir[2] = 0.0f;
		float mindist = m_this->getAttackDistance(/*NULL*/targetItem.get());
		float dist = targetDir.length() - mindist;
		thisData->getParam(WCHDATA_FollowDistance,param);
		float followDistance = *(float *)param;
		if(dist>followDistance)
		{
			m_time += m_dt;
			if(m_time>m_interval)
			{//每隔一个时间间隔更新目标点
				//targetDir.normalize();
				//targetPos[0] -= targetDir[0] * (followDistance+mindist);
				//targetPos[1] -= targetDir[1] * (followDistance+mindist);

				m_time = 0.0f;
				//crInstanceItem::crPathFinder *pathFinder = m_this->getOrCreatePathFinder();
				//if(/* m_this->getOrCreatePathFinder()->getPathStatus()!=crInstanceItem::crPathFinder::Found ||*/
				//	pathFinder->isPortPathEmpty() && pathFinder->isWaypointEmpty() && curTargetPos != targetPos)
				//if((curTargetPos-targetPos).length2()>0.1f)
				//{
					thisData->inputParam(WCHDATA_TargetPos,&targetPos);
					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					if(m_this->getItemtype() == crInstanceItem::Role)
					{
						//send message
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(12);
						//stream->_writeUChar(itemstate);
						stream->_writeVec3(targetPos);
						int playerid = m_this->getID();
						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvCloseTarget,stream.get());
						ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(hitPlayerData.valid())
							sceneServerConductor->getNetManager()->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
						//scene->sendPacketToItemNeighbor(m_this,packet);
					}
					else
					{
						thisData->getParam(WCHDATA_TargetPos,param);
						crVector3 curTargetPos = *(crVector3 *)param;
						curTargetPos[2] = targetPos[2];
						crInstanceItem::crPathFinder *pathFinder = m_this->getOrCreatePathFinder();
						if(/* m_this->getOrCreatePathFinder()->getPathStatus()!=crInstanceItem::crPathFinder::Found ||*/
							pathFinder->isPortPathEmpty() && pathFinder->isWaypointEmpty() && curTargetPos != targetPos)
						{
							crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
							crScene *scene = netCallback->findScene(m_this->getSceneID());
							scene->getPathFindingManager()->addPathFindRequest(m_this);
							//crItemEventPacket packet;
							//crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvCloseTarget,stream.get());
							//scene->sendPacketToItemNeighbor(m_this,packet);
						}
					}
				//}
			}
			return;
		}
		else if(itemstate != IS_CloseTarget)
		{
			return;
		}
	} while (0);
	//unsigned char itemstate = IS_Stop;
	//thisData->inputParam(WCHDATA_ItemState,&itemstate);
}
/////////////////////////////////////////
//
//crRecvCloseTargetMethod
//
/////////////////////////////////////////
crRecvCloseTargetMethod::crRecvCloseTargetMethod():
	m_netType(GameClient_Game){}
crRecvCloseTargetMethod::crRecvCloseTargetMethod(const crRecvCloseTargetMethod& handle):
	crMethod(handle)
{
}
void crRecvCloseTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvCloseTargetMethod::addParam(int i, const std::string& str)
{
}

void crRecvCloseTargetMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			crVector3 targetPos = m_stream->_readVec3();
			crData *data = m_this->getDataClass();
			//void *param;
			//data->getParam(WCHDATA_TargetPos,param);
			//crVector3 curTargetPos = *(crVector3 *)param;
			//curTargetPos[2] = targetPos[2];
			crInstanceItem::crPathFinder *pathFinder = m_this->getOrCreatePathFinder();
			if(/* m_this->getOrCreatePathFinder()->getPathStatus()!=crInstanceItem::crPathFinder::Found ||*/
				pathFinder->isPortPathEmpty() && pathFinder->isWaypointEmpty()/* && curTargetPos != targetPos*/)
			{
				data->inputParam(WCHDATA_TargetPos,&targetPos);
				crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
			}
		}
	}
}
/////////////////////////////////////////
//
//crUseItemAndSendMethod
//
/////////////////////////////////////////
crUseItemAndSendMethod::crUseItemAndSendMethod():m_itemid(0),m_isAboutToUseItem(false){}
crUseItemAndSendMethod::crUseItemAndSendMethod(const crUseItemAndSendMethod& handle):
crMethod(handle),
m_itemid(0),m_isAboutToUseItem(false)
{
}
void crUseItemAndSendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		m_itemid = *(int*)param;
		break;
	case 3:
		m_isAboutToUseItem = *(bool *)param;
		break;
	}
}
void crUseItemAndSendMethod::addParam(int i, const std::string& str)
{
}
void crUseItemAndSendMethod::operator()(crHandle &handle)
{
	unsigned short useResult = UR_None;
	if(m_itemid!=0)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_ItemLoad || itemstate == IS_Dead)
		{
			unsigned char itemstate = IS_Stop;
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			if(m_isAboutToUseItem)
			{
				thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);
			}
			return;
		}
		thisData->getParam(WCHDATA_TargetType,param);
		unsigned char targettype = *(unsigned char *)param;
		crItemChild *itemChild = m_this->findChildItem(m_itemid);
		if(!itemChild || !itemChild->isLoaded())
		{
			if(itemstate != IS_Defend)
			{
				itemstate = IS_Stop;
				thisData->inputParam(WCHDATA_ItemState,&itemstate);
			}
			if(m_isAboutToUseItem)
			{
				thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);
			}
			return;
		}
		crInstanceItem *item = itemChild->getInstanceItem();
		crData *itemData = item->getDataClass();
		itemData->getParam(WCHDATA_TargetType,param);
		unsigned char itemTargetType = *(unsigned char *)param;
		if(targettype & itemTargetType)
		{//对象符合
			crVector3 myPos;
			crVector3 targetPos;
			ref_ptr<crInstanceItem> targetItem;
			myPos = m_this->getPosition();
			//float mindist = 0.0f;
			if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill/* || itemstate == IS_AttackToPos*/)
			{
				thisData->getParam(WCHDATA_MoveToPos,param);
				targetPos = *(crVector3 *)param;
			}
			else
			{
				if(targettype & Target_Instance || targettype & Target_StaticNpc /*|| targettype & Target_StaticItem*/)
				{
					if(crGlobalHandle::isClient())
					{
						ref_ptr<crMatrixTransform> targetNode;
						m_this->clientGetTarget(targetItem,targetNode);
						//if(targetNode.valid())
						//{
						//	targetPos = targetNode->getTrans();
						//}
						//else return;
					}
					else
					{
						targetItem = m_this->serverGetTarget();
					}
					if(targetItem.valid())
					{
						targetPos = targetItem->getPosition();
						//mindist = m_this->getAttackDistance(/*NULL*/targetItem.get());
					}
					else if(!(itemTargetType & Target_Coord))
					{
						unsigned char itemstate = IS_Stop;
						thisData->inputParam(WCHDATA_ItemState,&itemstate);
						if(m_isAboutToUseItem)
						{
							thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);
						}
						return;
					}
					else
					{
						thisData->getParam(WCHDATA_TargetPos,param);
						targetPos = *(crVector3 *)param;
					}
				}
				else
				{
					thisData->getParam(WCHDATA_TargetPos,param);
					targetPos = *(crVector3 *)param;
				}
			}
			crVector3 targetDir = targetPos - myPos;
			//targetDir[2] = 0;//攻击加入高度差影响
			float dist = targetDir.length()/* - mindist*/;
			itemData->getParam(WCHDATA_ItemUseRange,param);
			unsigned short itemUseRange = *((unsigned short*)param);
			float relRange = itemUseRange * crGlobalHandle::gData()->gUnitScale();
			itemData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char *)param;
			float attackdist = 0.0f;
			if(datatype == DT_Attack)
			{
				attackdist = m_this->getAttackDistance(/*NULL*/targetItem.get());
			}
			else
			{//技能默认
				attackdist = 1.0f;
			}
			if(dist<=relRange+attackdist)
			{//在使用范围内
				//m_this->getOrCreatePathFinder()->dirty();
				UseItemParam useItemParam;
				useItemParam.m_user = m_this;
				if(targetItem.valid() && !(itemTargetType & Target_Coord) && (targetItem->getItemtype()==crInstanceItem::Npc || targetItem->getItemtype()==crInstanceItem::Role))
					useItemParam.m_target = targetItem;
				item->doEvent(MAKEINT64(WCH_UseItem,crGlobalHandle::isClient()?UT_Client:UT_Server),MAKEINT64(&useItemParam,&useResult));
				if(useResult == UR_Succeed)
				{
					if(m_isAboutToUseItem) 
					{
						thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);//
						//if(crGlobalHandle::isClient())
						//{
						//	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
						//	{
						//		crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
						//		bindview->showCursor("Default");
						//	}
						//}
					}
					unsigned char itemstate = IS_UseItem;
					thisData->inputParam(WCHDATA_ItemState,&itemstate);
					//sendpacket
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(/*26*/30);
					if(itemTargetType & Target_Coord)
					{
						targettype = Target_Coord;
					}
					stream->_writeUChar(targettype);
					if(targettype & Target_Instance || targettype & Target_StaticNpc/* || targettype & Target_StaticItem*/)
					{
						thisData->getParam(WCHDATA_TargetID,param);
						int targetID = *(int *)param;
						stream->_writeInt(targetID);//4
						if(targettype & Target_Role)
						{
							thisData->getParam(WCHDATA_TargetRoleID,param);
							int targetRoleID = *(int *)param;
							stream->_writeInt(targetRoleID);//4
						}
					}
					else
					{
						stream->_writeVec3(targetPos);//12
					}

					stream->_writeUChar(itemstate);
					stream->_writeInt(m_itemid);
					if(crGlobalHandle::isClient())
					{
						stream->_writeInt(m_this->getPosx());
						stream->_writeInt(m_this->getPosy());
						stream->_writeFloat(relRange);
					}
					/////////////去除
					//thisData->getParam(WCHDATA_RTHP,param);
					//float rthp = *((float*)param);
					//stream->_writeFloat(rthp);
					//thisData->getParam(WCHDATA_RTMP,param);
					//float rtmp = *((float*)param);
					//stream->_writeFloat(rtmp);
                    
					//float followDistance = relRange - crGlobalHandle::gData()->gFollowDelta();
					//stream->_writeFloat(followDistance);

					//turn to target
					targetDir[2] = 0.0f;
					targetDir.normalize();

					thisData->getParam(WCHDATA_GuiseState,param);
					unsigned int guiseState = *(unsigned int *)param;
					if(!(guiseState & GS_Static) && !(guiseState & GS_StaticNoneBlock)) 
						m_this->setDir(targetDir);

					if(crGlobalHandle::isClient())
					{
						if(!(guiseState & GS_Static) && !(guiseState & GS_StaticNoneBlock))
						{
							crMatrixTransform *thisNode = dynamic_cast<crMatrixTransform *>(m_this->getRelNode());
							m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(thisNode,crMatterObject::MD_RotMatrix));//转向拾取点
						}
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						if(netConductor)
						{
							crPlayerEventPacket packet;
							crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_NetControl,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
					else
					{
						crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
						crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
						crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						crItemEventPacket packet;
						crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_NetControl,stream.get());
						callback->findScene(m_this->getSceneID())->sendPacketToItemNeighbor(m_this,packet);
					}
					//itemstate = IS_Stop;
					//thisData->inputParam(WCHDATA_ItemState,&itemstate);
				}
				else
				{
					unsigned char itemstate = IS_Stop;
					thisData->inputParam(WCHDATA_ItemState,&itemstate);

					if(m_isAboutToUseItem)
					{
						thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);//
						//if(crGlobalHandle::isClient())
						//{
						//	if(m_this == crMyPlayerData::getInstance()->getCurrentRole())
						//	{
						//		crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
						//		bindview->showCursor("Default");
						//	}
						//}
					}
				}
			}
			else if(itemstate != IS_Defend)
			{
				if(targetItem.valid())
				{//超出技能使用范围，则向目标靠近
					unsigned char newitemstate = m_isAboutToUseItem?IS_CloseTargetUseSkill:IS_CloseTarget;
					if(newitemstate != itemstate)
					{
						thisData->inputParam(WCHDATA_ItemState,&newitemstate);
						float followDistance = relRange - crGlobalHandle::gData()->gFollowDelta();
						thisData->inputParam(WCHDATA_FollowDistance,&followDistance);
					}
					useResult = UR_OverRange;
				}
				else if(crGlobalHandle::isClient())
				{
					unsigned char newitemstate = m_isAboutToUseItem?IS_MoveToUseSkill:IS_AttackToPos;
					if(newitemstate != itemstate)
					{
						thisData->inputParam(WCHDATA_ItemState,&newitemstate);
						float followDistance = relRange - crGlobalHandle::gData()->gFollowDelta();
						thisData->inputParam(WCHDATA_FollowDistance,&followDistance);
						crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
					}
				}
			}

		}
	}
	handle.outputParam(3,&useResult);
}
///////////////////////////////////////////
////
////crNetControl2Method
////
///////////////////////////////////////////
//crNetControl2Method::crNetControl2Method():
//m_netType(GameClient_Game){}
//crNetControl2Method::crNetControl2Method(const crNetControl2Method& handle):
//crMethod(handle)
//{
//}
//void crNetControl2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crNetControl2Method::addParam(int i, const std::string& str)
//{
//}
//
//void crNetControl2Method::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		void *param;
//		crData *thisData = m_this->getDataClass();
//		thisData->getParam(WCHDATA_ItemState,param);
//		unsigned char itemstate = *(unsigned char *)param;
//		if(itemstate == IS_ItemLoad || itemstate == IS_Dead)
//		{
//			return;
//		}
//
//		unsigned char targetType = m_stream->_readUChar();
//		int targetid = 0;
//		if(targetType & Target_Instance)
//			targetid = m_stream->_readInt();
//		if(targetType & Target_Role)
//		{
//			int targetroleid = m_stream->_readInt();
//			thisData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
//		}
//		itemstate = m_stream->_readUChar();
//		crVector3 targetPosition;
//		bool hastargetpos = false;
//		if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill || itemstate == IS_AttackToPos)
//		{
//			targetPosition = m_stream->_readVec3();
//			thisData->inputParam(WCHDATA_MoveToPos,&targetPosition);
//			thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//			hastargetpos = true;
//		}
//		if(!m_stream->eof())
//		{
//			float followDistance = m_stream->_readFloat();
//			thisData->inputParam(WCHDATA_FollowDistance,&followDistance);
//		}
//		thisData->inputParam(WCHDATA_ItemState,&itemstate);
//		thisData->inputParam(WCHDATA_TargetType,&targetType);
//		thisData->inputParam(WCHDATA_TargetID,&targetid);
//		ref_ptr<crInstanceItem> targetItem;
//		if(m_netType == GameClient_Game)
//		{
//			ref_ptr<crMatrixTransform> targetNode;
//			m_this->clientGetTarget(targetItem,targetNode);
//			//thisData->inputParam(WCHDATA_TargetNode,targetNode.get());
//			if(!hastargetpos && targetItem.valid())
//			{
//				targetPosition = targetItem->getPosition();
//				thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//			}
//		}
//		else if(m_netType == SceneServer)
//		{
//			if(!hastargetpos)
//			{
//				targetItem = m_this->serverGetTarget();
//				if(targetItem.valid())
//				{
//					targetPosition = targetItem->getPosition();
//					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crGetItemRTDataMethod
//
/////////////////////////////////////////
crGetItemRTDataMethod::crGetItemRTDataMethod(){}
crGetItemRTDataMethod::crGetItemRTDataMethod(const crGetItemRTDataMethod& handle):
crMethod(handle)
{
}
void crGetItemRTDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_outstream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_outstream = (CRCore::ref_ptr<crStreamBuf> *)(LOINT64(param64));
		}
		else
		{
			m_outstream = NULL;
		}
		break;
	}
}
void crGetItemRTDataMethod::addParam(int i, const std::string& str)
{
}
void crGetItemRTDataMethod::operator()(crHandle &handle)
{
	if(m_outstream)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
        
		*m_outstream = new crStreamBuf;
		if(m_this->getItemtype() == crInstanceItem::Role)
			(*m_outstream)->createBuf(128);
		else
			(*m_outstream)->createBuf(55);
		(*m_outstream)->_writeFloat(m_this->getPosx());
		(*m_outstream)->_writeFloat(m_this->getPosy());
		//(*m_outstream)->_writeInt(m_this->getPosz());
		(*m_outstream)->_writeFloat(m_this->getDirx());
		(*m_outstream)->_writeFloat(m_this->getDiry());
		(*m_outstream)->_writeFloat(m_this->getDirz());//24
		if(m_this->getItemtype()==crInstanceItem::Npc || m_this->getItemtype()==crInstanceItem::Role)
		{
			thisData->getParam(WCHDATA_TargetType,param);
			unsigned char targetType = *(unsigned char*)param;
            (*m_outstream)->_writeUChar(targetType);//1
			if(targetType & Target_Instance || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
			{
				thisData->getParam(WCHDATA_TargetID,param);
				int targetid = *(int*)param;
				(*m_outstream)->_writeInt(targetid);
				if(targetType & Target_Role)
				{
					thisData->getParam(WCHDATA_TargetRoleID,param);
					int targetroleid = *(int*)param;
					(*m_outstream)->_writeInt(targetroleid);
				}
			}
			else
			{
				thisData->getParam(WCHDATA_TargetPos,param);
				crVector3 targetPos = *(crVector3*)param;
				(*m_outstream)->_writeVec3(targetPos);//12
			}
			thisData->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char*)param;
			(*m_outstream)->_writeUChar(itemstate);//1
			thisData->getParam(WCHDATA_GuiseState,param);
			unsigned int guisestate = *(unsigned int*)param;
			(*m_outstream)->_writeUInt(guisestate);//1

			//thisData->getParam(WCHDATA_FollowDistance,param);
			//float followDistance = *(float*)param;
			//(*m_outstream)->_writeFloat(followDistance);//4
            
			thisData->getParam(WCHDATA_RTHP,param);
			float rthp = *((float*)param);
			(*m_outstream)->_writeFloat(rthp);//4
			thisData->getParam(WCHDATA_RTMP,param);
			float rtmp = *((float*)param);
			(*m_outstream)->_writeFloat(rtmp);//4

			if(m_this->getItemtype() == crInstanceItem::Role)
			{//如果是玩家，还需要同步一些额外的信息
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_QuickList,param);
				QuickList *quickList = (QuickList *)param;
				(*m_outstream)->_writeUChar(quickList->size());
				for( QuickList::iterator itr = quickList->begin();
					itr != quickList->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				thisData->getParam(WCHDATA_EquipOnMap,param);
				EquipOnMap *equipOnMap = (EquipOnMap *)param;
				(*m_outstream)->_writeUChar(equipOnMap->size());
				for( EquipOnMap::iterator itr = equipOnMap->begin();
					itr != equipOnMap->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				//Tank
				thisData->getParam(WCHDATA_AttackMap,param);
				AttackMap *attackMap = (AttackMap *)param;
				(*m_outstream)->_writeUChar(attackMap->size());
				for( AttackMap::iterator itr = attackMap->begin();
					itr != attackMap->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				thisData->getParam(WCHDATA_BackPackMap,param);
				BackPackMap *backPackMap = (BackPackMap *)param;
				(*m_outstream)->_writeUChar(backPackMap->size());
				for( BackPackMap::iterator itr = backPackMap->begin();
					itr != backPackMap->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crGetItemChildDataMethod
//
/////////////////////////////////////////
crGetItemChildDataMethod::crGetItemChildDataMethod():m_itemid(0){}
crGetItemChildDataMethod::crGetItemChildDataMethod(const crGetItemChildDataMethod& handle):
crMethod(handle),
m_itemid(0)
{
}
void crGetItemChildDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_outstream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_outstream = (CRCore::ref_ptr<crStreamBuf> *)(LOINT64(param64));
			m_itemid = HIINT64(param64);
		}
		else
		{
			m_outstream = NULL;
		}
		break;
	}
}
void crGetItemChildDataMethod::addParam(int i, const std::string& str)
{
}
void crGetItemChildDataMethod::operator()(crHandle &handle)
{
	if(m_outstream)
	{
		crItemChild *itemChild = m_this->findChildItem(m_itemid);
		if(itemChild && itemChild->isLoaded())
		{
			crInstanceItem *equip = itemChild->getInstanceItem();
			int count = 0;
			std::vector< ref_ptr<crStreamBuf> > BufVec;

			(*m_outstream) = new crStreamBuf;
			(*m_outstream)->createBuf(MTUBUFFERSIZE);//MAXBUFFERSIZE-12);
			(*m_outstream)->_writeInt(itemChild->getItemChildID());
			writeItem(equip,(*m_outstream),BufVec,count,NetStream);
			if(BufVec.size()>0)
			{
				CRCore::notify(CRCore::ALWAYS)<<"crGetItemChildDataMethod溢出，需要采用DataStream方式传输"<<std::endl;
			}
			//else
			//{
			//	(*m_outstream) = BufVec[0].get();
			//}
		}
	}
}
/////////////////////////////////////////
//
//crNpcDeadMethod
//
/////////////////////////////////////////
crNpcDeadMethod::crNpcDeadMethod(){}
crNpcDeadMethod::crNpcDeadMethod(const crNpcDeadMethod& handle):
crMethod(handle)
{
}
void crNpcDeadMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_killerItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_killerItem = (crInstanceItem*)(LOINT64(param64));
		}
		else
		{
			m_killerItem = NULL;
		}
		break;
	}
}
void crNpcDeadMethod::addParam(int i, const std::string& str)
{
}
void crNpcDeadMethod::operator()(crHandle &handle)
{
	if(m_killerItem.valid())
	{
        void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_ExpToKiller,param);
		short expToKiller = *(short *)param;
		thisData->getParam(WCHDATA_GoldToKiller,param);
		short goldToKiller = *(short*)param;
		if(expToKiller!=0) m_killerItem->doEvent(WCH_AddExperience,MAKEINT64(expToKiller,NULL));
		if(goldToKiller!=0) m_killerItem->doEvent(WCH_AddGold,MAKEINT64(goldToKiller,NULL));

		////物品掉落
		//if(m_killerItem->getItemtype() == crInstanceItem::Role)
		//{
		//	int droppedItem = 0;
		//	thisData->excHandle(MAKEINT64(WCH_LockData,1));
		//	thisData->getParam(WCHDATA_ItemDropMap,param);
		//	ItemDropMap* itemDropMap = (ItemDropMap*)param;
		//	if(itemDropMap && !itemDropMap->empty())
		//	{
		//		CRCore::rangef frnd(0.0f,1.0f);
		//		float rnd;
		//		for( ItemDropMap::iterator itr = itemDropMap->begin();
		//			itr != itemDropMap->end();
		//			++itr )
		//		{
		//			rnd = frnd.get_random();
		//			if(rnd<itr->second)
		//			{
		//				droppedItem = itr->first;
		//				break;
		//			}
		//		}
		//	}
		//	thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//	if(droppedItem>0)
		//	{
		//		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		//		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		//		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		//		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());

		//		ref_ptr<crInstanceItem> item = new crInstanceItem;
		//		item->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
		//		//item->setAbstractItemID(droppedItem);
		//		item->setSceneID(m_this->getSceneID());
		//		item->setRoomID(m_this->getRoomID());
		//		item->setLayerID(m_this->getLayerID());
		//		item->setPosxy(m_this->getPosx(),m_this->getPosy());
		//		//CRCore::notify(CRCore::ALWAYS)<<"crNpcDeadMethod DroppedItem "<<droppedItem<<" itemid = "<<item->getInstanceItemID()<<std::endl;
		//		int belongid = m_killerItem->getID();
		//		crAbstractItem *aitem = crGlobalHandle::getInstance()->findAbstractItem(droppedItem);
		//		if(aitem)
		//		{
		//			item->setAbstractItem(aitem);
		//			item->setItemtype(crInstanceItem::instanceitem);
		//			crData *data = CREncapsulation::loadData(aitem->getScript());
		//			if(data)
		//			{
		//				item->setDataClass(data);
		//				data->excHandle(MAKEINT64(WCH_InitData,item.get()));

		//				void *param;
		//				//crData *data = item->getDataClass();
		//				data->getParam(WCHDATA_Zoffset,param);
		//				short zoffset = *(short*)param;
		//				item->setZoffset(zoffset);//
		//				data->inputParam(WCHDATA_BelongPlayerID,&belongid);
		//				float posz = scene->getPosZ(item->getLayerID(),item->getPosx() * crGlobalHandle::gData()->gUnitScale(),item->getPosy() * crGlobalHandle::gData()->gUnitScale(), item->getZoffset() * crGlobalHandle::gData()->gUnitScale());
		//				item->setPosz(posz / crGlobalHandle::gData()->gUnitScale());
		//				//item->getDataClass()->excHandle(MAKEINT64(WCH_CheckItemData,item.get()));
		//				//CRCore::notify(CRCore::ALWAYS)<<"FindAbstractItem DroppedItem "<<item->getPosx()<<","<<item->getPosy()<<std::endl;
		//				scene->insertSceneItem(item.get());
		//			}
		//		}
		//		else
		//		{
		//			crQueryAbstractItemPacket packet;
		//			crQueryAbstractItemPacket::buildRequestPacket(packet,droppedItem,item.get(),belongid);
		//			crNetConductor *gameServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
		//			gameServerConductor->getNetManager()->sendPacket("all",packet);
		//		}
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crAddExperienceMethod
//
/////////////////////////////////////////
crAddExperienceMethod::crAddExperienceMethod():m_experience(0){}
crAddExperienceMethod::crAddExperienceMethod(const crAddExperienceMethod& handle):
crMethod(handle),
m_experience(0)
{
}
void crAddExperienceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_experience = LOINT64(param64);
		}
		else
		{
			m_experience = 0;
		}
		break;
	}
}
void crAddExperienceMethod::addParam(int i, const std::string& str)
{
}
void crAddExperienceMethod::operator()(crHandle &handle)
{
	if(m_experience != 0)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Experience,param);
		int* experience = (int *)param;
		*experience += m_experience;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		m_this->doEvent(WCH_LvUp);
        //send to m_this，不需要发送给其他玩家
		if(m_this->getItemtype() == crInstanceItem::Role)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			int playerid = m_this->getID();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(*experience);
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvExperience,stream.get());
				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crAddExperience2Method
//
/////////////////////////////////////////
crAddExperience2Method::crAddExperience2Method():m_experience(0){}
crAddExperience2Method::crAddExperience2Method(const crAddExperience2Method& handle):
	crMethod(handle),
	m_experience(0)
{
}
void crAddExperience2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_experience = LOINT64(param64);
		}
		else
		{
			m_experience = 0;
		}
		break;
	}
}
void crAddExperience2Method::addParam(int i, const std::string& str)
{
}
void crAddExperience2Method::operator()(crHandle &handle)
{
	if(m_experience != 0)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Experience,param);
		int* experience = (int *)param;
		*experience += m_experience;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//m_this->doEvent(WCH_LvUp);
		//send to m_this，不需要发送给其他玩家
		int playerid = m_this->getPlayerID();
		if(playerid>0)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(*experience);
				crRoomPlayerEventPacket packet;
				crRoomPlayerEventPacket::buildRequestPacket(packet,playerid,playerid,WCH_RecvExperience,stream.get());
				crNetConductor *gameServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
				gameServerConductor->getNetManager()->sendPacket("all",packet);
				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crAddGoldMethod
//
/////////////////////////////////////////
crAddGoldMethod::crAddGoldMethod():m_gold(0){}
crAddGoldMethod::crAddGoldMethod(const crAddGoldMethod& handle):
crMethod(handle),
m_gold(0)
{
}
void crAddGoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gold = LOINT64(param64);
		}
		else
		{
			m_gold = 0;
		}
		break;
	}
}
void crAddGoldMethod::addParam(int i, const std::string& str)
{
}
void crAddGoldMethod::operator()(crHandle &handle)
{
	if(m_gold != 0)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Gold,param);
		int* gold = (int *)param;
		*gold += m_gold;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//send to m_this,不需要发送给其他玩家
		if(m_this->getItemtype() == crInstanceItem::Role)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			int playerid = m_this->getID();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(*gold);
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvGold,stream.get());
				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crAddGold2Method
//
/////////////////////////////////////////
crAddGold2Method::crAddGold2Method():m_gold(0){}
crAddGold2Method::crAddGold2Method(const crAddGold2Method& handle):
	crMethod(handle),
	m_gold(0)
{
}
void crAddGold2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gold = LOINT64(param64);
		}
		else
		{
			m_gold = 0;
		}
		break;
	}
}
void crAddGold2Method::addParam(int i, const std::string& str)
{
}
void crAddGold2Method::operator()(crHandle &handle)
{
	if(m_gold != 0)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Gold,param);
		int* gold = (int *)param;
		*gold += m_gold;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//send to m_this,不需要发送给其他玩家
		int playerid = m_this->getPlayerID();
		if(playerid>0)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(*gold);
				crRoomPlayerEventPacket packet;
				crRoomPlayerEventPacket::buildRequestPacket(packet,playerid,playerid,WCH_RecvGold,stream.get());
				crNetConductor *gameServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
				gameServerConductor->getNetManager()->sendPacket("all",packet);
				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvExperienceMethod
//
/////////////////////////////////////////
crRecvExperienceMethod::crRecvExperienceMethod(){}
crRecvExperienceMethod::crRecvExperienceMethod(const crRecvExperienceMethod& handle):
crMethod(handle)
{
}
void crRecvExperienceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvExperienceMethod::addParam(int i, const std::string& str)
{
}

void crRecvExperienceMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvExperienceMethod "<<std::endl;
		int experience = m_stream->_readInt();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Experience,param);
		int* curExperience = (int *)param;
		int changevalue = experience - *curExperience;
		*curExperience = experience;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		//客户端显示
		crNode *bot = m_this->getRelNode();
		if(bot)
		{
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvExperience,MAKEINT32(changevalue,-1)));
		}
	}
}
/////////////////////////////////////////
//
//crRecvExperience2Method
//
/////////////////////////////////////////
crRecvExperience2Method::crRecvExperience2Method(){}
crRecvExperience2Method::crRecvExperience2Method(const crRecvExperience2Method& handle):
	crMethod(handle)
{
}
void crRecvExperience2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvExperience2Method::addParam(int i, const std::string& str)
{
}

void crRecvExperience2Method::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvExperienceMethod "<<std::endl;
		int roleid = m_stream->_readInt();
		short experience = m_stream->_readShort();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Experience,param);
		short* curExperience = (short *)param;
		short changevalue = experience - *curExperience;
		*curExperience = experience;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		//客户端显示
		crNode *bot = crMyPlayerData::getInstance()->getRole(roleid)->getRelNode();
		if(bot)
		{
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvExperience,MAKEINT32(changevalue,-1)));
		}
	}
}
/////////////////////////////////////////
//
//crRecvGoldMethod
//
/////////////////////////////////////////
crRecvGoldMethod::crRecvGoldMethod(){}
crRecvGoldMethod::crRecvGoldMethod(const crRecvGoldMethod& handle):
crMethod(handle)
{
}
void crRecvGoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvGoldMethod::addParam(int i, const std::string& str)
{
}
void crRecvGoldMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvGoldMethod "<<std::endl;
		int gold = m_stream->_readInt();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Gold,param);
		int* curGold = (int *)param;
		int changevalue = gold - *curGold;
		*curGold = gold;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		//客户端显示
		crNode *bot = m_this->getRelNode();
		if(bot)
		{
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvGold,MAKEINT32(changevalue,-1)));
		}
	}
}
/////////////////////////////////////////
//
//crRecvGold2Method
//
/////////////////////////////////////////
crRecvGold2Method::crRecvGold2Method(){}
crRecvGold2Method::crRecvGold2Method(const crRecvGold2Method& handle):
	crMethod(handle)
{
}
void crRecvGold2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvGold2Method::addParam(int i, const std::string& str)
{
}
void crRecvGold2Method::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvGoldMethod "<<std::endl;
		int roleid = m_stream->_readInt();
		short gold = m_stream->_readInt();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_Gold,param);
		short* curGold = (short *)param;
		short changevalue = gold - *curGold;
		*curGold = gold;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		//客户端显示
		crNode *bot = crMyPlayerData::getInstance()->getRole(roleid)->getRelNode();
		if(bot)
		{
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvGold,MAKEINT32(changevalue,-1)));
		}
	}
}
/////////////////////////////////////////
//
//crLvUpFormula1Method
//
/////////////////////////////////////////
crLvUpFormula1Method::crLvUpFormula1Method()
{
	m_factor.set(10,40,50);
	m_attrPointGrow = 5;
	m_skillPointGrow = 2;
}
crLvUpFormula1Method::crLvUpFormula1Method(const crLvUpFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_attrPointGrow(handle.m_attrPointGrow),
m_skillPointGrow(handle.m_skillPointGrow)
{
}
void crLvUpFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crLvUpFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	case 1:
		m_attrPointGrow = (unsigned char)(atoi(str.c_str()));
		break;
	case 2:
		m_skillPointGrow = (unsigned char)(atoi(str.c_str()));
		break;
	}
}
void crLvUpFormula1Method::operator()(crHandle &handle)
{
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_Experience,param);
		int experience = *(int *)param;
		thisData->getParam(WCHDATA_Level,param);
		unsigned char lv = *(unsigned char *)param;
		int ilv = (int)lv;
		int nextlvexp = 0;
		while (nextlvexp<=experience)
		{
			ilv++;
			nextlvexp = ilv*ilv*ilv*m_factor[0]+ilv*m_factor[1]+m_factor[2];
		}
		ilv--;
		unsigned char nlv = (unsigned char)ilv;
		if(nlv>lv)
		{
			thisData->inputParam(WCHDATA_Level,&nlv);

			unsigned char dt = nlv - lv;
			unsigned char gainAttrPoint = dt * m_attrPointGrow;
			unsigned char gainSkillPoint = dt * m_skillPointGrow;
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_AttrPoint,param);
			unsigned short* curAttrPoint = (unsigned short *)param;
			*curAttrPoint += gainAttrPoint;
			thisData->getParam(WCHDATA_SkillPoint,param);
			unsigned short* curSkillPoint = (unsigned short *)param;
			*curSkillPoint += gainSkillPoint;
			thisData->excHandle(MAKEINT64(WCH_LockData,0));

			//set hp and mp
			float maxhp = 0;
			float maxmp = 0;
			m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
			m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
			thisData->inputParam(WCHDATA_RTHP,&maxhp);
			thisData->inputParam(WCHDATA_RTMP,&maxmp);

			//send to client及附近
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(13);
			stream->_writeUChar(nlv);
			stream->_writeUShort(*curAttrPoint);
		    stream->_writeUShort(*curSkillPoint);
			stream->_writeFloat(maxhp);
			stream->_writeFloat(maxmp);
			crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			crScene *scene = callback->findScene(m_this->getSceneID());
			if(m_this->getItemtype() == crInstanceItem::Role)
			{
				int playerid = m_this->getID();
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvLvUp,stream.get());
				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid())
				{
					sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				scene->sendPacketToItemNeighbor(m_this,packet);
			}
			else
			{
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvLvUp,stream.get());
				scene->sendPacketToItemNeighbor(m_this,packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvLvUpMethod
//
/////////////////////////////////////////
crRecvLvUpMethod::crRecvLvUpMethod(){}
crRecvLvUpMethod::crRecvLvUpMethod(const crRecvLvUpMethod& handle):
crMethod(handle)
{
}
void crRecvLvUpMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvLvUpMethod::addParam(int i, const std::string& str)
{
}
void crRecvLvUpMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		unsigned char newlv = m_stream->_readUChar();
		crData *thisData = m_this->getDataClass();
		thisData->inputParam(WCHDATA_Level,&newlv);
		unsigned short attrPoint = m_stream->_readUShort();
		unsigned short skillPoint = m_stream->_readUShort();
		thisData->inputParam(WCHDATA_AttrPoint,&attrPoint);
		thisData->inputParam(WCHDATA_SkillPoint,&skillPoint);

		float maxhp = m_stream->_readFloat();
		float maxmp = m_stream->_readFloat();
		thisData->inputParam(WCHDATA_RTHP,&maxhp);
		thisData->inputParam(WCHDATA_RTMP,&maxmp);

		//客户端显示
		crNode *bot = m_this->getRelNode();
		if(bot)
		{
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvLvUp,MAKEINT32(newlv,-1)));
		}
	}
}
/////////////////////////////////////////
//
//crDeadEventMethod
//
/////////////////////////////////////////
crDeadEventMethod::crDeadEventMethod():
m_corpseInterval(2.0f),
m_reliveInterval(10.0f),
m_dt(0.0f),
m_timer(0.0f),
m_step(0){}
crDeadEventMethod::crDeadEventMethod(const crDeadEventMethod& handle):
crMethod(handle),
m_corpseInterval(handle.m_corpseInterval),
m_reliveInterval(handle.m_reliveInterval),
m_dt(0.0f),
m_timer(0.0f),
m_step(0)
{
}
void crDeadEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crDeadEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_corpseInterval = atof(str.c_str());
		break;
	case 1:
		m_reliveInterval = atof(str.c_str());
		break;
	}
}

void crDeadEventMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f)
	{
		crData *thisData = m_this->getDataClass();
		void *param;
		thisData->getParam(WCHDATA_GuiseState,param);
		unsigned int guiseState = *(unsigned int *)param;
		if(m_step == 0)
		{
			if(!(guiseState & GS_UnVisiable) && !(guiseState & GS_StaticUnVisiable))
			{
				m_timer += m_dt;
				if(m_timer > m_corpseInterval)
				{
					m_step = 1;
					m_timer = 0.0f;

					if(guiseState & GS_Static || guiseState & GS_StaticNoneBlock)
						guiseState = GS_StaticUnVisiable;
					else
						guiseState = GS_UnVisiable;
					//send to client
					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					crNetManager *netManager = sceneServerConductor->getNetManager();
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeUInt(guiseState);
					crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					crScene *scene = netCallback->findScene(m_this->getSceneID());
					if(m_this->getItemtype() == crInstanceItem::Role)
					{
						int playerid = m_this->getID();
						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvGuiseState,stream.get());
						ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(m_this->getID()));
						if(playerData.valid())
						{
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							//playerData->clearInRanges();
						}
						scene->sendPacketToItemNeighbor(m_this,packet);
					}
					else
					{
						crItemEventPacket packet;
						crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvGuiseState,stream.get());
						scene->sendPacketToItemNeighbor(m_this,packet);
					}
					thisData->inputParam(WCHDATA_GuiseState, &guiseState);
					thisData->inputParam(WCHDATA_ControllerFlg,NULL);
					scene->itemDead(m_this);
				}
			}
		}
		else if(m_step == 1 && m_reliveInterval>0.0f)
		{
			m_timer += m_dt;
			if(m_timer>m_reliveInterval)
			{
				m_step = 0;
				m_timer = 0.0f;
				//m_corpseover = false;

				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				crScene *scene = netCallback->findScene(m_this->getSceneID());

				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_InitData,m_this));

				//unsigned char itemstate = IS_Relive;
				//thisData->inputParam(WCHDATA_ItemState, &itemstate);
				//float rt = 0;
				//m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&rt,NULL));
				//thisData->inputParam(WCHDATA_RTHP,&rt);
				//m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&rt,NULL));
				//thisData->inputParam(WCHDATA_RTMP,&rt);

				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_PatrolPointVec,param);
				PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
				if(patrolPointVec && !patrolPointVec->empty())
				{
					char idx;
					thisData->getParam(WCHDATA_PatrolLoopMode,param);
					unsigned char loopmode = *(unsigned char *)param;
					if(loopmode == PL_NoLoop)
					{
						idx = 0;
					}
					else
					{
						int count = patrolPointVec->size();
						idx = rangei(0,count).get_random();
						thisData->inputParam(WCHDATA_PatrolIndex,&idx);
					}
					crVector2i coord = (*patrolPointVec)[idx];
					float scale = crGlobalHandle::gData()->gUnitScale();
					float coordz = scene->getPosZ(m_this->getLayerID(), (float)coord[0] * scale, (float)coord[1] * scale, (float)(m_this->getZoffset())*scale);
					m_this->setPosxy(coord[0],coord[1]);
					m_this->setPosz(coordz / scale);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
				crRoom *room = netCallback->findRoom(m_this->getRoomID());
				if(room && room->getGameRunning())
				{
					thisData->getParam(WCHDATA_Camp,param);
					unsigned char camp = *(unsigned char *)param;
					crSightInfo *attackSightInfo = room->getOrCreateSightInfo(camp);
					m_this->setSightInfo(attackSightInfo);
				}
				scene->itemRelive(m_this);
			}
		}
		else// if(guiseState != GS_UnVisiable && guiseState != GS_StaticUnVisiable)
		{
			m_step = 0;
			m_timer = 0.0f;
		}
	}
}
/////////////////////////////////////////
//
//crSinkMethod
//
/////////////////////////////////////////
crSinkMethod::crSinkMethod():
m_sinkSpeed(-1.0f){}
crSinkMethod::crSinkMethod(const crSinkMethod& handle):
crMethod(handle),
m_sinkSpeed(handle.m_sinkSpeed)
{
}
void crSinkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	}
}
void crSinkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sinkSpeed = atof(str.c_str());
		break;
	}
}
void crSinkMethod::operator()(crHandle &handle)
{
	{
		m_this->setVelocity(crVector3(0.0f,0.0f,m_sinkSpeed));
	}
}
/////////////////////////////////////////
//
//crResetBotMethod
//
/////////////////////////////////////////
crResetBotMethod::crResetBotMethod(){}
crResetBotMethod::crResetBotMethod(const crResetBotMethod& handle):
crMethod(handle)
{
}
void crResetBotMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crViewMatterObject*)param;
		break;
	}
}
void crResetBotMethod::addParam(int i, const std::string& str)
{
}
void crResetBotMethod::operator()(crHandle &handle)
{
	{
		m_this->setVelocity(crVector3(0.0f,0.0f,0.0f));
		m_this->setAcceleration(crVector3(0.0f,0.0f,0.0f));
		m_this->setHPR(crVector3(0.0f,0.0f,0.0f));
	}
}
/////////////////////////////////////////
//
//crUIRelivePlayerMethod
//
/////////////////////////////////////////
crUIRelivePlayerMethod::crUIRelivePlayerMethod():
m_reliveFlg(0){}
crUIRelivePlayerMethod::crUIRelivePlayerMethod(const crUIRelivePlayerMethod& handle):
crMethod(handle),
m_reliveFlg(handle.m_reliveFlg)
{
}
void crUIRelivePlayerMethod::inputParam(int i, void *param)
{
}
void crUIRelivePlayerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_reliveFlg = (unsigned char)(atoi(str.c_str()));
		break;
	}
}
void crUIRelivePlayerMethod::operator()(crHandle &handle)
{
	crRole *player = crMyPlayerData::getInstance()->getCurrentRole();
	crData *thisData = player->getDataClass();
	thisData->excHandle(MAKEINT64(WCH_InitData,player));

	unsigned char itemstate = IS_Stop;
	thisData->inputParam(WCHDATA_ItemState, &itemstate);
	unsigned int guisestate = GS_Normal;
	thisData->inputParam(WCHDATA_GuiseState, &guisestate);
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(1);
		//stream->_writeUChar(player->getItemtype());
		//stream->_writeInt(player->getPlayerID());
		stream->_writeUChar(m_reliveFlg);
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RelivePlayer,player,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
	//crViewMatterObject *bot = crMyPlayerData::getInstance()->getNPC()->getNPCBot();
	//bot->doEvent(MAKEINT64(WCH_AITASK,4),MAKEINT64(MAKEINT32(WCHAI_Begin,WCHAI_SetCPToBot),NULL));
}
/////////////////////////////////////////
//
//crRecvRelivePlayerMethod
//
/////////////////////////////////////////
crRecvRelivePlayerMethod::crRecvRelivePlayerMethod():
m_netType(GameClient_Game){}
crRecvRelivePlayerMethod::crRecvRelivePlayerMethod(const crRecvRelivePlayerMethod& handle):
crMethod(handle),
m_netType(handle.m_netType)
{
}
void crRecvRelivePlayerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvRelivePlayerMethod::addParam(int i, const std::string& str)
{
}

void crRecvRelivePlayerMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_InitData,m_this));
		unsigned char itemstate = IS_Stop;
		thisData->inputParam(WCHDATA_ItemState, &itemstate);
		unsigned int guisestate = GS_Normal;
		thisData->inputParam(WCHDATA_GuiseState, &guisestate);
		if(m_netType == SceneServer)
		{
			float maxhp = 0;
			float maxmp = 0;
			m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
			m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
			unsigned char reliveFlg = m_stream->_readUChar();

			int playerid = m_this->getPlayerID();
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData>playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				if(reliveFlg == 0)
				{//原地复活
					maxhp *= 0.5f;
					maxmp *= 0.5f;
					thisData->inputParam(WCHDATA_RTHP,&maxhp);
					thisData->inputParam(WCHDATA_RTMP,&maxmp);
				}
				else if(reliveFlg == 1)
				{//回城复活
					maxhp *= 0.5f;
					maxmp *= 0.5f;
					thisData->inputParam(WCHDATA_RTHP,&maxhp);
					thisData->inputParam(WCHDATA_RTMP,&maxmp);
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					CRNetApp::crScene *scene = callback->findScene(m_this->getSceneID());
					if(scene)
					{
						int index = -1;
						int roomid = m_this->getRoomID();
						if(roomid!=0)
						{
							crRoom *room = callback->findRoom(roomid);
							if(room)
								index = room->getBirthPointIndex(room->getMember(m_this->getID()));
						}
						//crVector3i pos = scene->gainBirthPoint(m_this->getLayerID(),m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale(),index);
						//m_this->setPosx(pos[0]);
						//m_this->setPosy(pos[1]);
						//m_this->setPosz(pos[2]);
						scene->gainBirthPoint(m_this,index);
					}
				}
				else if(reliveFlg == 2)
				{//竞技游戏复活
					thisData->inputParam(WCHDATA_RTHP,&maxhp);
					thisData->inputParam(WCHDATA_RTMP,&maxmp);
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					CRNetApp::crScene *scene = callback->findScene(m_this->getSceneID());
					int index = -1;
					int roomid = m_this->getRoomID();
					if(roomid!=0)
					{
						crRoom *room = callback->findRoom(roomid);
						if(room)
							index = room->getBirthPointIndex(room->getMember(m_this->getID()));
					}
					//crVector3i pos = scene->gainBirthPoint(m_this->getLayerID(),m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale(),index);
					//m_this->setPosx(pos[0]);
					//m_this->setPosy(pos[1]);
					//m_this->setPosz(pos[2]);
					scene->gainBirthPoint(m_this,index);
				}
				//send to client
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(20);
				stream->_writeFloat(maxhp);
				stream->_writeFloat(maxmp);
				stream->_writeInt(m_this->getPosx());
				stream->_writeInt(m_this->getPosy());
				stream->_writeInt(m_this->getPosz());
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RelivePlayer,stream.get());
				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			float hp = m_stream->_readFloat();
			float mp = m_stream->_readFloat();
			thisData->inputParam(WCHDATA_RTHP,&hp);
			thisData->inputParam(WCHDATA_RTMP,&mp);
			m_this->setPosxy(m_stream->_readVec2i());
			m_this->setPosz(m_stream->_readInt());
			crNode *relNode = m_this->getRelNode();
			if(relNode)
			{
				m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
				//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				relNode->setVisiable(true);
				relNode->setEnableIntersect(true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crSetKeyboardMouseModeMethod
//
/////////////////////////////////////////
crSetKeyboardMouseModeMethod::crSetKeyboardMouseModeMethod():
m_mode(CRCore::KM_All){}
crSetKeyboardMouseModeMethod::crSetKeyboardMouseModeMethod(const crSetKeyboardMouseModeMethod& handle):
crMethod(handle),
m_mode(handle.m_mode)
{
}
void crSetKeyboardMouseModeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_mode = (unsigned short)(LOINT64(param64));
		}
		else
		{
			m_mode = CRCore::KM_All;
		}
		break;
	}
}

void crSetKeyboardMouseModeMethod::addParam(int i, const std::string& str)
{
}

void crSetKeyboardMouseModeMethod::operator()(crHandle &handle)
{
	CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview && bindview->isInited() && crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		////右键可用性检测
		//unsigned short flg = m_mode;
		//if(cr2DStageManager::getInstance()->hasCanDragStageOnShow())
		//{
		//	flg &= ~crCamera::KM_RightMouse;
		//}
		CRPhysics::crCamera *camera = bindview->getViewCameraNode();
		camera->setKeyboardMouseMode(m_mode);
	}
}
/////////////////////////////////////////
//
//crBulletCollideTestMethod
//
/////////////////////////////////////////
crBulletCollideTestMethod::crBulletCollideTestMethod():
m_collideTest(NULL),
m_targetType(Target_Enemy){}
crBulletCollideTestMethod::crBulletCollideTestMethod(const crBulletCollideTestMethod& handle):
crMethod(handle),
m_collideTest(NULL),
m_targetType(handle.m_targetType)
{
}
void crBulletCollideTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_collideNode = NULL;
			m_collideTest = NULL;
		}
		break;
	case 1:
		m_this = (CRPhysics::crBulletMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_collideNode = (crNode *)(LOINT64(param64));
			m_collideTest = (int *)(HIINT64(param64));
		}
		else
		{
			m_collideNode = NULL;
			m_collideTest = NULL;
		}
		break;
	}
}
void crBulletCollideTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_targetType = (unsigned char)(atoi(str.c_str()));
		break;
	}
}
void crBulletCollideTestMethod::operator()(crHandle &handle)
{
	//CRCore::notify(CRCore::ALWAYS)<<"crBulletCollideMethod"<<std::endl;
	if(m_collideTest)
	{
		if(m_this->getCollided() && !m_this->isExploding())
		{
			*m_collideTest = 0;
		}
		else if(m_collideNode.valid())
		{
            crData *collideNodeData = m_collideNode->getDataClass();
			if(collideNodeData)
			{
				if(m_this->getBulletObject()->getAttrMask() & crBulletObject::Track)
				{
					if(m_collideNode != m_this->getTrackTarget())
					{
						*m_collideTest = 0;
						//if(dynamic_cast<crViewMatterObject *>(m_collideNode.get()))
						//	*m_collideTest = 0;
						//else
						//{
						//	crViewMatterObject *firer = const_cast<crViewMatterObject *>(m_this->getFireWeapon()->getFireBody());
						//	firer->doEvent(WCH_TrackFireMiss,MAKEINT64(m_this,m_collideNode.get()));
						//}
					}
					//else if(dynamic_cast<crWeaponMatterObject*>(m_collideNode.get()) || dynamic_cast<crBulletMatterObject*>(m_collideNode.get()))
					//{
					//	char gbuf[256];
					//	sprintf(gbuf,"BulletCollideTest Weapon:%d,targetNode:%d,collideTest=%d,collideNode=%d,collided=%d\n\0",m_this->getFireWeapon(),m_this->getTrackTarget(),*m_collideTest,m_collideNode.get(),m_this->getCollided()?1:0);
					//	gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
					//}
				}
				else
				{
					void *param;
					crViewMatterObject *fireBody = const_cast<crViewMatterObject *>(m_this->getFireWeapon()->getFireBody());
					if(fireBody && fireBody->getDataClass())
					{
						crData *fireBodyData = fireBody->getDataClass();
						fireBodyData->getParam(WCHDATA_Item,param);
						crInstanceItem *fireItem = (crInstanceItem *)param;
						collideNodeData->getParam(WCHDATA_Item,param);
						crInstanceItem *hitItem = (crInstanceItem *)param;
						if(fireItem && hitItem)
						{
							if( fireItem->getItemtype()==crInstanceItem::Role && 
								hitItem->getItemtype()==crInstanceItem::Role &&
								hitItem->getID() == fireItem->getID())
							{//击中自己
								if(!(m_targetType & Target_Self))
									*m_collideTest = 0;
							}
							else
							{
								char isEnemy = 0;
								fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(hitItem,&isEnemy));
								if(isEnemy == -1)
								{
									if(m_targetType & Target_Friend)
										*m_collideTest = 0;
								}
								else if(isEnemy == 1)
								{
									if(m_targetType & Target_Enemy)
										*m_collideTest = 0;
									else if(m_targetType == Target_Self)
									{//只能对自己使用
										if( fireItem->getItemtype()!=crInstanceItem::Role || 
											hitItem->getItemtype()!=crInstanceItem::Role ||
											hitItem->getID() != fireItem->getID())
										{
											*m_collideTest = 0;
										}
									}
								}
								else
								{
									*m_collideTest = 0;
								}
							}
							//char isEnemy = 0;
							//fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(hitItem,&isEnemy));
							//if(isEnemy == -1)
							//{
							//	if(m_targetType & Target_Friend)
							//		*m_collideTest = 0;
							//}
							//else if(isEnemy == 1)
							//{
							//	if(m_targetType & Target_Enemy)
							//		*m_collideTest = 0;//不是敌人，不产生碰撞
							//}
							//else
							//{
							//	*m_collideTest = 0;
							//}
						}
					}
				}
			}
			else if(m_this->getBulletObject()->getAttrMask() & crBulletObject::Track)
			{//如果是技能,可以穿透地形
				crData *thisdata = m_this->getDataClass();
				void *param;
				thisdata->getParam(WCHDATA_Item,param);
				crInstanceItem *item = (crInstanceItem *)param;
				if(item && item->getDataClass())
				{
					crData *itemdata = item->getDataClass();
					itemdata->getParam(WCHDATA_DataType,param);
					unsigned char datatype = *(unsigned char *)param;
					if(datatype == DT_Skill)
					{
						if(m_collideNode != m_this->getTrackTarget())
						{
							*m_collideTest = 0;
						}
					}
				}
			}
		}
		//char gbuf[256];
		//sprintf(gbuf,"BulletCollideTest Weapon:%d,targetNode:%d,collideTest=%d,collideNode=%d,collided=%d\n\0",m_this->getFireWeapon(),m_this->getTrackTarget(),*m_collideTest,m_collideNode.get(),m_this->getCollided()?1:0);
		//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
	}
}
///////////////////////////////////////////
////
////crEnemyCheckMethod
////
///////////////////////////////////////////
//crEnemyCheckMethod::crEnemyCheckMethod():m_isEnemy(NULL){}
//crEnemyCheckMethod::crEnemyCheckMethod(const crEnemyCheckMethod& handle):
//crMethod(handle)
//{
//}
//void crEnemyCheckMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_targetItem = NULL;
//			m_isEnemy = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_targetItem = (crInstanceItem *)(LOINT64(param64));
//			m_isEnemy = (char *)(HIINT64(param64));
//		}
//		else
//		{
//			m_targetItem = NULL;
//			m_isEnemy = NULL;
//		}
//		break;
//	}
//}
//void crEnemyCheckMethod::addParam(int i, const std::string& str)
//{
//}
//void crEnemyCheckMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_targetItem.valid() && m_isEnemy)
//	{
//		*m_isEnemy = 0;
//		do 
//		{
//			if(m_this == m_targetItem)
//			{//自身伤害
//				*m_isEnemy = 1;
//				break;
//			}
//			if(m_this->getItemtype() == crInstanceItem::instanceitem)
//			{
//				*m_isEnemy = 0;
//			    break;
//			}
//			if(m_targetItem->getItemtype() == crInstanceItem::instanceitem)
//			{
//				*m_isEnemy = 0;
//				break;
//			}
//			if(m_this->getRoomID()!=0)
//			{//开房间式
//				ref_ptr<crRoom> room;
//				if(crGlobalHandle::isClient())
//				{
//					room = crMyPlayerData::getInstance()->getSelectedRoom();
//				}
//				else
//				{
//					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//					if(sceneServerConductor)
//					{
//						crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//						crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//						room = callback->findRoom(m_this->getRoomID());
//					}
//				}
//				if(room.valid())
//				{
//					*m_isEnemy = room->isEnemy(m_this,m_targetItem.get());
//					break;
//				}
//			}
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			int targetid = m_targetItem->getID();
//			thisData->getParam(WCHDATA_GroupMemberSet,param);
//			GroupMemberSet groupMemberSet = *((GroupMemberSet*)param);
//			GroupMemberSet::iterator itr = groupMemberSet.find(targetid);
//			if(itr!=groupMemberSet.end())
//			{
//				*m_isEnemy = 1;
//				break;
//			}
//			else
//			{
//				thisData->getParam(WCHDATA_FightMode,param);
//				unsigned char fightMode = *(unsigned char *)param;
//				if(fightMode == FM_All)
//				{
//					*m_isEnemy = -1;
//					break;
//				}
//				if(fightMode == FM_Group)
//				{
//					*m_isEnemy = -1;
//					break;
//				}
//			}
//			thisData->getParam(WCHDATA_Camp,param);
//			unsigned char thisCamp = *(unsigned char *)param;
//			crData *targetData = m_targetItem->getDataClass();
//			targetData->getParam(WCHDATA_Camp,param);
//			unsigned char hitCamp = *(unsigned char *)param;
//			if(thisCamp == hitCamp)
//			{
//                *m_isEnemy = 0;
//				break;
//			}
//			else
//			{
//				*m_isEnemy = -1;
//				break;
//			}
//		} while (0);
//	}
//}
/////////////////////////////////////////
//
//crEnemyCheckMethod
//
/////////////////////////////////////////
crEnemyCheckMethod::crEnemyCheckMethod():m_isEnemy(NULL){}
crEnemyCheckMethod::crEnemyCheckMethod(const crEnemyCheckMethod& handle):
	crMethod(handle)
{
}
void crEnemyCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_targetItem = NULL;
			m_isEnemy = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetItem = (crInstanceItem *)(LOINT64(param64));
			m_isEnemy = (char *)(HIINT64(param64));
		}
		else
		{
			m_targetItem = NULL;
			m_isEnemy = NULL;
		}
		break;
	}
}
void crEnemyCheckMethod::addParam(int i, const std::string& str)
{
}
void crEnemyCheckMethod::operator()(crHandle &handle)
{
	if(m_targetItem.valid() && m_isEnemy)
	{
		*m_isEnemy = 0;
		do 
		{
			if(m_this == m_targetItem.get())
			{//自身伤害
				*m_isEnemy = 1;
				break;
			}
			unsigned char thistype = m_this->getItemtype();
			unsigned char targettype = m_targetItem->getItemtype();
			//if( thistype>=crInstanceItem::Npc && thistype<=crInstanceItem::Role &&
			//	targettype>=crInstanceItem::Npc && targettype<=crInstanceItem::Role )
			//{
				void *param;
				crData *thisData = m_this->getDataClass();
				if(!thisData)
					break;
				thisData->getParam(WCHDATA_Camp,param);
				if(!param)
				{
					break;
				}
				unsigned char thisCamp = *(unsigned char *)param;
				if(thisCamp == 0)
				{
					break;
				}
				else if(thisCamp == 1)
				{
					*m_isEnemy = -1;
					break;
				}
				crData *targetData = m_targetItem->getDataClass();
				if(!targetData)
					break;
				targetData->getParam(WCHDATA_Camp,param);
				if(!param)
				{
					break;
				}
				unsigned char targetCamp = *(unsigned char *)param;
				if(targetCamp == 0)
				{
					break;
				}
				else if(targetCamp == 1)
				{
					*m_isEnemy = -1;
					break;
				}
				if(thisCamp == targetCamp)
				{
					*m_isEnemy = 1;
					break;
				}
				*m_isEnemy = -1;
			//}
		} while (0);
	}
}
/////////////////////////////////////////
//
//crRequestItemRTDataMethod
//
/////////////////////////////////////////
crRequestItemRTDataMethod::crRequestItemRTDataMethod(){}
crRequestItemRTDataMethod::crRequestItemRTDataMethod(const crRequestItemRTDataMethod& handle):
crMethod(handle)
{
}
void crRequestItemRTDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crViewMatterObject*)param;
		break;
	}
}
void crRequestItemRTDataMethod::addParam(int i, const std::string& str)
{
}
void crRequestItemRTDataMethod::operator()(crHandle &handle)
{
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Item,param);
		crInstanceItem *item = ((crInstanceItem*)param);
        if(item)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				crRequestItemRTDataPacket packet;
				crRequestItemRTDataPacket::buildRequestPacket(packet,item);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
///////////////////////////////////////////
////
////crGetRoleZMethod
////
///////////////////////////////////////////
//crGetRoleZMethod::crGetRoleZMethod(){}
//crGetRoleZMethod::crGetRoleZMethod(const crGetRoleZMethod& handle):
//crMethod(handle)
//{
//}
//void crGetRoleZMethod::inputParam(int i, void *param)
//{
//}
//void crGetRoleZMethod::addParam(int i, const std::string& str)
//{
//}
//void crGetRoleZMethod::operator()(crHandle &handle)
//{
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	crGetRoleZPacket packet;
//	netConductor->getNetManager()->sendPacket("all",packet);
//}
/////////////////////////////////////////
//
//crTransportCollideMethod
//
/////////////////////////////////////////
crTransportCollideMethod::crTransportCollideMethod():
m_sceneid(0),
m_layerid(0){}
crTransportCollideMethod::crTransportCollideMethod(const crTransportCollideMethod& handle):
crMethod(handle),
m_sceneid(handle.m_sceneid),
m_layerid(handle.m_layerid),
m_coord(handle.m_coord)
{
}
void crTransportCollideMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_collideNode = NULL;
			m_contactInfo = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_collideNode = (crNode *)(LOINT64(param64));
			m_contactInfo = (dContact *)(HIINT64(param64));
		}
		else
		{
			m_collideNode = NULL;
			m_contactInfo = NULL;
		}
		break;
	}
}
void crTransportCollideMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sceneid = atoi(str.c_str());
		break;
	case 1:
		m_layerid = (unsigned short)(atoi(str.c_str()));
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_coord);
		break;
	}
}
void crTransportCollideMethod::operator()(crHandle &handle)
{
	//	CRCore::notify(CRCore::ALWAYS)<<"crBotCollideMethod"<<std::endl;
	if(m_collideNode.valid() && m_contactInfo)
	{
		void *param;
		//crData *thisData = m_this->getDataClass();
		//thisData->getParam(WCHDATA_Item,param);
		//crInstanceItem *thisItem = ((crInstanceItem*)param);

		if(dynamic_cast<crViewMatterObject *>(m_collideNode.get()))
		{
			crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_collideNode.get());
			crData *botData = const_cast<crData *>(bot->getDataClass());
			botData->getParam(WCHDATA_Item,param);
			crInstanceItem *item = ((crInstanceItem*)param);
			if(item && item->getDataClass() && crMyPlayerData::getInstance()->ifItemIsMe(item))
			{//传送
				//crNode *relNode = item->getRelNode();
				//crVector3 nullpos;
				//float speed = 0;
				//if(node) node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));//停止移动
				unsigned char itemstate = IS_Stop;
				item->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
				//bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeOutRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				bot->setVisiable(false);
				bot->setEnableIntersect(false);

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(14);
				//stream->_writeUChar(item->getItemtype());
				//stream->_writeInt(crMyPlayerData::getInstance()->getPlayerID());
				stream->_writeInt(m_sceneid);//
				stream->_writeUShort(m_layerid);//
				//if(m_sceneid == item->getSceneID())
				stream->_writeVec2(m_coord);//8
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					crPlayerServerEventPacket packet;
					//crPlayerServerEventPacket::buildRequestPacket(packet,WCH_Transport,item->getItemtype(),crMyPlayerData::getInstance()->getPlayerID(),stream.get());
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_Transport,item,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvTransportMethod
//
/////////////////////////////////////////
crRecvTransportMethod::crRecvTransportMethod():
m_netType(GameClient_Game){}
crRecvTransportMethod::crRecvTransportMethod(const crRecvTransportMethod& handle):
crMethod(handle)
{
}
void crRecvTransportMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvTransportMethod::addParam(int i, const std::string& str)
{
}

void crRecvTransportMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *thisData = m_this->getDataClass();
		unsigned char targettype = Target_Coord;
		thisData->inputParam(WCHDATA_TargetType,&targettype);
		unsigned char itemstate = IS_Stop;
		thisData->inputParam(WCHDATA_ItemState,&itemstate);
		//m_this->getOrCreatePathFinder()->dirty();
		if(m_netType == SceneServer)
		{
			int sceneid = m_stream->_readInt();
			unsigned short layerid = m_stream->_readUShort();
			int curSceneID = m_this->getSceneID();
			unsigned short curLayerID = m_this->getLayerID();
			unsigned char transport = TM_None;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crNetManager *netManager = sceneServerConductor->getNetManager();
			crVector2 coord = m_stream->_readVec2();
			m_this->setPosxy(coord[0] / crGlobalHandle::gData()->gUnitScale(),coord[1] / crGlobalHandle::gData()->gUnitScale());
			crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			crScene *scene = callback->findScene(m_this->getSceneID());
			float posz = scene->getPosZ(layerid,coord[0],coord[1],m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale());
			posz /= crGlobalHandle::gData()->gUnitScale();
			m_this->setPosz(posz);
			if(curSceneID == sceneid)
			{
				if(curLayerID != layerid)
				{
					transport = TM_SwitchLayer;
					m_this->setLayerID(layerid);
					stream->createBuf(15);
					stream->_writeUChar(transport);
					stream->_writeUShort(layerid);
				}
				else
				{
					stream->createBuf(13);
					stream->_writeUChar(transport);
				}
				stream->_writeInt(m_this->getPosx());
				stream->_writeInt(m_this->getPosy());
				stream->_writeInt(m_this->getPosz());
			}
			else
			{
				transport = TM_SwitchScene;
				m_this->setTransportSceneID(sceneid);
				m_this->setLayerID(layerid);
				stream->createBuf(7);
				stream->_writeUChar(transport);
				stream->_writeInt(sceneid);
				stream->_writeUShort(layerid);
			}

			if(m_this->getItemtype() == crInstanceItem::Role)
			{
				int playerid = m_this->getID();
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_Transport,stream.get());

				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid())
					netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				unsigned char transport = m_stream->_readUChar();
				crNode *relNode = m_this->getRelNode();
				//if(node)
				//{
				//	crVector3 nullpos;
				//	float speed = 0.0f;
				//	node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));//停止移动
				//}
				if(transport == TM_None)
				{
                    m_this->setPosxy(m_stream->_readVec2i());
					m_this->setPosz(m_stream->_readInt());
					if(relNode)
					{
						m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_TransMatrix));
						//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
						relNode->setVisiable(true);
						relNode->setEnableIntersect(true);
					}
				}
				else if(transport == TM_SwitchLayer)
				{
					unsigned short layerid = m_stream->_readUShort();
					m_this->setLayerID(layerid);
					m_this->setPosxy(m_stream->_readVec2i());
					m_this->setPosz(m_stream->_readInt());

					if(relNode)
					{
						m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_TransMatrix));
						//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
						relNode->setVisiable(true);
						relNode->setEnableIntersect(true);
					}
				}
				else if(transport == TM_SwitchScene)
				{
                    int sceneid = m_stream->_readInt();
					unsigned short layerid = m_stream->_readUShort();
					m_this->setSceneID(sceneid);
					m_this->setLayerID(layerid);

					crRole *gameRole = crMyPlayerData::getInstance()->getSelectedGameRole();
                    gameRole->setSceneID(sceneid);
                    gameRole->setLayerID(layerid);
					relNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_ExitScene,EC_SwitchScene));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crExitSceneMethod
//
/////////////////////////////////////////
crExitSceneMethod::crExitSceneMethod():
m_exitCode(0){}
crExitSceneMethod::crExitSceneMethod(const crExitSceneMethod& handle):
crMethod(handle),
m_exitCode(handle.m_exitCode)
{
}
void crExitSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_exitCode = (char)(LOINT64(param64));
		}
		else
		{
			m_exitCode = NULL;
		}
		break;
	}
}
void crExitSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_exitCode = (char)(atoi(str.c_str()));
		break;
	}
}
void crExitSceneMethod::operator()(crHandle &handle)
{
	if(m_exitCode == EC_ExitGame)
	    crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Game);
	crMyPlayerData::getInstance()->setExitCode(m_exitCode);
	//crMyPlayerData::getInstance()->clear();
	//crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Game);
	ref_ptr<CRProducer::crViewer>bindview = crStartHandler::getInstance()->getViewer();
	if(bindview.valid()) bindview->setDone(true);
	crRunGameHandle::getInstance()->end();
}
/////////////////////////////////////////
//
//crUIExitSceneMethod
//
/////////////////////////////////////////
crUIExitSceneMethod::crUIExitSceneMethod():
m_exitCode(0){}
crUIExitSceneMethod::crUIExitSceneMethod(const crUIExitSceneMethod& handle):
crMethod(handle),
m_exitCode(handle.m_exitCode)
{
}
void crUIExitSceneMethod::inputParam(int i, void *param)
{
}
void crUIExitSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_exitCode = (char)(atoi(str.c_str()));
		break;
	}
}
void crUIExitSceneMethod::operator()(crHandle &handle)
{
	if(m_exitCode == EC_ExitGame)
		crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Game);
	crMyPlayerData::getInstance()->setExitCode(m_exitCode);
	//crMyPlayerData::getInstance()->clear();
	//crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Game);
	ref_ptr<CRProducer::crViewer>bindview = crStartHandler::getInstance()->getViewer();
	if(bindview.valid()) bindview->setDone(true);
	crRunGameHandle::getInstance()->end();
}
/////////////////////////////////////////
//
//crDisconnectSceneMethod
//
/////////////////////////////////////////
crDisconnectSceneMethod::crDisconnectSceneMethod(){}
crDisconnectSceneMethod::crDisconnectSceneMethod(const crDisconnectSceneMethod& handle):
crMethod(handle)
{
}
void crDisconnectSceneMethod::inputParam(int i, void *param)
{
}
void crDisconnectSceneMethod::addParam(int i, const std::string& str)
{
}
void crDisconnectSceneMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{//client to server
		crLogoutScenePacket packet;
		netConductor->getNetManager()->sendPacket("all",packet);
		CRCore::notify(CRCore::FATAL)<<"DisconnectScene"<<std::endl;
	}
}
/////////////////////////////////////////
//
//crParseExitCodeMethod
//
/////////////////////////////////////////
crParseExitCodeMethod::crParseExitCodeMethod(){}
crParseExitCodeMethod::crParseExitCodeMethod(const crParseExitCodeMethod& handle):
crMethod(handle)
{
}
void crParseExitCodeMethod::inputParam(int i, void *param)
{
}
void crParseExitCodeMethod::addParam(int i, const std::string& str)
{
}
void crParseExitCodeMethod::operator()(crHandle &handle)
{
	bool m_true = false;
	char exitCode = crMyPlayerData::getInstance()->getExitCode();
    if(exitCode == EC_SwitchScene)
	{
        m_true = true;
	}
	handle.outputParam(0,&m_true);
}
/////////////////////////////////////////
//
//crParseExitCode2Method
//
/////////////////////////////////////////
crParseExitCode2Method::crParseExitCode2Method(){}
crParseExitCode2Method::crParseExitCode2Method(const crParseExitCode2Method& handle):
crMethod(handle)
{
}
void crParseExitCode2Method::inputParam(int i, void *param)
{
}
void crParseExitCode2Method::addParam(int i, const std::string& str)
{
}
void crParseExitCode2Method::operator()(crHandle &handle)
{
	bool m_true = true;
	char exitCode = crMyPlayerData::getInstance()->getExitCode();
	if(exitCode == EC_ExitGame)
	{
		m_true = false;
	}
	handle.outputParam(0,&m_true);
}
/////////////////////////////////////////
//
//crShowStatsMethod
//
/////////////////////////////////////////
crShowStatsMethod::crShowStatsMethod():m_show(0){}
crShowStatsMethod::crShowStatsMethod(const crShowStatsMethod& handle):
crMethod(handle),
m_show(0)
{
}
void crShowStatsMethod::inputParam(int i, void *param)
{
}
void crShowStatsMethod::addParam(int i, const std::string& str)
{
}
void crShowStatsMethod::operator()(crHandle &handle)
{
	//CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
 //   if(bindview)
	//{
	//	m_show = m_show>=3?0:m_show+1;
	//	bindview->showStats(m_show);
	//}
	crStatistics::getInstance()->setStat(!crStatistics::getInstance()->getStat());
}
/////////////////////////////////////////
//
//crSnapImageMethod
//
/////////////////////////////////////////
crSnapImageMethod::crSnapImageMethod(){}
crSnapImageMethod::crSnapImageMethod(const crSnapImageMethod& handle):
crMethod(handle)
{
}
void crSnapImageMethod::inputParam(int i, void *param)
{
}
void crSnapImageMethod::addParam(int i, const std::string& str)
{
}
void crSnapImageMethod::operator()(crHandle &handle)
{
	CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	bindview->snapImageOnNextFrame();
}
/////////////////////////////////////////
//
//crRecordMethod
//
/////////////////////////////////////////
crRecordMethod::crRecordMethod(){}
crRecordMethod::crRecordMethod(const crRecordMethod& handle):
crMethod(handle)
{
}
void crRecordMethod::inputParam(int i, void *param)
{
}
void crRecordMethod::addParam(int i, const std::string& str)
{
}
void crRecordMethod::operator()(crHandle &handle)
{
	//CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	//bindview->record();
}
/////////////////////////////////////////
//
//crUIUpdateRoleMethod
//
/////////////////////////////////////////
crUIUpdateRoleMethod::crUIUpdateRoleMethod(){}
crUIUpdateRoleMethod::crUIUpdateRoleMethod(const crUIUpdateRoleMethod& handle):
crMethod(handle),
m_name(handle.m_name),
m_lv(handle.m_lv),
m_lvAdd(handle.m_lvAdd),
m_exp(handle.m_exp),
m_gold(handle.m_gold),
m_hp(handle.m_hp),
m_mp(handle.m_mp),
m_attack(handle.m_attack),
m_defend(handle.m_defend),
m_strength(handle.m_strength),
m_strengthAdd(handle.m_strengthAdd),
m_agility(handle.m_agility),
m_agilityAdd(handle.m_agilityAdd),
m_intellect(handle.m_intellect),
m_intellectAdd(handle.m_intellectAdd),
m_attrpoint(handle.m_attrpoint),
m_skillpoint(handle.m_skillpoint),
m_attrok(handle.m_attrok)
{
}
void crUIUpdateRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		m_this = (crImageStage*)(param);
		break;
	}
}
void crUIUpdateRoleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_name = str;
		break;
	case 1:
		m_lv = str;
		break;
	case 2:
		m_lvAdd = str;
		break;
	case 3:
		m_exp = str;
		break;
	case 4:
		m_gold = str;
		break;
	case 5:
		m_hp = str;
		break;
	case 6:
		m_mp = str;
		break;
	case 7:
		m_attack = str;
		break;
	case 8:
		m_defend = str;
		break;
	case 9:
		m_strength = str;
		break;
	case 10:
		m_strengthAdd = str;
		break;
	case 11:
		m_agility = str;
		break;
	case 12:
		m_agilityAdd = str;
		break;
	case 13:
		m_intellect = str;
		break;
	case 14:
		m_intellectAdd = str;
		break;
	case 15:
		m_attrpoint = str;
		break;
	case 16:
		m_skillpoint = str;
		break;
	case 17:
		m_attrok = str;
		break;
	}
}
void crUIUpdateRoleMethod::operator()(crHandle &handle)
{
	if(!m_this->isHide())
	{
		crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
		if(!role) return;
		crStaticTextBoxElement *nameElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_name));
		crStaticTextBoxElement *lvElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_lv));
		crStaticTextBoxElement *lvAddElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_lvAdd));
		crStaticTextBoxElement *expElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_exp));
		crStaticTextBoxElement *goldElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_gold));
		crStaticTextBoxElement *hpElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_hp));
		crStaticTextBoxElement *mpElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_mp));
		crStaticTextBoxElement *attackElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_attack));
		crStaticTextBoxElement *defendElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_defend));

		bool needReDraw = false;
		std::string str,oldstr;
		void *param;
		crData *roleData = role->getDataClass();

		roleData->excHandle(MAKEINT64(WCH_LockData,1));
		roleData->getParam(WCHDATA_EquipOnMap,param);
		crItemChild *itemChild;
		float equip = 0;
		float equipStrengthSum = 0;
		float equipAgilitySum = 0;
		float equipIntellectSum = 0;
		float equipLvSum = 0;
		EquipOnMap* equipOnMap = (EquipOnMap*)param;
		crInstanceItem *item;
		for( EquipOnMap::iterator itr = equipOnMap->begin();
			itr != equipOnMap->end();
			++itr )
		{
			itemChild = role->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				item = itemChild->getInstanceItem();
				equip = 0;
				item->doEvent(WCH_GetEquipStrength,MAKEINT64(m_this,&equip));
				equipStrengthSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipAgility,MAKEINT64(m_this,&equip));
				equipAgilitySum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipIntellect,MAKEINT64(m_this,&equip));
				equipIntellectSum+=equip;
				equip = 0;
				item->doEvent(WCH_GetEquipLv,MAKEINT64(m_this,&equip));
				equipLvSum+=equip;
			}
		}
		roleData->excHandle(MAKEINT64(WCH_LockData,0));

		if(nameElement)
		{
			str = role->getIName();
			oldstr = nameElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				nameElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(lvElement)
		{
			roleData->getParam(WCHDATA_Level,param);
			unsigned char lv = *((unsigned char*)param);
			str = crArgumentParser::appItoa((int)lv);
			oldstr = lvElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				lvElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(lvAddElement)
		{
			str.clear();
			if((int)equipLvSum!=0)
				str = "+" +crArgumentParser::appItoa(equipLvSum);

			oldstr = lvAddElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				lvAddElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(expElement)
		{
			roleData->getParam(WCHDATA_Experience,param);
			int exp = *((int*)param);
			int nextexp = exp;
			role->doEvent(WCH_GetNextLvExp,MAKEINT64(&nextexp,NULL));
			str = crArgumentParser::appItoa(exp) + "/" + crArgumentParser::appItoa(nextexp);
			oldstr = expElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				expElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(goldElement)
		{
			roleData->getParam(WCHDATA_Gold,param);
			int gold = *((int*)param);
			str = crArgumentParser::appItoa(gold);
			oldstr = expElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				goldElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(hpElement)
		{
			float maxhp = 0;
			role->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
			roleData->getParam(WCHDATA_RTHP,param);
			float rthp = *(float*)param;

			str = crArgumentParser::appItoa(rthp) + "/" + crArgumentParser::appItoa(maxhp);
			oldstr = hpElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				hpElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(mpElement)
		{
			float maxmp = 0;
			role->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
			roleData->getParam(WCHDATA_RTMP,param);
			float rtmp = *(float*)param;

			str = crArgumentParser::appItoa(rtmp) + "/" + crArgumentParser::appItoa(maxmp);
			oldstr = mpElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				mpElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(attackElement)
		{
			float attack = 0;
			role->doEvent(MAKEINT64(WCH_GetDamage,NULL),MAKEINT64(&attack,NULL));
			str = crArgumentParser::appItoa(attack);
			oldstr = attackElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				attackElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(defendElement)
		{
			float defend = 0;
			role->doEvent(MAKEINT64(WCH_GetDefend,NULL),MAKEINT64(&defend,NULL));
			str = crArgumentParser::appItoa(defend);
			oldstr = defendElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				defendElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		crStaticTextBoxElement *skillpointElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_skillpoint));
		if(skillpointElement)
		{
			roleData->getParam(WCHDATA_SkillPoint,param);
			unsigned short skillpoint = *((unsigned short*)param);
			str = crArgumentParser::appItoa((int)skillpoint);
			oldstr = skillpointElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				skillpointElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		crStaticTextBoxElement *strengthAddElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_strengthAdd));
		crStaticTextBoxElement *agilityAddElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_agilityAdd));
		crStaticTextBoxElement *intellectAddElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_intellectAdd));
		if(strengthAddElement)
		{
			str.clear();
			if((int)equipStrengthSum!=0)
				str = "+" +crArgumentParser::appItoa(equipStrengthSum);

			oldstr = strengthAddElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				strengthAddElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(agilityAddElement)
		{
			str.clear();
			if((int)equipAgilitySum!=0)
				str = "+" +crArgumentParser::appItoa(equipAgilitySum);

			oldstr = agilityAddElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				agilityAddElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		if(intellectAddElement)
		{
			str.clear();
			if((int)equipIntellectSum!=0)
				str = "+" +crArgumentParser::appItoa(equipIntellectSum);

			oldstr = intellectAddElement->getStringArrayInString();
			if(str.compare(oldstr)!=0)
			{
				intellectAddElement->setStringArrayByString(str);
				needReDraw = true;
			}
		}
		crButtonElement *attrokElement = dynamic_cast<crButtonElement *>(m_this->getElement(m_attrok));
		if(attrokElement && !attrokElement->getShow())
		{
			crStaticTextBoxElement *strengthElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_strength));
			crStaticTextBoxElement *agilityElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_agility));
			crStaticTextBoxElement *intellectElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_intellect));
			crStaticTextBoxElement *attrpointElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_attrpoint));
			if(strengthElement)
			{
				roleData->getParam(WCHDATA_Strength,param);
				short strength = *((short*)param);
				str = crArgumentParser::appItoa(strength);

				oldstr = strengthElement->getStringArrayInString();
				if(str.compare(oldstr)!=0)
				{
					strengthElement->setStringArrayByString(str);
					needReDraw = true;
				}
			}
			if(agilityElement)
			{
				roleData->getParam(WCHDATA_Agility,param);
				short agility = *((short*)param);
				str = crArgumentParser::appItoa(agility);

				oldstr = agilityElement->getStringArrayInString();
				if(str.compare(oldstr)!=0)
				{
					agilityElement->setStringArrayByString(str);
					needReDraw = true;
				}
			}
			if(intellectElement)
			{
				roleData->getParam(WCHDATA_Intellect,param);
				short intellect = *((short*)param);
				str = crArgumentParser::appItoa(intellect);

				oldstr = intellectElement->getStringArrayInString();
				if(str.compare(oldstr)!=0)
				{
					intellectElement->setStringArrayByString(str);
					needReDraw = true;
				}
			}
			if(attrpointElement)
			{
				roleData->getParam(WCHDATA_AttrPoint,param);
				unsigned short attrpoint = *((unsigned short*)param);
				str = crArgumentParser::appItoa((int)attrpoint);
				oldstr = attrpointElement->getStringArrayInString();
				if(str.compare(oldstr)!=0)
				{
					attrpointElement->setStringArrayByString(str);
					needReDraw = true;
				}
			}
		}
		if(needReDraw) m_this->setNeedReDraw();
	}
}
/////////////////////////////////////////
//
//crGetNextLvExpMethod
//
/////////////////////////////////////////
crGetNextLvExpMethod::crGetNextLvExpMethod():
m_output(NULL)
{
	m_factor.set(10,40,50);
}
crGetNextLvExpMethod::crGetNextLvExpMethod(const crGetNextLvExpMethod& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetNextLvExpMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (int *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetNextLvExpMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crGetNextLvExpMethod::operator()(crHandle &handle)
{
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_Level,param);
		unsigned char lv = *(unsigned char *)param;
		int ilv = (int)lv + 1;
		*m_output = ilv*ilv*ilv*m_factor[0]+ilv*m_factor[1]+m_factor[2];
	}
}
/////////////////////////////////////////
//
//crItemDoEventMethod
//
/////////////////////////////////////////
crItemDoEventMethod::crItemDoEventMethod():
m_msg(NULL),
m_param(NULL),
m_this(NULL)
{
}
crItemDoEventMethod::crItemDoEventMethod(const crItemDoEventMethod& handle):
crMethod(handle),
m_this(NULL),
m_msg(handle.m_msg),
m_param(handle.m_param)
{
}
void crItemDoEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crItemDoEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = parseEventMsg(str);
		break;
	case 1:
		m_msg = MAKEINT64(LOINT64(m_msg),parseEventMsg(str));
		break;
	case 2:
		m_param = atoi(str.c_str());
		break;
	case 3:
		m_param =  MAKEINT64(LOINT64(m_param),atoi(str.c_str()));
		break;
	}
}
void crItemDoEventMethod::operator()(crHandle &handle)
{
	m_this->doEvent(m_msg,m_param);
}
/////////////////////////////////////////
//
//crNodeDoEventMethod
//
/////////////////////////////////////////
crNodeDoEventMethod::crNodeDoEventMethod():
	m_msg(NULL),
	m_param(NULL),
	m_this(NULL)
{
}
crNodeDoEventMethod::crNodeDoEventMethod(const crNodeDoEventMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msg(handle.m_msg),
	m_param(handle.m_param)
{
}
void crNodeDoEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}
void crNodeDoEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = parseEventMsg(str);
		break;
	case 1:
		m_msg = MAKEINT64(LOINT64(m_msg),parseEventMsg(str));
		break;
	case 2:
		m_param = atoi(str.c_str());
		break;
	case 3:
		m_param =  MAKEINT64(LOINT64(m_param),atoi(str.c_str()));
		break;
	}
}
void crNodeDoEventMethod::operator()(crHandle &handle)
{
	m_this->doEvent(m_msg,m_param);
}
/////////////////////////////////////////
//
//crMyRoleDoEventMethod
//
/////////////////////////////////////////
crMyRoleDoEventMethod::crMyRoleDoEventMethod():
	m_roleindex(0),
	m_msg(NULL),
	m_param(NULL)
{
}
crMyRoleDoEventMethod::crMyRoleDoEventMethod(const crMyRoleDoEventMethod& handle):
	crMethod(handle),
	m_roleindex(handle.m_roleindex),
	m_msg(handle.m_msg),
	m_param(handle.m_param)
{
}
void crMyRoleDoEventMethod::inputParam(int i, void *param)
{
}
void crMyRoleDoEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_roleindex = atoi(str.c_str());
		break;
	case 1:
		m_msg = parseEventMsg(str);
		break;
	case 2:
		m_msg = MAKEINT64(LOINT64(m_msg),parseEventMsg(str));
		break;
	case 3:
		m_param = atoi(str.c_str());
		break;
	case 4:
		m_param =  MAKEINT64(LOINT64(m_param),atoi(str.c_str()));
		break;
	}
}
void crMyRoleDoEventMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getLoadedRoleByIndex(m_roleindex);
	if(role) role->doEvent(m_msg,m_param);
}
/////////////////////////////////////////
//
//crMyMetierEventMethod
//
/////////////////////////////////////////
crMyMetierEventMethod::crMyMetierEventMethod():
m_msg(0),
m_param(0)
{
}
crMyMetierEventMethod::crMyMetierEventMethod(const crMyMetierEventMethod& handle):
crMethod(handle),
m_msg(handle.m_msg),
m_param(handle.m_param)
{
}
void crMyMetierEventMethod::inputParam(int i, void *param)
{
}
void crMyMetierEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		{
			std::string str1,str2;
			std::string::size_type comma = str.find_first_of(',');
			str1 = std::string(str.begin(),str.begin()+comma);
			str2 = std::string(str.begin()+comma + 1,str.end());
			m_msg = MAKEINT64(parseEventMsg(str1),parseEventMsg(str2));
		}
		break;
	case 1:
		{
			crVector2i vec2;
			crArgumentParser::appAtoVec(str,vec2);
			m_param = MAKEINT64(vec2[0],vec2[1]);
		}
		break;
	}
}
void crMyMetierEventMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	me->doMetierEvent(m_msg,m_param);
}
/////////////////////////////////////////
//
//crGetTaskMethod
//
/////////////////////////////////////////
crGetTaskMethod::crGetTaskMethod()
{
}
crGetTaskMethod::crGetTaskMethod(const crGetTaskMethod& handle):
crMethod(handle)
{
}
void crGetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_taskid = LOINT64(param64);
	//	}
	//	else
	//	{
	//		m_taskid = 0;
	//	}
	//	break;
	}
}
void crGetTaskMethod::addParam(int i, const std::string& str)
{
}
void crGetTaskMethod::operator()(crHandle &handle)
{
	{
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		metierData->getParam(WCHDATA_CurrentTaskID,param);
		int taskid = *(int *)param;
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid() && !gameTask->getActivation())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
            stream->_writeInt(taskid);
			int playerid = m_this->getPlayerID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			if(netConductor)
			{//server to client
                crPlayerMetierEventPacket packet;
				crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvGetTask,stream.get());
				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			else
			{
				netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crWaitNetReturnStreamLogic::getLock();
                    crPlayerServerMetierEventPacket packet;
					crPlayerServerMetierEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_RecvGetTask,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crAdvanceTaskMethod
//
/////////////////////////////////////////
crAdvanceTaskMethod::crAdvanceTaskMethod():
m_taskid(0),
m_stepType(0),
m_noStreamLock(false)
{
}
crAdvanceTaskMethod::crAdvanceTaskMethod(const crAdvanceTaskMethod& handle):
crMethod(handle),
m_taskid(0),
m_stepType(0),
m_noStreamLock(handle.m_noStreamLock)
{
}
void crAdvanceTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_taskid = LOINT64(param64);
			m_stepType = (unsigned char)(HIINT64(param64));
		}
		break;
	}
}
void crAdvanceTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noStreamLock = (bool)(atoi(str.c_str()));
		break;
	}
}
void crAdvanceTaskMethod::operator()(crHandle &handle)
{
	{
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		int taskid = m_taskid;
		if(taskid == 0)
		{
			metierData->getParam(WCHDATA_CurrentTaskID,param);
			taskid = *(int *)param;
		}
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
		if(gameTask.valid())
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			if(netConductor)
			{//server to client
				if(gameTask->advance(m_stepType))
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeInt(taskid);
					stream->_writeInt(gameTask->getTaskProgress());

					int playerid = m_this->getPlayerID();
					crPlayerMetierEventPacket packet;
					crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvAdvanceTask,stream.get());
					ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
					if(playerData.valid())
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
			else if(gameTask->isTaskCanAdvance(m_stepType))
			{
				netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor && m_this == crMyPlayerData::getInstance()->getCurrentRole())
				{//client to server
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(5);
					stream->_writeInt(m_taskid);
					stream->_writeUChar(m_stepType);
					crPlayerServerMetierEventPacket packet;
					if(!m_noStreamLock)
					{
						crWaitNetReturnStreamLogic::getLock();
						crPlayerServerMetierEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_RecvAdvanceTask,stream.get());
					}
					else
					{
						crPlayerServerMetierEventPacket::buildRequestPacket(packet,m_this->getRoleID(),MAKEINT64(WCH_RecvAdvanceTask,1),stream.get());
					}
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crReferTaskMethod
//
/////////////////////////////////////////
crReferTaskMethod::crReferTaskMethod()
{
}
crReferTaskMethod::crReferTaskMethod(const crReferTaskMethod& handle):
crMethod(handle)
{
}
void crReferTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}
void crReferTaskMethod::addParam(int i, const std::string& str)
{
}
void crReferTaskMethod::operator()(crHandle &handle)
{
	{
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		metierData->getParam(WCHDATA_CurrentTaskID,param);
		int taskid = *(int *)param;
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
		if(gameTask.valid() && gameTask->isTaskCanRefer())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(taskid);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{//client to server
				crWaitNetReturnStreamLogic::getLock();
				crPlayerServerMetierEventPacket packet;
				crPlayerServerMetierEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_RecvReferTask,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crKillerMetierEventMethod
//
/////////////////////////////////////////
crKillerMetierEventMethod::crKillerMetierEventMethod():
m_msg(0),
m_param(0)
{
}
crKillerMetierEventMethod::crKillerMetierEventMethod(const crKillerMetierEventMethod& handle):
crMethod(handle),
m_msg(handle.m_msg),
m_param(handle.m_param)
{
}
void crKillerMetierEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_killerRole = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_killerRole = (crRole*)(LOINT64(param64));
		}
		else
		{
			m_killerRole = NULL;
		}
		break;
	}
}
void crKillerMetierEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		{
			std::string str1,str2;
			std::string::size_type comma = str.find_first_of(',');
			str1 = std::string(str.begin(),str.begin()+comma);
			str2 = std::string(str.begin()+comma + 1,str.end());
			m_msg = MAKEINT64(parseEventMsg(str1),parseEventMsg(str2));
		}
		break;
	case 1:
		{
			crVector2i vec2;
			crArgumentParser::appAtoVec(str,vec2);
			m_param = MAKEINT64(vec2[0],vec2[1]);
		}
		break;
	}
}
void crKillerMetierEventMethod::operator()(crHandle &handle)
{
	if(m_killerRole.valid())
	{
		m_killerRole->doMetierEvent(m_msg,m_param);
	}
}
/////////////////////////////////////////
//
//crRecvGetTaskMethod
//
/////////////////////////////////////////
crRecvGetTaskMethod::crRecvGetTaskMethod():
m_netType(GameClient_Game){}
crRecvGetTaskMethod::crRecvGetTaskMethod(const crRecvGetTaskMethod& handle):
crMethod(handle)
{
}
void crRecvGetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvGetTaskMethod::addParam(int i, const std::string& str)
{
}
void crRecvGetTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
        int taskid = m_stream->_readInt();
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid() && !gameTask->getActivation())
		{
			if(m_netType == SceneServer)
			{
				do 
				{
					crData *data = m_this->getDataClass();
					data->getParam(WCHDATA_Level,param);
					unsigned char lv = *((unsigned char*)param);
					const crVector2ub &lvRange = gameTask->getLvRange();
					if(lvRange != crVector2ub(0,0))
					{
						if(lv<lvRange[0] || lv>lvRange[1])
						{
							break;
						}
					}
					int perTaskID = gameTask->getPreTask();
					if(perTaskID!=0)
					{
						GameTaskMap::iterator gameTaskItr = gameTaskMap->find(perTaskID);
						crGameTask *preGameTask = gameTaskItr!=gameTaskMap->end()?gameTaskItr->second.get():NULL;
						if(!preGameTask || !preGameTask->isComplete())
						{//前置任务没有完成
							break;
						}
					}
					gameTask->setActivation(true);
					
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(taskid);
					int playerid = m_this->getPlayerID();
					crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					if(netConductor)
					{//server to client
						crPlayerMetierEventPacket packet;
						crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvGetTask,stream.get());
						ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
						if(playerData.valid())
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				} while (0);
			}
			else if(m_netType == GameClient_Game)
			{
				gameTask->setActivation(true);
				m_stream->seek(-4);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crRecvAdvanceTaskMethod
//
/////////////////////////////////////////
crRecvAdvanceTaskMethod::crRecvAdvanceTaskMethod():
m_netType(GameClient_Game),
m_noStreamLock(false){}
crRecvAdvanceTaskMethod::crRecvAdvanceTaskMethod(const crRecvAdvanceTaskMethod& handle):
crMethod(handle),
m_netType(GameClient_Game),
m_noStreamLock(handle.m_noStreamLock)
{
}
void crRecvAdvanceTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvAdvanceTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noStreamLock = (bool)(atoi(str.c_str()));
		break;
	}
}
void crRecvAdvanceTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		int taskid = m_stream->_readInt();
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid())
		{
			if(m_netType == SceneServer)
			{
				unsigned char steptype = m_stream->_readUChar();
				if(gameTask->advance(steptype))
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeInt(taskid);
					stream->_writeInt(gameTask->getTaskProgress());
					int playerid = m_this->getPlayerID();
					crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					if(netConductor)
					{//server to client
						crPlayerMetierEventPacket packet;
						crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvAdvanceTask,stream.get());
						ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
						if(playerData.valid())
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
			else if(m_netType == GameClient_Game)
			{
				int progress = m_stream->_readInt();
				gameTask->setTaskProgress(progress);
				m_stream->seek(-8);
				if(!m_noStreamLock)
					crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crTaskAwardMethod
//
/////////////////////////////////////////
crTaskAwardMethod::crTaskAwardMethod():
m_output(NULL)
{
}
crTaskAwardMethod::crTaskAwardMethod(const crTaskAwardMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crTaskAwardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_gameTask = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gameTask = (crGameTask *)(LOINT64(param64));
            m_output = (bool *)(HIINT64(param64));
		}
		else
		{
			m_gameTask = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crTaskAwardMethod::addParam(int i, const std::string& str)
{
}
void crTaskAwardMethod::operator()(crHandle &handle)
{
	if(m_gameTask.valid())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = netConductor->getNetDataManager();
		int playerid = m_this->getPlayerID();
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
		if(playerData.valid())
		{
			////物品奖励的时候需要判断玩家包裹里是否有空位
			//AwardItemMap &awardItemMap = m_gameTask->getAwardItemMap();
			//if(!awardItemMap.empty())
			//{
			//	int awardItemCount = awardItemMap.size();
			//	///检查背包
			//	void *param;
			//	crData *data = m_this->getDataClass();
			//	data->excHandle(MAKEINT64(WCH_LockData,1));
			//	data->getParam(WCHDATA_BackPackMap,param);
			//	BackPackMap* backPackMap = (BackPackMap* )param;
			//	if(!backPackMap)
			//	{
			//		data->excHandle(MAKEINT64(WCH_LockData,0));
			//		return;
			//	}
			//	data->getParam(WCHDATA_MaxBackPack,param);
			//	unsigned char maxBackPack = *(unsigned char *)param;
			//	if((int)maxBackPack<backPackMap->size()+awardItemCount)
			//	{
			//		data->excHandle(MAKEINT64(WCH_LockData,0));
			//		return;
			//	}
			//	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			//	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
			//	crInstanceItem *item;
			//	char insertToBackPack = -1;
			//	int itemid,abstractid;
			//	for( AwardItemMap::iterator itr = awardItemMap.begin();
			//		itr != awardItemMap.end();
			//		++itr )
			//	{
			//		item = itr->second.get();
			//		if(item)
			//		{
			//			abstractid = itr->first;
			//			itemid = crGlobalHandle::gainTemporaryItemID();
			//			item->setInstanceItemID(itemid);

			//			m_this->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item,&insertToBackPack));
			//			//send result
			//			bool needInsertItemChild = false;
			//			ref_ptr<crItemChild> itemchild;
			//			if(insertToBackPack>=0)
			//			{
			//				if(insertToBackPack == 1)
			//				{
			//					needInsertItemChild = true;
			//					abstractid = item->getAbstractItemID();
			//					itemchild = m_this->findTemporaryItemChild(abstractid);
			//					if(itemchild.valid())
			//					{
			//						needInsertItemChild = false;
			//						BackPackMap::iterator itr = backPackMap->find(abstractid);
			//						for( ; itr!=backPackMap->end() && itr->first == abstractid; ++itr)
			//						{
			//							if(itr->second == itemid)
			//								itr->second = itemchild->getInstanceItemID();
			//						}
			//					}
			//					if(needInsertItemChild)
			//					{
			//						itemchild = new crItemChild;
			//						itemchild->setItemChildID(crGlobalHandle::gainTemporaryItemChildID());
			//						itemchild->setInstanceItem(item);
			//						m_this->insertChildItem(itemchild.get());
			//					}
			//					else
			//					{
			//						crGlobalHandle::recycleItemID(itemid);
			//					}
			//				}
			//				else
			//				{//回收id
			//					crGlobalHandle::recycleItemID(item->getInstanceItemID());
			//				}
			//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
			//				stream->createBuf(17);
			//				stream->_writeInt(m_gameTask->getTaskID());
			//				stream->_writeInt(abstractid);
			//				stream->_writeBool(needInsertItemChild);
			//				if(needInsertItemChild)
			//				{
			//					stream->_writeInt(itemchild->getItemChildID());
			//					stream->_writeInt(itemchild->getInstanceItemID());
			//				}
			//				else
			//				{
			//					if(itemchild.valid())
			//						stream->_writeInt(itemchild->getInstanceItemID());
			//					else
			//						stream->_writeInt(itemid);
			//				}
			//				crPlayerMetierEventPacket packet;
			//				crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvTaskAwardItem,stream.get());
			//				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			//				//需要将我的背包变化同步给附近玩家？
			//				CRCore::notify(CRCore::ALWAYS)<<"crTaskAwardMethod Abstractid "<<abstractid<<std::endl;
			//			}
			//		}
			//	}
			//	data->excHandle(MAKEINT64(WCH_LockData,0));
			//	//m_this->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
			//}
			int exp = m_gameTask->getExp();
			int gold = m_gameTask->getGold();
			if(exp!=0) m_this->doEvent(WCH_AddExperience,MAKEINT64(exp,NULL));
			if(gold!=0) m_this->doEvent(WCH_AddGold,MAKEINT64(gold,NULL));
			*m_output = true;
		}
	}
}
/////////////////////////////////////////
//
//crRecvTaskAwardItemMethod
//
/////////////////////////////////////////
crRecvTaskAwardItemMethod::crRecvTaskAwardItemMethod():
m_netType(GameClient_Game){}
crRecvTaskAwardItemMethod::crRecvTaskAwardItemMethod(const crRecvTaskAwardItemMethod& handle):
crMethod(handle)
{
}
void crRecvTaskAwardItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvTaskAwardItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvTaskAwardItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			int taskid = m_stream->_readInt();
			int abstractid = m_stream->_readInt();

			void *param;
			crData *metierData = m_this->getMetierDataClass();
			ref_ptr<crGameTask> gameTask;
			metierData->getParam(WCHDATA_GameTaskMap,param);
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			GameTaskMap* gameTaskMap = (GameTaskMap* )param;
			GameTaskMap::iterator itr = gameTaskMap->find(taskid);
			gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
			//if(gameTask.valid())
			//{
			//	ref_ptr<crInstanceItem> item;
			//	if(gameTask->getAwardItem(abstractid,item))
			//	{
			//		bool needInsertItemChild = m_stream->_readBool();
			//		if(needInsertItemChild)
			//		{
			//			int itemchildid = m_stream->_readInt();
			//			int itemid = m_stream->_readInt();
			//			item->setInstanceItemID(itemid);
			//			ref_ptr<crItemChild> itemchild = new crItemChild;
			//			itemchild->setItemChildID(itemchildid);
			//			itemchild->setInstanceItem(item.get());
			//			me->insertChildItem(itemchild.get());

			//			crData *newItemData = item->getDataClass();
			//			int playerid = me->getID();
			//			newItemData->inputParam(WCHDATA_BelongPlayerID,&playerid);
			//			newItemData->getParam(WCHDATA_DataType,param);
			//			unsigned char datatype = *((unsigned char*)param);
			//			if(datatype == DT_AttackThing)
			//			{
			//				item->clientLoadItemChildNode(me);
			//			}
			//		}
			//		else
			//		{
			//			item->setInstanceItemID(m_stream->_readInt());
			//		}
			//		char insertToBackPack2 = -1;
			//		me->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item.get(),&insertToBackPack2));
			//		me->doEvent(WCH_BuildBackPackList,NULL);
			//		//me->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
			//	}
			//}
		}
	}
}
/////////////////////////////////////////
//
//crRecvReferTaskMethod
//
/////////////////////////////////////////
crRecvReferTaskMethod::crRecvReferTaskMethod():
m_netType(GameClient_Game){}
crRecvReferTaskMethod::crRecvReferTaskMethod(const crRecvReferTaskMethod& handle):
crMethod(handle)
{
}
void crRecvReferTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvReferTaskMethod::addParam(int i, const std::string& str)
{
}
void crRecvReferTaskMethod::operator()(crHandle &handle)
{
	if(m_this && m_this->getMetierDataClass() && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				bool success = false;
				int taskid = m_stream->_readInt();
				void *param;
				crData *metierData = m_this->getMetierDataClass();
				ref_ptr<crGameTask> gameTask;
				metierData->getParam(WCHDATA_GameTaskMap,param);
				metierData->excHandle(MAKEINT64(WCH_LockData,1));
				GameTaskMap* gameTaskMap = (GameTaskMap* )param;
				GameTaskMap::iterator itr = gameTaskMap->find(taskid);
				gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
				metierData->excHandle(MAKEINT64(WCH_LockData,0));
				if(gameTask.valid() && gameTask->isTaskCanRefer())
				{
					m_this->doMetierEvent(WCH_TASKAWARD,MAKEINT64(gameTask.get(),&success));
					if(success)
					{
						gameTask->refer();
						//send result
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(taskid);
						crPlayerMetierEventPacket packet;
						crPlayerMetierEventPacket::buildRequestPacket(packet,playerid,playerid,m_this->getRoleID(),WCH_RecvReferTask,stream.get());
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			int taskid = m_stream->_readInt();
			void *param;
			crData *metierData = m_this->getMetierDataClass();
			ref_ptr<crGameTask> gameTask;
			metierData->getParam(WCHDATA_GameTaskMap,param);
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			GameTaskMap* gameTaskMap = (GameTaskMap* )param;
			GameTaskMap::iterator itr = gameTaskMap->find(taskid);
			gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
			if(gameTask.valid())
			{
				gameTask->refer();
			}
			m_stream->seek(-4);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crRecvCorrectPositionMethod
//
/////////////////////////////////////////
crRecvCorrectPositionMethod::crRecvCorrectPositionMethod():
m_netType(GameClient_Game){}
crRecvCorrectPositionMethod::crRecvCorrectPositionMethod(const crRecvCorrectPositionMethod& handle):
crMethod(handle)
{
}
void crRecvCorrectPositionMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvCorrectPositionMethod::addParam(int i, const std::string& str)
{
}
void crRecvCorrectPositionMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		unsigned char targettype = Target_None;
		m_this->getDataClass()->inputParam(WCHDATA_TargetType,&targettype);//避免closetarget
		unsigned char itemstate = IS_Stop;
		m_this->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);

		m_this->setPosxy(m_stream->_readVec2i());
		m_this->setPosz(m_stream->_readInt());
		crNode *node = m_this->getRelNode();
		if(node)
		{
			m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(node,crMatterObject::MD_TransMatrix));
			//crVector3 nullpos;
			//float speed = 0;
			//if(m_this == crMyPlayerData::getInstance()->getRole())
			//	node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));//停止移动
			//else
			//	node->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));//停止移动
		}
		//CRCore::notify(CRCore::ALWAYS)<<"crRecvCorrectPositionMethod "<<std::endl;
	}
}
/////////////////////////////////////////
//
//crRecvAbstractItemMethod
//SceneServer
/////////////////////////////////////////
crRecvAbstractItemMethod::crRecvAbstractItemMethod(){}
crRecvAbstractItemMethod::crRecvAbstractItemMethod(const crRecvAbstractItemMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvAbstractItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvAbstractItemMethod::addParam(int i, const std::string& str)
{
}

void crRecvAbstractItemMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
		if(stream)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			ref_ptr<crInstanceItem> item;
			int itemid = stream->_readInt();
			int sceneid = stream->_readInt();
			int roomid = stream->_readInt();
			int layerid = stream->_readInt();
			int posx = stream->_readInt();
			int posy = stream->_readInt();
			int belongid = stream->_readInt();
			//crSceneServerPlayerData *playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(belongid));
			CRNetApp::crScene *scene = netCallback->findScene(sceneid);
			if(scene)
			{
				item = new crInstanceItem;
				ref_ptr<crAbstractItem> aitem; 
				readAbstractItem(aitem,stream/*,true*/);
				crGlobalHandle::getInstance()->insertAbstractItem(aitem.get());
				item->setAbstractItem(aitem.get());
				item->setInstanceItemID(itemid);
				item->setSceneID(sceneid);
				item->setRoomID(roomid);
				item->setLayerID(layerid);
				item->setItemtype(crInstanceItem::instanceitem);
				item->setPosxy(posx,posy);
				crData *data = CREncapsulation::loadData(aitem->getScript());
				if(data)
				{
					item->setDataClass(data);
					data->excHandle(MAKEINT64(WCH_InitData,item.get()));

					void *param;
					//crData *data = item->getDataClass();
					data->getParam(WCHDATA_Zoffset,param);
					short zoffset = *(short*)param;
					item->setZoffset(zoffset);//
					data->inputParam(WCHDATA_BelongPlayerID,&belongid);
					float posz = scene->getPosZ(item->getLayerID(),item->getPosx() * crGlobalHandle::gData()->gUnitScale(),item->getPosy() * crGlobalHandle::gData()->gUnitScale(), item->getZoffset() * crGlobalHandle::gData()->gUnitScale());
					item->setPosz(posz / crGlobalHandle::gData()->gUnitScale());
					//item->getDataClass()->excHandle(MAKEINT64(WCH_CheckItemData,item.get()));
					//CRCore::notify(CRCore::ALWAYS)<<"crRecvAbstractItemMethod DroppedItem "<<item->getPosx()<<","<<item->getPosy()<<std::endl;
					scene->insertSceneItem(item.get());
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crDropItemUpdateMethod
////
///////////////////////////////////////////
//crDropItemUpdateMethod::crDropItemUpdateMethod():
//m_dt(0.0f),
//m_intevel(0.0f),
//m_time(0.0f){}
//crDropItemUpdateMethod::crDropItemUpdateMethod(const crDropItemUpdateMethod& handle):
//crMethod(handle),
//m_dt(0.0f),
//m_intevel(handle.m_intevel),
//m_time(0.0f)
//{
//}
//void crDropItemUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((float*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0.0f;
//		}
//		break;
//	}
//}
//void crDropItemUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_intevel = atof(str.c_str());
//		break;
//	}
//}
//void crDropItemUpdateMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_dt>0.0f)
//	{
//        m_time+=m_dt;
//		if(m_time>m_intevel)
//		{
//			m_time = 0.0f;
//			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//			crNetDataManager *netDataManager = netConductor->getNetDataManager();
//			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//			CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
//
//			//crItemOutRangePacket packet;
//			//crItemOutRangePacket::buildRequestPacket(packet,0,m_this->getItemtype(),id);
//			//netCallback->sendPacketToItemNeighbor(m_this,packet);
//			scene->wantToRemoveItem(m_this);
//			int id = m_this->getInstanceItemID();
//			if(id<0) crGlobalHandle::recycleItemID(id);
//		}
//	}
//}
/////////////////////////////////////////
//
//crNetPickItemMethod
//
/////////////////////////////////////////
crNetPickItemMethod::crNetPickItemMethod()
{
}
crNetPickItemMethod::crNetPickItemMethod(const crNetPickItemMethod& handle):
crMethod(handle)
{
}
void crNetPickItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crNetPickItemMethod::addParam(int i, const std::string& str)
{
}
void crNetPickItemMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = crMyPlayerData::getInstance()->getPlayerID();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(8);
		stream->_writeInt(playerid);
		stream->_writeInt(crMyPlayerData::getInstance()->getCurrentRole()->getRoleID());
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvNetPickItem,m_this,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		//CRCore::notify(CRCore::ALWAYS)<<"crNetPickItemMethod Abstractid "<<m_this->getAbstractItemID()<<" itemid = "<<m_this->getInstanceItemID()<<std::endl;
	}
}
/////////////////////////////////////////
//
//crRecvNetPickItemMethod
//
/////////////////////////////////////////
crRecvNetPickItemMethod::crRecvNetPickItemMethod(){}
crRecvNetPickItemMethod::crRecvNetPickItemMethod(const crRecvNetPickItemMethod& handle):
crMethod(handle)
{
}
void crRecvNetPickItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvNetPickItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvNetPickItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->getParam(WCHDATA_BelongPlayerID,param);
				int belong = *(int *)param;
				if(belong == playerid)
				{
					crRole *role = playerData->getRole(roleid);
					int itemid = m_this->getInstanceItemID();
					char insertToBackPack = -1;
					role->doEvent(WCH_InsertItemToBackPack,MAKEINT64(m_this,&insertToBackPack));
					thisData->inputParam(WCHDATA_BelongPlayerID,NULL);//避免玩家重复拾取

					//send result
					char needInsertItemChild = 0;
					ref_ptr<crItemChild> itemchild;
					if(insertToBackPack>=0)
					{
						crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						CRNetApp::crScene *scene = netCallback->findScene(role->getSceneID());
						if(insertToBackPack == 1)
						{
							needInsertItemChild = 1;
							if(itemid<0)
							{
								int abstractid = m_this->getAbstractItemID();
								itemchild = role->findTemporaryItemChild(abstractid);
								if(itemchild.valid())
								{
									needInsertItemChild = 2;
									crData *roleData = role->getDataClass();
									roleData->excHandle(MAKEINT64(WCH_LockData,1));
									roleData->getParam(WCHDATA_BackPackMap,param);
									BackPackMap *backPackMap = (BackPackMap *)param;
									BackPackMap::iterator itr = backPackMap->find(abstractid);
									for( ; itr!=backPackMap->end() && itr->first == abstractid; ++itr)
									{
										if(itr->second == m_this->getInstanceItemID())
											itr->second = itemchild->getInstanceItemID();
									}
									roleData->excHandle(MAKEINT64(WCH_LockData,0));
								}
							}
							if(needInsertItemChild==1)
							{
								itemchild = new crItemChild;
								itemchild->setItemChildID(crGlobalHandle::gainTemporaryItemChildID());
								itemchild->setInstanceItem(m_this);
								role->insertChildItem(itemchild.get());
							}
							else
							{
								crGlobalHandle::recycleItemID(itemid);
							}
						}
						else
						{//回收id
							crGlobalHandle::recycleItemID(itemid);
						}
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(17);
						stream->_writeInt(playerid);
						stream->_writeInt(roleid);
						stream->_writeChar(needInsertItemChild);
						if(needInsertItemChild>0)
						{
							stream->_writeInt(itemchild->getItemChildID());
							stream->_writeInt(itemchild->getInstanceItemID());
						}
						else if(needInsertItemChild==0)
						{
							if(itemchild.valid())
								stream->_writeInt(itemchild->getInstanceItemID());
							else
								stream->_writeInt(itemid);
						}

						crItemEventPacket packet;
						crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvNetPickItem,stream.get());
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						//将背包变化同步给附近玩家
						scene->sendPacketToItemNeighbor(role,packet);
						scene->wantToRemoveItem(m_this);
						//role->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
					}
					//CRCore::notify(CRCore::ALWAYS)<<"crRecvNetPickItemMethod Abstractid "<<m_this->getAbstractItemID()<<" itemid = "<<m_this->getInstanceItemID()<<std::endl;
				}
				else
				{//告诉玩家，这件装备不属于他

					return;
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool ipick = false;
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			crRole *picker = NULL;
			if(playerid == crMyPlayerData::getInstance()->getPlayerID())
			{
				picker = crMyPlayerData::getInstance()->getRole(roleid);
				ipick = true;
			}
			else
			{
				crMyPlayerData::RoleNpcPair roleNpcPair;
				if(crMyPlayerData::getInstance()->findInRangePlayer(playerid,roleid,roleNpcPair))
				{
					picker = roleNpcPair.first.get();
				}
			}
			if(!picker)
				return;
			char needInsertItemChild = m_stream->_readChar();
			char insertToBackPack2 = -1;
			if(needInsertItemChild>0)
			{
				int itemchildid = m_stream->_readInt();
				int itemid = m_stream->_readInt();
				ref_ptr<crItemChild> itemchild;
				if(needInsertItemChild==2)
				{
					itemchild = picker->getChildItem(itemchildid);
				}
				if(itemchild.valid())
					m_this->setInstanceItemID(itemid);
				else
				{
					itemchild = new crItemChild;
					m_this->setInstanceItemID(itemid);
					itemchild->setItemChildID(itemchildid);
					itemchild->setInstanceItem(m_this);
					picker->insertChildItem(itemchild.get());
				}
				if(ipick)
				{
					picker->doEvent(WCH_InsertItemToBackPack,MAKEINT64(m_this,&insertToBackPack2));
					picker->doEvent(WCH_BuildBackPackList,NULL);
					//me->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
				}
			}
			else if(needInsertItemChild==0)
			{
				m_this->setInstanceItemID(m_stream->_readInt());
				if(ipick)
				{
					picker->doEvent(WCH_InsertItemToBackPack,MAKEINT64(m_this,&insertToBackPack2));
					picker->doEvent(WCH_BuildBackPackList,NULL);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crInsertItemToBackPackMethod
//
/////////////////////////////////////////
crInsertItemToBackPackMethod::crInsertItemToBackPackMethod():
m_output(NULL){}
crInsertItemToBackPackMethod::crInsertItemToBackPackMethod(const crInsertItemToBackPackMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crInsertItemToBackPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_output = (char *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crInsertItemToBackPackMethod::addParam(int i, const std::string& str)
{
}
void crInsertItemToBackPackMethod::operator()(crHandle &handle)
{//返回-1失败，0覆盖，1插入
	if(m_this && m_item.valid() && m_output)
	{
		*m_output = -1;
		void *param;
		crData *thisData = m_this->getDataClass();
		int abstractid = m_item->getAbstractItemID();
		int itemid = m_item->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap* backPackMap = (BackPackMap* )param;
		thisData->getParam(WCHDATA_MaxBackPack,param);
		unsigned char maxbackpack = *(unsigned char *)param;
		if(itemid<0)
		{
			BackPackMap::iterator bitr = backPackMap->find(abstractid);
			if(bitr == backPackMap->end())
			{//没有重复的
				if(backPackMap->size()<(int)maxbackpack)
				{
					backPackMap->insert(std::make_pair(abstractid,itemid));
					*m_output = 1;
				}
			}
			else
			{
				itemid = bitr->second;
				bool lapover = false;
				thisData->getParam(WCHDATA_ItemCountMap,param);
				ItemCountMap* itemCountMap = (ItemCountMap* )param;
				ItemCountMap::iterator citr = itemCountMap->find(abstractid);
				if(citr == itemCountMap->end())
				{
					//BackPackMap::iterator bitr = backPackMap->find(abstractid);
					for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
					{
						if(bitr->second < 0)
						{
							itemCountMap->insert(std::make_pair(abstractid,2));
							lapover = true;
							break;
						}
					}
				}
				else
				{
					int n = 0;
					for(; citr != itemCountMap->end() && citr->first == abstractid; ++citr)
					{
						if(citr->second < crGlobalHandle::gData()->gMaxLapover())
						{
							citr->second++;
							lapover = true;
							break;
						}
						else
						{
							n++;
						}
					}
					if(!lapover)
					{
						BackPackMap::iterator bitr = backPackMap->find(abstractid);
						for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
						{
							n--;
						}
						if(n<0)
						{
							itemCountMap->insert(std::make_pair(abstractid,2));
							lapover = true;
						}
					}
				}
				if(!lapover)
				{
					if(backPackMap->size()<(int)maxbackpack)
					{
						backPackMap->insert(std::make_pair(abstractid,itemid));
						*m_output = 0;
					}
				}
				else
				{
					*m_output = 0;
				}
			}
		}
		else if(itemid>0)
		{
			if(backPackMap->size()<(int)maxbackpack)
			{
				backPackMap->insert(std::make_pair(abstractid,itemid));
				*m_output = 1;
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		////////////////
	}
}
/////////////////////////////////////////
//
//crUISaleItemMethod
//
/////////////////////////////////////////
crUISaleItemMethod::crUISaleItemMethod()
{
}
crUISaleItemMethod::crUISaleItemMethod(const crUISaleItemMethod& handle):
crMethod(handle),
m_backPackControl(handle.m_backPackControl)
{
}
void crUISaleItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crListControlElement*)param;
}
void crUISaleItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_backPackControl = str;
		break;
	}
}
void crUISaleItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		crListControlElement *backPackControl = dynamic_cast<crListControlElement *>(stage->getElement(m_backPackControl));
		if(backPackControl)
		{
			crListNode *listNode = backPackControl->getSelectNode();
			if(listNode)
			{
				crInstanceItem *item = (crInstanceItem*)(listNode->getData());
				int itemid = item->getInstanceItemID();
				if(itemid>0)
				{///应该弹出确认窗口避免玩家误卖

				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(itemid);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crWaitNetReturnStreamLogic::getLock();
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSaleItem,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
					canceleTask = false;
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUISaleItem2Method
//
/////////////////////////////////////////
crUISaleItem2Method::crUISaleItem2Method()
{
}
crUISaleItem2Method::crUISaleItem2Method(const crUISaleItem2Method& handle):
crMethod(handle)
{
}
void crUISaleItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUISaleItem2Method::addParam(int i, const std::string& str)
{
}
void crUISaleItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	if(m_this)
	{
		crListControlNode *listNode = m_this->getSelectNode();
		if(listNode && listNode->getVisiable())
		{
			crInstanceItem *item = (crInstanceItem*)(listNode->getData());
			int itemid = item->getInstanceItemID();
			const std::string &countStr = listNode->getTitle2();
			int count = atoi(countStr.c_str());
			//if(itemid>0)
			//{///应该弹出确认窗口避免玩家误卖

			//}
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(5);
			stream->_writeInt(itemid);
			if(itemid<0)
				stream->_writeUChar(count);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{//client to server
				crWaitNetReturnStreamLogic::getLock();
				crPlayerServerEventPacket packet;
				crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSaleItem,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				canceleTask = false;
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
///////////////////////////////////////////
////
////crUISaleCountItemMethod
////
///////////////////////////////////////////
//crUISaleCountItemMethod::crUISaleCountItemMethod()
//{
//}
//crUISaleCountItemMethod::crUISaleCountItemMethod(const crUISaleCountItemMethod& handle):
//crMethod(handle)
//{
//}
//void crUISaleCountItemMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crUISaleCountItemMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_saleCountWidget = str;
//		break;
//	case 1:
//		m_priceWidget = str;
//		break;
//	}
//}
//void crUISaleCountItemMethod::operator()(crHandle &handle)
//{
//	bool canceleTask = true;
//	do 
//	{
//		if(!m_this)
//			break;
//		ref_ptr<crCanvasNode> parentCanvas = m_this->getParentCanvas();
//		ref_ptr<crEditWidgetNode> saleCount = dynamic_cast<crEditWidgetNode *>(parentCanvas->getWidget(m_saleCountWidget));
//		const std::wstring& saleCountStr = saleCount->getString();
//		int count = _wtoi(saleCountStr.c_str());
//		crInstanceItem *item = (crInstanceItem *)(crMyPlayerData::getInstance()->getCurrentDialogData());
//		int itemid = item->getInstanceItemID();
//
//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
//		stream->createBuf(5);
//		stream->_writeInt(itemid);
//		if(itemid<0)
//			stream->_writeUChar(count);
//		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//		if(netConductor)
//		{//client to server
//			crWaitNetReturnStreamLogic::getLock();
//			crPlayerServerEventPacket packet;
//			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSaleItem,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
//			netConductor->getNetManager()->sendPacket("all",packet);
//			canceleTask = false;
//		}
//	} while (0);
//	handle.outputParam(0,&canceleTask);
//}
/////////////////////////////////////////
//
//crRecvSaleItemMethod
//
/////////////////////////////////////////
crRecvSaleItemMethod::crRecvSaleItemMethod():
m_netType(GameClient_Game){}
crRecvSaleItemMethod::crRecvSaleItemMethod(const crRecvSaleItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvSaleItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvSaleItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvSaleItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int itemid = m_stream->_readInt();
			int count = 1;
			if(itemid<0 && m_stream->getRemainSize()==1)
				count  = m_stream->_readUChar();
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(itemid!=0 && playerData.valid())
			{
				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_Gold,param);
				int* gold = (int *)param;
				std::vector<char>RemoveItems;
				RemoveItems.reserve(count);
				ref_ptr<crItemChild> itemchild = m_this->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemPrice,param);
					int price = *(int*)param;
					price *= crGlobalHandle::gData()->gSalerate();

					char removeItem;
					for( int i=0; i<count; i++)
					{
						removeItem = -1;
						m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
						if(removeItem>=0)
						{
							if(price != 0)
							{
								*gold += price;
								//m_this->doEvent(WCH_AddGold,MAKEINT64(price,NULL));
							}
							if(removeItem==1)
							{
								if(itemid<0)
								{
									crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
									CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
									crGlobalHandle::recycleItemID(itemid);
									crGlobalHandle::recycleItemChildID(itemchild->getItemChildID());
								}
								else
								{//删除数据库
									crNetConductor *gameConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
									crRemoveItemChildPacket packet;
									crRemoveItemChildPacket::buildRequestPacket(packet,itemchild.get(),playerData->getGameDBID());
									gameConductor->getNetManager()->sendPacket("all",packet);
								}
							}
						}
						RemoveItems.push_back(removeItem);
					}
				}
				count = RemoveItems.size();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(9+count);
				stream->_writeInt(itemid);
				stream->_writeUChar(count);
				for(int i = 0; i<count; i++)
				{
					stream->_writeChar(RemoveItems[i]);
				}
				stream->_writeInt(*gold);
				//if(removeItem>=0)
				//{
				//    stream->_writeInt(itemid);
				//}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvSaleItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			int itemid = m_stream->_readInt();
			int count = m_stream->_readUChar();
			std::vector<char>RemoveItems;
			RemoveItems.reserve(count);
			for(int i=0; i<count; i++)
			{
				RemoveItems.push_back(m_stream->_readChar());
			}
			int gold = m_stream->_readInt();
			void *param;
			crData *data = m_this->getDataClass();
			//钱
			int changevalue = 0;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_Gold,param);
			int* curGold = (int *)param;
			changevalue = gold - *curGold;
			*curGold = gold;
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//客户端显示
			crNode *bot = m_this->getRelNode();
			if(bot)
			{
				bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvGold,MAKEINT32(changevalue,-1)));
			}
			ref_ptr<crItemChild> itemchild = m_this->findChildItem(itemid);
			if(itemchild.valid() && itemchild->isLoaded())
			{
				char removeItem;
				for(int i= 0; i<count; i++)
				{
					removeItem = RemoveItems[i];
					if(removeItem>=0)
					{
						m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(itemchild->getInstanceItem(),&removeItem));
					}
				}
			}
			char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr - ptr2);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crUIRemoveItemMethod
//
/////////////////////////////////////////
crUIRemoveItemMethod::crUIRemoveItemMethod()
{
}
crUIRemoveItemMethod::crUIRemoveItemMethod(const crUIRemoveItemMethod& handle):
crMethod(handle),
m_backPackControl(handle.m_backPackControl)
{
}
void crUIRemoveItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		m_element = (CRGUI::crListControlElement*)param;
		if(param == 0)
		{
			m_stream = NULL;
		}
		break;
	case 3:
        m_stream = (crStreamBuf *)(param);
		break;
	}		
}
void crUIRemoveItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_backPackControl = str;
		break;
	}
}
void crUIRemoveItemMethod::operator()(crHandle &handle)
{
	if(m_element.valid() && m_stream.valid())
	{
		int itemid = m_stream->_readInt();
		int count = m_stream->_readUChar();
		if(count == 1)
		{
			char removeItem = m_stream->_readChar();
			if(removeItem>=0)
			{
				crImageStage *stage = m_element->getParentStage();
				crListControlElement *backPackControl = dynamic_cast<crListControlElement *>(stage->getElement(m_backPackControl));
				if(backPackControl)
				{
					crListNode *listNode = backPackControl->getSelectNode();
					if(listNode)
					{
						std::string title2 = listNode->getTitle2();
						if(title2.empty())
						{//delete
							backPackControl->removeSelectListNode();
						}
						else
						{
							std::string newTitle2;
							int count = atoi(title2.c_str());
							count--;
							if(count > 1)
							{
								newTitle2 = crArgumentParser::appItoa(count);
							}
							listNode->setTitle2(newTitle2);
						}
						backPackControl->updateData();
						stage->setNeedReDraw();
					}
				}
			}
		}
		else
		{
			crMyPlayerData::getInstance()->getCurrentRole()->doEvent(WCH_BuildBackPackList,NULL);
		}
	}
}
/////////////////////////////////////////
//
//crUIRemoveItem2Method
//
/////////////////////////////////////////
crUIRemoveItem2Method::crUIRemoveItem2Method()
{
}
crUIRemoveItem2Method::crUIRemoveItem2Method(const crUIRemoveItem2Method& handle):
crMethod(handle)
{
}
void crUIRemoveItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crUIRemoveItem2Method::addParam(int i, const std::string& str)
{
}
void crUIRemoveItem2Method::operator()(crHandle &handle)
{
	if(m_this)
	{
		int itemid = m_stream->_readInt();
		int count = m_stream->_readUChar();
		if(count == 1)
		{
			char removeItem = m_stream->_readChar();
			if(removeItem>=0)
			{
				crListControlNode *listNode = m_this->getSelectNode();
				if(listNode && listNode->getVisiable())
				{
					std::string title2 = listNode->getTitle2();
					int count = atoi(title2.c_str());
					if(count == 1)
					{//delete
						m_this->removeSelectListNode();
					}
					else
					{
						std::string newTitle2;
						int count = atoi(title2.c_str());
						count--;
						newTitle2 = crArgumentParser::appItoa(count);
						listNode->setTitle2(newTitle2);
					}
				}
			}
		}
		else
		{
			crMyPlayerData::getInstance()->getCurrentRole()->doEvent(WCH_BuildBackPackList,NULL);
		}
	}
}
/////////////////////////////////////////
//
//crRemoveItemFromBackPackMethod
//
/////////////////////////////////////////
crRemoveItemFromBackPackMethod::crRemoveItemFromBackPackMethod():
m_output(NULL){}
crRemoveItemFromBackPackMethod::crRemoveItemFromBackPackMethod(const crRemoveItemFromBackPackMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crRemoveItemFromBackPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_output = (char *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crRemoveItemFromBackPackMethod::addParam(int i, const std::string& str)
{
}
void crRemoveItemFromBackPackMethod::operator()(crHandle &handle)
{//返回-1失败，0减数量，1删除
	if(m_this && m_item.valid() && m_output)
	{
		*m_output = -1;
		void *param;
		crData *thisData = m_this->getDataClass();
		int abstractid = m_item->getAbstractItemID();
		int itemid = m_item->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap* backPackMap = (BackPackMap* )param;
		if(itemid>0)
		{
			BackPackMap::iterator bitr = backPackMap->find(abstractid);
			for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
			{
				if(bitr->second == itemid)
				{
					backPackMap->erase(bitr);
					*m_output = 1;
					break;
				}
			} 
		}
		else if(itemid<0)
		{
			thisData->getParam(WCHDATA_ItemCountMap,param);
			ItemCountMap* itemCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr = itemCountMap->find(abstractid);
			if(citr == itemCountMap->end())
			{
				BackPackMap::iterator bitr = backPackMap->find(abstractid);
				for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
				{
					if(bitr->second == itemid)
					{
						backPackMap->erase(bitr);
						*m_output = 1;
						break;
					}
				} 
			}
			else
			{
				int count1 = 0;
				int count2 = 0;
				BackPackMap::iterator bitr = backPackMap->find(abstractid);
				for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
				{
					if(bitr->second<0)
                        count1++;
				}
				for(; citr != itemCountMap->end() && citr->first == abstractid; ++citr)
				{
					count2++;
				}
				if(count1>count2)
				{
					bitr--;
                    backPackMap->erase(bitr);
				}
				else/* if(count1 == count2)*/
				{
					citr--;
					citr->second--;
					if(citr->second == 1)
						itemCountMap->erase(citr);
				}
				*m_output = 0;
			}
			crData *itemData = m_item->getDataClass();
			if(itemData)
			{
				itemData->getParam(WCHDATA_DataType,param);
				unsigned char dataType = *(unsigned char *)param;
				if(dataType == DT_Equip)
				{
					if(*m_output == 1)
					{//检查EquipOnMap里是否存在
						thisData->getParam(WCHDATA_EquipOnMap,param);
						EquipOnMap *equipOnMap = (EquipOnMap *)param;
						EquipOnMap::iterator itr = equipOnMap->find(abstractid);
						for( ; itr != equipOnMap->end() && itr->first == abstractid; ++itr)
						{
							if(itr->second == itemid)
							{
								*m_output = 0;
								break;
							}
						}
					}
				}
				else if((dataType == DT_Thing || dataType == DT_AttackThing) && *m_output == 1)
				{//检查QuickList里是否存在
					thisData->getParam(WCHDATA_QuickList,param);
					QuickList *quickList = (QuickList *)param;
					QuickList::iterator itr = quickList->begin();
					bool found = false;
					for( ; itr != quickList->end() && itr->first == abstractid; ++itr)
					{
						if(itr->second == itemid)
						{
							found = true;
							break;
						}
					}
					if(found)
					{
						quickList->erase(itr);
					}
				}
			}
			//最后检查仓库里是否存在
			if(*m_output == 1)
			{
				thisData->getParam(WCHDATA_StorageMap,param);
				StorageMap *storageMap = (StorageMap *)param;
				StorageMap::iterator itr = storageMap->find(abstractid);
				for( ; itr != storageMap->end() && itr->first == abstractid; ++itr)
				{
					if(itr->second == itemid)
					{
						*m_output = 0;
						break;
					}
				}
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(*m_output == 1)
		{
			crItemChild* itemchild = m_this->findChildItem(itemid);
			if(itemchild && itemchild->isLoaded())
			{
				m_this->removeChildItem(itemchild->getItemChildID());
			}
		}
	}
}
/////////////////////////////////////////
//
//crGetItemCountInBackPackMethod
//
/////////////////////////////////////////
crGetItemCountInBackPackMethod::crGetItemCountInBackPackMethod():
m_output(NULL){}
crGetItemCountInBackPackMethod::crGetItemCountInBackPackMethod(const crGetItemCountInBackPackMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crGetItemCountInBackPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_output = (short *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crGetItemCountInBackPackMethod::addParam(int i, const std::string& str)
{
}
void crGetItemCountInBackPackMethod::operator()(crHandle &handle)
{//返回-1失败，0减数量，1删除
	if(m_this && m_item.valid() && m_output)
	{
		*m_output = 0;
		void *param;
		crData *thisData = m_this->getDataClass();
		int abstractid = m_item->getAbstractItemID();
		int itemid = m_item->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap* backPackMap = (BackPackMap* )param;
		if(itemid>0)
		{
			BackPackMap::iterator bitr = backPackMap->find(abstractid);
			for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
			{
				if(bitr->second == itemid)
				{
					*m_output = 1;
					break;
				}
			} 
		}
		else if(itemid<0)
		{
			BackPackMap::iterator bitr = backPackMap->find(abstractid);
			if(bitr != backPackMap->end())
			{
				thisData->getParam(WCHDATA_ItemCountMap,param);
				ItemCountMap* itemCountMap = (ItemCountMap* )param;
				for( ItemCountMap::iterator citr = itemCountMap->find(abstractid);
					citr != itemCountMap->end() && citr->first == abstractid;
					++citr )
				{
					*m_output += citr->second;
				}
				if(*m_output == 0)
					*m_output = 1;
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crBuildBackPackListMethod
//
/////////////////////////////////////////
crBuildBackPackListMethod::crBuildBackPackListMethod(){}
crBuildBackPackListMethod::crBuildBackPackListMethod(const crBuildBackPackListMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_backPackList(handle.m_backPackList)
{
}
void crBuildBackPackListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crBuildBackPackListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_backPackList = str;
		break;
	}
}
void crBuildBackPackListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		if(!crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			return;
		crListControlElement *backPackList = dynamic_cast<crListControlElement *>(imageStage->getElement(m_backPackList));
		if(backPackList)
		{
			backPackList->clear();
			backPackList->lockList();
			crListControlElement::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
			//crRole *me = crMyPlayerData::getInstance()->getRole();
			void *param;
			crData *myData = m_this->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_BackPackMap,param);
			BackPackMap* backPackMap = (BackPackMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			myData->getParam(WCHDATA_ItemCountMap,param);
			ItemCountMap* itemCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr;
			unsigned char count;
			std::string title,title2;
			std::map<int,int> FindCount;
			std::map<int,int>::iterator FindCountItr;
			int offset;
			for( BackPackMap::iterator itr = backPackMap->begin();
				itr != backPackMap->end();
				++itr )
			{
				if(itr->second!=0)
				{
					itemchild = m_this->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						if(!itemData)
							continue;
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;

						title = item->getIName();
						title2.clear();
						if(itr->second<0)
						{
							citr = itemCountMap->find(itr->first);
							if(citr!=itemCountMap->end())
							{
								FindCountItr = FindCount.find(itr->first);
								if(FindCountItr==FindCount.end())
								{
									FindCount[itr->first] = 1;
									count = citr->second;
								}
								else
								{
									offset = FindCountItr->second;
									for(citr++;citr!=itemCountMap->end()&&citr->first==itr->first;citr++)
									{
										offset--;
										if(offset==0)
											break;
									}
									if(offset==0)
									{
										count = citr->second;
										FindCountItr->second++;
									}
									else
									{
										count = 1;
									}
								}
								//if(count>1)
								title2 = crArgumentParser::appItoa((int)count);
							}
							else
								title2 = crArgumentParser::appItoa(1);
						}
						listNode = new crListNode;
						listNode->setTitle(title);
						listNode->setTitle2(title2);
						listNode->setData(item);
						listNode->addBitMapFile(iconfile);
						listNodeVec.push_back(listNode.get());
					}
				}
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			backPackList->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildBackPackList2Method
//
/////////////////////////////////////////
crBuildBackPackList2Method::crBuildBackPackList2Method(){}
crBuildBackPackList2Method::crBuildBackPackList2Method(const crBuildBackPackList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_listName(handle.m_listName)
{
}
void crBuildBackPackList2Method::inputParam(int i, void *param)
{
}
void crBuildBackPackList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_listName = str;
		break;
	}
}
void crBuildBackPackList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_listName));
		if(backPackList.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *myData = me->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_BackPackMap,param);
			BackPackMap* backPackMap = (BackPackMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			myData->getParam(WCHDATA_ItemCountMap,param);
			ItemCountMap* itemCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr;
			unsigned char count;
			std::string title,title2;
			std::map<int,int> FindCount;
			std::map<int,int>::iterator FindCountItr;
			int offset;
			backPackList->setListNodeCount(backPackMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
			int i = 0;
			for( BackPackMap::iterator itr = backPackMap->begin();
				itr != backPackMap->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second!=0)
				{
					itemchild = me->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						if(!itemData)
							continue;
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;

						title = item->getIName();
						title2.clear();
						if(itr->second<0)
						{
							citr = itemCountMap->find(itr->first);
							if(citr!=itemCountMap->end())
							{
								FindCountItr = FindCount.find(itr->first);
								if(FindCountItr==FindCount.end())
								{
									FindCount[itr->first] = 1;
									count = citr->second;
								}
								else
								{
									offset = FindCountItr->second;
									for(citr++;citr!=itemCountMap->end()&&citr->first==itr->first;citr++)
									{
										offset--;
										if(offset==0)
											break;
									}
									if(offset==0)
									{
										count = citr->second;
										FindCountItr->second++;
									}
									else
									{
										count = 1;
									}
								}
								title2 = crArgumentParser::appItoa((int)count);
							}
							else
								title2 = crArgumentParser::appItoa(1);
						}
						listNodeVec[i]->setTitle(title);
						listNodeVec[i]->setTitle2(title2);
						listNodeVec[i]->setData(item);
						listNodeVec[i]->setImageName(iconfile);
						listNodeVec[i]->setVisiable(true);
					}
				}
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crWaitNetReturnStreamLockMethod
//
/////////////////////////////////////////
crWaitNetReturnStreamLockMethod::crWaitNetReturnStreamLockMethod(){}
crWaitNetReturnStreamLockMethod::crWaitNetReturnStreamLockMethod(const crWaitNetReturnStreamLockMethod& handle):
crMethod(handle)
{
}
void crWaitNetReturnStreamLockMethod::inputParam(int i, void *param)
{
}
void crWaitNetReturnStreamLockMethod::addParam(int i, const std::string& str)
{
}
void crWaitNetReturnStreamLockMethod::operator()(crHandle &handle)
{
	crWaitNetReturnStreamLogic::getLock();
}
/////////////////////////////////////////
//
//crUIDropItemMethod
//
/////////////////////////////////////////
crUIDropItemMethod::crUIDropItemMethod()
{
}
crUIDropItemMethod::crUIDropItemMethod(const crUIDropItemMethod& handle):
crMethod(handle),
m_backPackControl(handle.m_backPackControl)
{
}
void crUIDropItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crListControlElement*)param;
}
void crUIDropItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_backPackControl = str;
		break;
	}
}
void crUIDropItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		crListControlElement *backPackControl = dynamic_cast<crListControlElement *>(stage->getElement(m_backPackControl));
		if(backPackControl)
		{
			crListNode *listNode = backPackControl->getSelectNode();
			if(listNode)
			{
				crInstanceItem *item = (crInstanceItem*)(listNode->getData());
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(item->getInstanceItemID());
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crWaitNetReturnStreamLogic::getLock();
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvDropItem,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
					canceleTask = false;
					//CRCore::notify(CRCore::ALWAYS)<<"crUIDropItemMethod "<<item->getInstanceItemID()<<std::endl;
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIDropItem2Method
//
/////////////////////////////////////////
crUIDropItem2Method::crUIDropItem2Method()
{
}
crUIDropItem2Method::crUIDropItem2Method(const crUIDropItem2Method& handle):
crMethod(handle)
{
}
void crUIDropItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUIDropItem2Method::addParam(int i, const std::string& str)
{
}
void crUIDropItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this) break;

		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode||!listNode->getVisiable()) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		if(!me) break;
		crData *thisData = me->getDataClass();
		void *param;
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap* backPackMap = (BackPackMap* )param;
		bool foundInBackPack = false;
		int abstractid = item->getAbstractItemID();
		int itemid = item->getInstanceItemID();
		BackPackMap::iterator bitr = backPackMap->find(abstractid);
		for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
		{
			if(bitr->second == itemid)
			{
				foundInBackPack = true;
				break;
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		if(foundInBackPack)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(itemid);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{//client to server
				crWaitNetReturnStreamLogic::getLock();
				crPlayerServerEventPacket packet;
				crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvDropItem,me,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				canceleTask = false;
				//CRCore::notify(CRCore::ALWAYS)<<"crUIDropItem2Method "<<item->getInstanceItemID()<<std::endl;
			}
		}
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvDropItemMethod
//
/////////////////////////////////////////
crRecvDropItemMethod::crRecvDropItemMethod():
m_netType(GameClient_Game){}
crRecvDropItemMethod::crRecvDropItemMethod(const crRecvDropItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
	m_dropRangei.set(-500,500);
}
void crRecvDropItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvDropItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		{
            int r = atoi(str.c_str());
			m_dropRangei.set(-r,r);
		}
		break;
	}
}
void crRecvDropItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int itemid = m_stream->_readInt();
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(itemid!=0 && playerData.valid())
			{
				char removeItem = -1;
				ref_ptr<crItemChild> itemchild = m_this->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
					if(removeItem>=0)
					{
						crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
						float posx,posy,posz;
						posx = m_this->getPosx() + m_dropRangei.get_random();
						posy = m_this->getPosy() + m_dropRangei.get_random();
						void *param;
						crData *data = item->getDataClass();
						data->getParam(WCHDATA_Zoffset,param);
						short zoffset = *(short*)param;
						posz = scene->getPosZ(m_this->getLayerID(),posx * crGlobalHandle::gData()->gUnitScale(),posy * crGlobalHandle::gData()->gUnitScale(), zoffset * crGlobalHandle::gData()->gUnitScale());
						posz /= crGlobalHandle::gData()->gUnitScale();

						ref_ptr<crInstanceItem> newitem;
						if(removeItem == 0)
						{
							newitem = dynamic_cast<crInstanceItem *>(item->clone());
							newitem->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
						}
						else if(removeItem==1)
						{
							crGlobalHandle::recycleItemChildID(itemchild->getItemChildID());
							newitem = item;
						}
						newitem->setRoomID(playerData->getRoomID());
						newitem->setPosxy(posx,posy);
						newitem->setPosz(posz);
						newitem->setZoffset(zoffset);
						newitem->setLayerID(m_this->getLayerID());
						newitem->setSceneID(scene->getSceneID());
						data = newitem->getDataClass();
						data->inputParam(WCHDATA_BelongPlayerID,&playerid);
                        scene->insertSceneItem(newitem.get());

						if(itemid>0)
						{//删除数据库
							crNetConductor *gameConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
							crRemoveItemChildPacket packet;
							crRemoveItemChildPacket::buildRequestPacket(packet,itemchild.get(),playerData->getGameDBID());
							gameConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeChar(removeItem);
				if(removeItem>=0)
				{
					stream->_writeInt(itemid);
				}
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvDropItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char removeItem = m_stream->_readChar();
            if(removeItem>=0)
			{
				int itemid = m_stream->_readInt();
				ref_ptr<crItemChild> itemchild = m_this->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					char removeItem2 = -1;
					m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(itemchild->getInstanceItem(),&removeItem2));
				}
			}
            char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr-ptr2);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crBuildSaleItemListMethod
//
/////////////////////////////////////////
crBuildSaleItemListMethod::crBuildSaleItemListMethod(){}
crBuildSaleItemListMethod::crBuildSaleItemListMethod(const crBuildSaleItemListMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_saleItemList(handle.m_saleItemList)
{
}
void crBuildSaleItemListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildSaleItemListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_saleItemList = str;
		break;
	}
}

void crBuildSaleItemListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		crListControlElement *saleItemList = dynamic_cast<crListControlElement *>(imageStage->getElement(m_saleItemList));
		if(saleItemList)
		{
			saleItemList->clear();
			saleItemList->lockList();
			crListControlElement::ListNodeVec& listNodeVec = saleItemList->getListNodeVec();
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap* saleItemMap = (SaleItemMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			std::string title,title2;
			for( SaleItemMap::iterator itr = saleItemMap->begin();
				itr != saleItemMap->end();
				++itr )
			{
				if(itr->second[0]==0)
				{
                    continue;
				}
				if(itr->second[1]==0)
				{//-1表示无穷，0表示没有库存
					continue;
				}
				itemchild = m_this->findChildItem(itr->second[0]);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;

					title = item->getIName();
					title2.clear();

					if(itr->second[1]>0)
					{
						title2 = crArgumentParser::appItoa(itr->second[1]);
					}
					if(itr->second[2]==0)
					{
						itemData->getParam(WCHDATA_ItemPrice,param);
						itr->second[2] = *(int *)param;
					}
					listNode = new crListNode;
					listNode->setTitle(title);
					listNode->setTitle2(title2);
					listNode->setData(&(itr->second));
					listNode->addBitMapFile(iconfile);
					listNodeVec.push_back(listNode.get());
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			saleItemList->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildSaleItemList2Method
//
/////////////////////////////////////////
crBuildSaleItemList2Method::crBuildSaleItemList2Method(){}
crBuildSaleItemList2Method::crBuildSaleItemList2Method(const crBuildSaleItemList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_saleItemList(handle.m_saleItemList)
{
}
void crBuildSaleItemList2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildSaleItemList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_saleItemList = str;
		break;
	}
}

void crBuildSaleItemList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid() && m_this)
	{
		ref_ptr<crListControlWidgetNode>saleItemList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_saleItemList));
		if(saleItemList.valid())
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap* saleItemMap = (SaleItemMap* )param;

			saleItemList->setListNodeCount(saleItemMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = saleItemList->getListNodeVec();
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListControlNode> listNode;
			std::string title,title2;
			int i = 0;
			for( SaleItemMap::iterator itr = saleItemMap->begin();
				itr != saleItemMap->end();
				++itr )
			{
				if(itr->second[0]==0)
				{
					continue;
				}
				if(itr->second[1]==0)
				{//-1表示无穷，0表示没有库存
					continue;
				}
				itemchild = m_this->findChildItem(itr->second[0]);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;

					title = item->getIName();
					title2.clear();

					if(itr->second[1]>0)
					{
						title2 = crArgumentParser::appItoa(itr->second[1]);
					}
					if(itr->second[2]==0)
					{
						itemData->getParam(WCHDATA_ItemPrice,param);
						itr->second[2] = *(int *)param;
					}
					listNodeVec[i]->setTitle(title);
					listNodeVec[i]->setTitle2(title2);
					listNodeVec[i]->setData(&(itr->second));
					listNodeVec[i]->setImageName(iconfile);
					listNodeVec[i]->setVisiable(true);
					++i;
				}
			}
			saleItemList->setListNodeCount(i);
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crUIShowPriceMethod
//
/////////////////////////////////////////
crUIShowPriceMethod::crUIShowPriceMethod():
m_flg(0){}
crUIShowPriceMethod::crUIShowPriceMethod(const crUIShowPriceMethod& handle):
crMethod(handle),
m_priceText(handle.m_priceText),
m_flg(handle.m_flg)
{
}
void crUIShowPriceMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_itemListElement = (CRGUI::crListControlElement*)param;
}

void crUIShowPriceMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_priceText = str;
		break;
	case 1:
		m_flg = (char)(atoi(str.c_str()));
		break;
	}
}

void crUIShowPriceMethod::operator()(crHandle &handle)
{
	if(m_itemListElement.valid())
	{
		crImageStage *stage = m_itemListElement->getParentStage();
		crStaticTextBoxElement *priceElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_priceText));
        crListNode *listNode = m_itemListElement->getSelectNode();
		if(listNode)
		{
			int itemPrice = 0;
			if(m_flg == 0)
			{
				crVector3i *saleParam = (crVector3i *)(listNode->getData());
				if(saleParam)
				{
					itemPrice = (*saleParam)[2];
				}
			}
			else if(m_flg == 1)
			{
				crInstanceItem *item = (crInstanceItem *)(listNode->getData());
				if(item)
				{
					void *param;
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemPrice,param);
					itemPrice = *(int *)param;
					itemPrice *= crGlobalHandle::gData()->gSalerate();
				}
			}
			priceElement->setStringArrayByString(crArgumentParser::appItoa(itemPrice));
		}
		else
		{
			priceElement->setStringArrayByString(crArgumentParser::appItoa(0));
		}
	}
}
/////////////////////////////////////////
//
//crUIBuyItemMethod
//
/////////////////////////////////////////
crUIBuyItemMethod::crUIBuyItemMethod()
{
}
crUIBuyItemMethod::crUIBuyItemMethod(const crUIBuyItemMethod& handle):
crMethod(handle),
m_listControl(handle.m_listControl)
{
}
void crUIBuyItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crListControlElement*)param;
}
void crUIBuyItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_listControl = str;
		break;
	}
}
void crUIBuyItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		crListControlElement *listControl = dynamic_cast<crListControlElement *>(stage->getElement(m_listControl));
		if(listControl)
		{
			crListNode *listNode = listControl->getSelectNode();
			if(listNode)
			{
				crVector3i *saleParam = (crVector3i *)(listNode->getData());
				if(!saleParam || (*saleParam)[1]==0)
				{//ui提示没有库存
					//std::string str = "没有库存了，请下次再来！";
					//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(30,NULL));
				}
				else
				{
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{//client to server
						crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
						ref_ptr<crInstanceItem> targetItem;
						ref_ptr<crMatrixTransform> targetNode;
						me->clientGetTarget(targetItem,targetNode);
						//me->doEvent(MAKEINT64(WCH_GetTarget,WCH_Client),MAKEINT64(&targetItem,&targetNode));
						if(targetItem.valid())
						{
							crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
							if(itemchild && itemchild->isLoaded())
							{
								//检查钱
								void *param;
								int gold = 0;
								crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
								crData *_data = NULL;
								if(playerGameData) _data = playerGameData->getDataClass();
								if(_data)
								{
									_data->getParam(WCHDATA_Gold,param);
									gold = *(int *)param;
								}
								else
								{
									crData *myData = me->getDataClass();
									myData->getParam(WCHDATA_Gold,param);
									gold = *(int *)param;
								}
								if(gold>=(*saleParam)[2])
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(12);
									stream->_writeInt(me->getPlayerID());
									stream->_writeInt(me->getRoleID());
									stream->_writeInt((*saleParam)[0]);
									crWaitNetReturnStreamLogic::getLock();
									crPlayerServerEventPacket packet;
									crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvBuyItem,targetItem.get(),stream.get());
									netConductor->getNetManager()->sendPacket("all",packet);
									canceleTask = false;
									//CRCore::notify(CRCore::ALWAYS)<<"crUIBuyItemMethod "<<std::endl;
								}
								else
								{
									//std::string str = "您没有足够的金币！";
									//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(31,NULL));
								}
							}
						}
					}
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIBuyItem2Method
//
/////////////////////////////////////////
crUIBuyItem2Method::crUIBuyItem2Method():
m_emporium(false)
{
}
crUIBuyItem2Method::crUIBuyItem2Method(const crUIBuyItem2Method& handle):
crMethod(handle),
m_emporium(handle.m_emporium)
{
}
void crUIBuyItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_selectIndex = LOINT64(param64);
	//	}
	//	else
	//	{
	//		m_selectIndex = -1;
	//	}
	//	break;
	}
}
void crUIBuyItem2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_emporium = (bool)(atoi(str.c_str()));
		break;
	}
}
void crUIBuyItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this)
			break;
		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode || !listNode->getVisiable())
		{
			break;
		}
		crVector3i *saleParam = (crVector3i *)(listNode->getData());
		if(!saleParam || (*saleParam)[1]==0)
		{//ui提示没有库存
			//std::string str = "没有库存了，请下次再来！";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(30,NULL));
		}
		else
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{//client to server
				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
				ref_ptr<crInstanceItem> targetItem;
				if(m_emporium)
				{
					targetItem = crMyPlayerData::getInstance()->getScene()->getEmporium();
				}
				else
				{
					ref_ptr<crMatrixTransform> targetNode;
					me->clientGetTarget(targetItem,targetNode);
				}
				if(targetItem.valid())
				{
					crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
					if(itemchild && itemchild->isLoaded())
					{
						//检查钱
						void *param;
						int gold = 0;
						crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
						crData *_data = NULL;
						if(playerGameData) _data = playerGameData->getDataClass();
						if(_data)
						{
							_data->getParam(WCHDATA_Gold,param);
							gold = *(int *)param;
						}
						else
						{
							crData *myData = me->getDataClass();
							myData->getParam(WCHDATA_Gold,param);
							gold = *(int *)param;
						}
						if(gold>=(*saleParam)[2])
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(12);
							stream->_writeInt(me->getPlayerID());
							stream->_writeInt(me->getRoleID());
							stream->_writeInt((*saleParam)[0]);
							crWaitNetReturnStreamLogic::getLock();
							crPlayerServerEventPacket packet;
							crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvBuyItem,targetItem.get(),stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
							canceleTask = false;
							//CRCore::notify(CRCore::ALWAYS)<<"crUIBuyItemMethod "<<std::endl;
						}
						else
						{
							//std::string str = "您没有足够的金币！";
							//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(31,NULL));
						}
					}
				}
			}
		}
	} while (0);
	handle.outputParam(0,&canceleTask);
}
///////////////////////////////////////////
////
////crUIBuyCountItemMethod
////
///////////////////////////////////////////
//crUIBuyCountItemMethod::crUIBuyCountItemMethod()
//{
//}
//crUIBuyCountItemMethod::crUIBuyCountItemMethod(const crUIBuyCountItemMethod& handle):
//crMethod(handle)
//{
//}
//void crUIBuyCountItemMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crListControlWidgetNode*)param;
//		break;
//	}
//}
//void crUIBuyCountItemMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_buyCountWidget = str;
//		break;
//	case 1:
//		m_priceWidget = str;
//		break;
//	}
//}
//void crUIBuyCountItemMethod::operator()(crHandle &handle)
//{
//	bool canceleTask = true;
//	do 
//	{
//		if(!m_this)
//			break;
//		ref_ptr<crCanvasNode> parentCanvas = m_this->getParentCanvas();
//		ref_ptr<crEditWidgetNode> buyCount = dynamic_cast<crEditWidgetNode *>(parentCanvas->getWidget(m_buyCountWidget));
//		const std::wstring& buyCountStr = buyCount->getString();
//		int count = _wtoi(buyCountStr.c_str());
//		crVector3i *saleParam = (crVector3i *)(crMyPlayerData::getInstance()->getCurrentDialogData());
//		if(!saleParam || (*saleParam)[1]==0)
//		{//ui提示没有库存
//			//std::string str = "没有库存了，请下次再来！";
//			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(30,NULL));
//		}
//		else
//		{
//			if((*saleParam)[0]>0)
//				count = 1;
//			else if((*saleParam)[1]>0 && count > (*saleParam)[1])
//				count = (*saleParam)[1];
//			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//			if(netConductor)
//			{//client to server
//				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
//				ref_ptr<crInstanceItem> targetItem;
//				bool isEmporium = crMyPlayerData::getInstance()->getSaleDialogEmporium();
//				if(isEmporium)
//				{
//					targetItem = crMyPlayerData::getInstance()->getScene()->getEmporium();
//				}
//				else
//				{
//					ref_ptr<crMatrixTransform> targetNode;
//					me->clientGetTarget(targetItem,targetNode);
//				}
//				if(targetItem.valid())
//				{
//					crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
//					if(itemchild && itemchild->isLoaded())
//					{
//						//检查钱
//						void *param;
//						int gold = 0;
//						crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//						crData *_data = NULL;
//						if(playerGameData) _data = playerGameData->getDataClass();
//						if(_data)
//						{
//							_data->getParam(WCHDATA_Gold,param);
//							gold = *(int *)param;
//						}
//						else
//						{
//							crData *myData = me->getDataClass();
//							myData->getParam(WCHDATA_Gold,param);
//							gold = *(int *)param;
//						}
//						if(gold>=count * (*saleParam)[2])
//						{
//							ref_ptr<crStreamBuf> stream = new crStreamBuf;
//							stream->createBuf(13);
//							stream->_writeInt(me->getPlayerID());
//							stream->_writeInt(me->getRoleID());
//							stream->_writeInt((*saleParam)[0]);
//							if((*saleParam)[0]<0)
//								stream->_writeUChar(count);
//							crWaitNetReturnStreamLogic::getLock();
//							crPlayerServerEventPacket packet;
//							crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvBuyItem,targetItem.get(),stream.get());
//							netConductor->getNetManager()->sendPacket("all",packet);
//							canceleTask = false;
//							//CRCore::notify(CRCore::ALWAYS)<<"crUIBuyCountItemMethod "<<std::endl;
//						}
//						else
//						{
//							//std::string str = "您没有足够的金币！";
//							//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(31,NULL));
//						}
//					}
//				}
//			}
//		}
//	} while (0);
//	handle.outputParam(0,&canceleTask);
//}
/////////////////////////////////////////
//
//crRecvBuyItemMethod
//
/////////////////////////////////////////
crRecvBuyItemMethod::crRecvBuyItemMethod():
m_netType(GameClient_Game){}
crRecvBuyItemMethod::crRecvBuyItemMethod(const crRecvBuyItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvBuyItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvBuyItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvBuyItemMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			int itemid = m_stream->_readInt();
			int count = 1;
			if(itemid<0 && m_stream->getRemainSize() == 1)
				count = (int)(m_stream->_readUChar());
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
		    if(playerData.valid())
			{
				char buyItemReturn = BC_Success;
				do 
				{
					crItemChild *buyitemchild = m_this->findChildItem(itemid);
					if(!buyitemchild || !buyitemchild->isLoaded()) 
					{
						buyItemReturn = BC_Error;
						break;
					}
					crInstanceItem *buyitem = buyitemchild->getInstanceItem();
					crData *buyItemData = buyitem->getDataClass();
					//检查钱是否够
					void *param;
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_SaleItemMap,param);
					SaleItemMap* saleItemMap = (SaleItemMap* )param;
					if(!saleItemMap)
					{
						buyItemReturn = BC_Error;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					bool found = false;
					int price = 0;
					SaleItemMap::iterator saleItemItr;
					int* buyerGold = NULL;
					int abstractid = buyitem->getAbstractItemID();
					saleItemItr = saleItemMap->find(abstractid);
					for( ; saleItemItr!=saleItemMap->end() && saleItemItr->first == abstractid; ++saleItemItr )
					{
						if(saleItemItr->second[0] == itemid)
						{
							if(saleItemItr->second[1] != 0)
							{
								found = true;
								break;
							}
						}
					}
					if(!found)
					{
                        buyItemReturn = BC_SaleOut;
                        thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					if(saleItemItr->second[1] != -1 && saleItemItr->second[1] < count)
					{
						count = saleItemItr->second[1];
					}
					if(saleItemItr->second[2] == 0)
					{
						buyItemData->getParam(WCHDATA_ItemPrice,param);
						price = *(int*)param;
						saleItemItr->second[2] = price;
					}
					else
					{
						price = saleItemItr->second[2];
					}

					crRole *buyer = playerData->getRole(roleid);
					crData *buyerData = buyer->getDataClass();
					buyerData->excHandle(MAKEINT64(WCH_LockData,1));//锁定，避免交易过程中玩家的金币发生变化
					crPlayerGameData *playerGameData = buyer->getPlayerGameData();
					crData *_data = NULL;
					if(playerGameData) _data = playerGameData->getDataClass();
					if(_data)
					{
						_data->excHandle(MAKEINT64(WCH_LockData,1));//锁定，避免交易过程中玩家的金币发生变化
						_data->getParam(WCHDATA_Gold,param);
						buyerGold = (int*)param;
					}
					else
					{
						buyerData->getParam(WCHDATA_Gold,param);
						buyerGold = (int*)param;
					}
					if(*buyerGold<price * count)
					{
						buyItemReturn = BC_MoneyNotEnough;
						buyerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						if(_data) _data->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					///检查背包
					buyerData->getParam(WCHDATA_BackPackMap,param);
					BackPackMap* backPackMap = (BackPackMap* )param;
					if(!backPackMap)
					{
						buyItemReturn = BC_Error;
						buyerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						if(_data) _data->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					buyerData->getParam(WCHDATA_MaxBackPack,param);
					unsigned char maxBackPack = *(unsigned char *)param;
					if((int)maxBackPack<=backPackMap->size())
					{
						buyItemReturn = BC_BackpackIsFull;
						buyerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						if(_data) _data->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					///购买（先收货，后扣钱）
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					CRNetApp::crScene *scene = callback->findScene(m_this->getSceneID());
					ref_ptr<crInstanceItem> newitem;
                    if(itemid<0)
					{
                        newitem = dynamic_cast<crInstanceItem *>(buyitem->clone());
						newitem->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
					}
					else
					{//itemid>0
						newitem = buyitem;
					}
					//放入背包
					int relcount = 0;
					std::vector< std::pair< char,ref_ptr<crItemChild> > >InsertBackPackVec;
					ref_ptr<crItemChild> newItemChild;
					for(;relcount<count;relcount++)
					{
						char insertToBackPack = -1;
						char needInsertItemChild = 0;
						buyer->doEvent(WCH_InsertItemToBackPack,MAKEINT64(newitem.get(),&insertToBackPack));
						if(insertToBackPack>=0)
						{//成功
							if(insertToBackPack == 1)
							{
								needInsertItemChild = 1;
								if(itemid<0)
								{
									//检查是否需要insertChildItem
									newItemChild = buyer->findTemporaryItemChild(abstractid);
									if(!newItemChild.valid())
									{
										newItemChild = new crItemChild;
										newItemChild->setItemChildID(crGlobalHandle::gainTemporaryItemChildID());
										newItemChild->setInstanceItem(newitem.get());
									}
									else
									{
										crGlobalHandle::recycleItemID(newitem->getInstanceItemID());
										needInsertItemChild = 2;

										BackPackMap::iterator itr = backPackMap->find(abstractid);
										for( ; itr!=backPackMap->end() && itr->first == abstractid; ++itr)
										{
											if(itr->second == newitem->getInstanceItemID())
												itr->second = newItemChild->getInstanceItemID();
										}
									}
								}
								else
								{//itemid>0，NPC不出售itemid>0的
									//更新数据库
									//如果saler与buyer的gamedbid不同，则需要删除saler的，在buyer重建否则更新操作
									//crNetConductor *gameConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
									//crChangeItemChildParentPacket packet;
									//crChangeItemChildParentPacket::buildRequestPacket(packet,itemchild.get(),playerData->getGameDBID());
									//gameConductor->getNetManager()->sendPacket("all",packet);
									//crRemoveItemChildPacket packet;
									//crRemoveItemChildPacket::buildRequestPacket(packet,itemchild.get(),playerData->getGameDBID());
									//gameConductor->getNetManager()->sendPacket("all",packet);
									//确认数据库更新操作是否成功
									newItemChild = buyitemchild;
									m_this->removeChildItem(buyitemchild->getItemChildID());
								}
								if(needInsertItemChild == 1)
									buyer->insertChildItem(newItemChild.get());
							}
							else
							{//回收id
								//>0的item在插入背包时候是不能覆盖的
								crGlobalHandle::recycleItemID(newitem->getInstanceItemID());
							}
							crData *data = newitem->getDataClass();
							data->inputParam(WCHDATA_BelongPlayerID,&playerid);
							InsertBackPackVec.push_back(std::make_pair(needInsertItemChild,newItemChild.get()));
						}
						else
						{
							//buyItemReturn = BC_InsertBackpackError;
							//buyerData->excHandle(MAKEINT64(WCH_LockData,0));
							//thisData->excHandle(MAKEINT64(WCH_LockData,0));
							newItemChild = NULL;
							InsertBackPackVec.push_back(std::make_pair(-1,newItemChild));
							break;
						}
					}
					if(relcount == 0)
					{
						buyItemReturn = BC_InsertBackpackError;
						buyerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						if(_data) _data->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					else if(relcount<count)
					{
						relcount++;
					}
					//后扣钱
					*buyerGold -= price * relcount;
					buyerData->excHandle(MAKEINT64(WCH_LockData,0));//帐户解锁
					if(_data) _data->excHandle(MAKEINT64(WCH_LockData,0));
					ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
					stream1->createBuf(12);
					stream1->_writeInt(itemid);
					if(itemid<0)
					{
						if(saleItemItr->second[1]>0)
						{
							saleItemItr->second[1]-=relcount;
							//将该信息同步给其他正在交易的玩家
							stream1->_writeInt(saleItemItr->second[1]);
							stream1->_writeInt(saleItemItr->second[2]);//price change
						}
					}
					else
					{//
						stream1->_writeInt(0);
                        saleItemMap->erase(saleItemItr);
                        //将该信息同步给其他正在交易的玩家
					}

					thisData->getParam(WCHDATA_ExchangePlayerSet,param);
					ExchangePlayerSet *exchangePlayerSet = (ExchangePlayerSet*)param;
					if(exchangePlayerSet)
					{
						std::vector<int> EraseID;
						crItemEventPacket packet;
						ref_ptr<crSceneServerPlayerData> playerData2;
						for( ExchangePlayerSet::iterator itr = exchangePlayerSet->begin();
							 itr != exchangePlayerSet->end();
							 ++itr )
						{
							if((*itr)!=playerid)
							{
								playerData2 = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(*itr));
								if(playerData2.valid())
								{
									crItemEventPacket::buildRequestPacket(packet,*itr,m_this,WCH_RecvSaleItemMapChange,stream1.get());
									netConductor->getNetManager()->sendPacket(playerData2->getPlayerConnectServerAddress(),packet);
								}
								else
								{
									EraseID.push_back(*itr);
								}
							}
						}
						for( std::vector<int>::iterator itr = EraseID.begin();
							 itr != EraseID.end();
							 ++itr )
						{
                            exchangePlayerSet->erase(*itr);
						}
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
					//m_this->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
					//发送给客户端
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(18+relcount*9);
					stream->_writeChar(buyItemReturn);
					stream->_writeInt(playerid);//buyerplayerid
					stream->_writeInt(roleid);
					stream->_writeInt(*buyerGold);
					stream->_writeInt(itemid);//buyitemid
					stream->_writeUChar(relcount);
					for(int i = 0; i<relcount; i++)
					{
						stream->_writeChar(InsertBackPackVec[i].first);
						if(InsertBackPackVec[i].first>0)
						{
							stream->_writeInt(InsertBackPackVec[i].second->getItemChildID());
							stream->_writeInt(InsertBackPackVec[i].second->getInstanceItemID());
						}
						else if(InsertBackPackVec[i].first==0)
						{
							if(InsertBackPackVec[i].second.valid())
								stream->_writeInt(InsertBackPackVec[i].second->getInstanceItemID());
							else
								stream->_writeInt(itemid);
						}
					}

					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvBuyItem,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					//将玩家背包的变化同步给附近玩家
					scene->sendPacketToItemNeighbor(buyer,packet);

					//if(m_this->getItemtype() == crInstanceItem::Role)
					//{//卖家是玩家，则玩家钱增加，并发送消息给玩家（salemap change）

					//}
					return;
				} while (0);
				if(buyItemReturn!=BC_Success)
				{//向客户端发送失败信息
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeChar(buyItemReturn);
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvBuyItem,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool ibuy = false;
			char *ptr = m_stream->getPtr();
			char buyItemReturn = m_stream->_readChar();
			if(buyItemReturn == BC_Success)
			{
				int playerid = m_stream->_readInt();
				int roleid = m_stream->_readInt();
				int gold = m_stream->_readInt();
				crRole *buyer = NULL;
				if(playerid == crMyPlayerData::getInstance()->getPlayerID())
				{
					buyer = crMyPlayerData::getInstance()->getRole(roleid);
					ibuy = true;
				}
				else
				{
					crMyPlayerData::RoleNpcPair roleNpcPair;
					if(crMyPlayerData::getInstance()->findInRangePlayer(playerid,roleid,roleNpcPair))
					{
						buyer = roleNpcPair.first.get();
					}
				}
				if(!buyer)
					return;
				void *param;
				crData *buyerData = buyer->getDataClass();
				crPlayerGameData *playerGameData = buyer->getPlayerGameData();
				crData *_data = NULL;
				if(playerGameData) _data = playerGameData->getDataClass();
				//扣钱
				int changevalue = 0;
				int* curGold = NULL;
				if(_data)
				{
					_data->excHandle(MAKEINT64(WCH_LockData,1));
					_data->getParam(WCHDATA_Gold,param);
					curGold = (int *)param;
				}
				else
				{
					buyerData->excHandle(MAKEINT64(WCH_LockData,1));
					buyerData->getParam(WCHDATA_Gold,param);
					curGold = (int *)param;
				}
				changevalue = gold - *curGold;
				*curGold = gold;
				if(_data)
				{
					_data->excHandle(MAKEINT64(WCH_LockData,0));
				}
				else
				{
					buyerData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				//客户端显示
				crNode *bot = buyer->getRelNode();
				if(bot)
				{
					bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvGold,MAKEINT32(changevalue,-1)));
				}
				int buyitemid = m_stream->_readInt();
				int relcount = m_stream->_readUChar();
				crItemChild *buyitemchild = m_this->findChildItem(buyitemid);
				if(!buyitemchild || buyitemchild->isLoaded())
					return;
				crInstanceItem *buyitem = buyitemchild->getInstanceItem();
				if(ibuy)
				{
					//SaleItemMap改变
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_SaleItemMap,param);
					SaleItemMap* saleItemMap = (SaleItemMap* )param;
					SaleItemMap::iterator saleItemItr;
					int abstractid = buyitem->getAbstractItemID();
					saleItemItr = saleItemMap->find(abstractid);
					bool found = false;
					for( ; saleItemItr!=saleItemMap->end() && saleItemItr->first == abstractid; ++saleItemItr )
					{
						if(saleItemItr->second[0] == buyitemid)
						{
							if(saleItemItr->second[1] != 0)
							{
								if(saleItemItr->second[1]>0)
									saleItemItr->second[1]-=relcount;
								found = true;
								break;
							}
						}
					}
					if(buyitemid>0 && found)
					{
						saleItemMap->erase(saleItemItr);
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				ref_ptr<crInstanceItem> newitem;
				char needInsertItemChild;
				char insertToBackPack2;
				for(int i = 0; i<relcount; i++)
				{
					needInsertItemChild = m_stream->_readChar();
					if(needInsertItemChild>0)
					{
						int newItemChildID = m_stream->_readInt();
						int newItemid = m_stream->_readInt();
						ref_ptr<crItemChild> newItemChild;
						if(buyitemid<0)
						{
							if(needInsertItemChild==2)
							{
								newItemChild = buyer->getChildItem(newItemChildID);
							}
							if(newItemChild.valid())
								newitem = newItemChild->getInstanceItem();
							else
							{
								newitem = dynamic_cast<crInstanceItem *>(buyitem->clone());
								newitem->setInstanceItemID(newItemid);
								newItemChild = new crItemChild;
								newItemChild->setInstanceItem(newitem.get());
								newItemChild->setItemChildID(newItemChildID);
								buyer->insertChildItem(newItemChild.get());

								crData *newItemData = newitem->getDataClass();
								int playerid = buyer->getID();
								newItemData->inputParam(WCHDATA_BelongPlayerID,&playerid);
								newItemData->getParam(WCHDATA_DataType,param);
								unsigned char datatype = *((unsigned char*)param);
								if(datatype == DT_AttackThing)
								{
									newitem->clientLoadItemChildNode(buyer);
								}
							}
						}
						else
						{//>0
							newItemChild = buyitemchild;
							newitem = buyitem;
							m_this->removeChildItem(buyitemchild->getItemChildID());
							newItemChild->setItemChildID(newItemChildID);
							buyer->insertChildItem(newItemChild.get());

							crData *newItemData = newitem->getDataClass();
							int playerid = buyer->getID();
							newItemData->inputParam(WCHDATA_BelongPlayerID,&playerid);
							newItemData->getParam(WCHDATA_DataType,param);
							unsigned char datatype = *((unsigned char*)param);
							if(datatype == DT_AttackThing)
							{
								newitem->clientLoadItemChildNode(buyer);
							}
						}
						buyer->doEvent(WCH_InsertItemToBackPack,MAKEINT64(newitem.get(),&insertToBackPack2));
					}
					else if(needInsertItemChild==0)
					{
						newitem = dynamic_cast<crInstanceItem*>(buyitem->clone());
						newitem->setInstanceItemID(m_stream->_readInt());
						buyer->doEvent(WCH_InsertItemToBackPack,MAKEINT64(newitem.get(),&insertToBackPack2));
					}
				}
				m_this->doEvent(WCH_BuildSaleItemList,NULL);
				if(ibuy)
				{
				    buyer->doEvent(WCH_BuildBackPackList,NULL);
					//buyer->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
				}
			}
			if(ibuy)
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
				//crBuyItemNotifyMethod
			}
		}
	}
}
/////////////////////////////////////////
//
//crBuyItemNotifyMethod
//
/////////////////////////////////////////
crBuyItemNotifyMethod::crBuyItemNotifyMethod(){}
crBuyItemNotifyMethod::crBuyItemNotifyMethod(const crBuyItemNotifyMethod& handle):
crMethod(handle)
{
}
void crBuyItemNotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crBuyItemNotifyMethod::addParam(int i, const std::string& str)
{
}
void crBuyItemNotifyMethod::operator()(crHandle &handle)
{
	//std::string str = "网络未响应";
	//if(m_stream.valid())
	//{
	//	char buyItemReturn = m_stream->_readChar();
	//	switch(buyItemReturn)
	//	{
	//	case BC_Success:
	//		{
	//			m_stream->seek(12);
	//			int relcount = m_stream->_readUChar();
	//			char buf[32];
	//			sprintf(buf,"购买成功！买到%d件\0",relcount);
	//			str = buf;
	//		}
	//		break;
	//	case BC_SaleOut:
	//		str = "购买失败，该物品已经没有库存了！";
	//		break;
	//	case BC_MoneyNotEnough:
	//		str = "购买失败，您的钱不够！";
	//		break;
	//	case BC_BackpackIsFull:
	//		str = "购买失败，您的背包没有空间了！";
	//		break;
	//	default:
	//		str = "购买失败";
	//		break;
	//	}
	//}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crUISetKeyboardMouseModeMethod
//
/////////////////////////////////////////
crUISetKeyboardMouseModeMethod::crUISetKeyboardMouseModeMethod():
m_mode(CRCore::KM_All){}
crUISetKeyboardMouseModeMethod::crUISetKeyboardMouseModeMethod(const crUISetKeyboardMouseModeMethod& handle):
crMethod(handle),
m_mode(handle.m_mode)
{
}
void crUISetKeyboardMouseModeMethod::inputParam(int i, void *param)
{
}

void crUISetKeyboardMouseModeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mode = (unsigned short)(atoi(str.c_str()));
		break;
	}
}

void crUISetKeyboardMouseModeMethod::operator()(crHandle &handle)
{
	//crRole *role = crMyPlayerData::getInstance()->getRole();
	//if(!role)
	//	return;
	//crNode *node = role->getRelNode();
	//if(node)
	//{
	//	//右键可用性检测
	//	unsigned short flg = m_flg;
	//	if(cr2DStageManager::getInstance()->hasCanDragStageOnShow())
	//	{
	//		flg &= ~crCamera::KM_RightMouse;
	//	}
	//	node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_KEYBOARDMOUSE),MAKEINT64(WCH_SetKeyboardMouseMode,flg));
	//}
	CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview && bindview->isInited())
	{
		CRPhysics::crCamera *camera = bindview->getViewCameraNode();
		if(camera)
		{
			camera->setKeyboardMouseMode(m_mode);
		}
	}
}
/////////////////////////////////////////
//
//crGetSaleItemMapMethod
//
/////////////////////////////////////////
crGetSaleItemMapMethod::crGetSaleItemMapMethod(){}
crGetSaleItemMapMethod::crGetSaleItemMapMethod(const crGetSaleItemMapMethod& handle):
crMethod(handle)
{
}
void crGetSaleItemMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crGetSaleItemMapMethod::addParam(int i, const std::string& str)
{
}

void crGetSaleItemMapMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(crMyPlayerData::getInstance()->getPlayerID());
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSaleItemMap,m_this,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crUIGetSaleItemMapMethod
//
/////////////////////////////////////////
crUIGetSaleItemMapMethod::crUIGetSaleItemMapMethod():
m_emporium(false){}
crUIGetSaleItemMapMethod::crUIGetSaleItemMapMethod(const crUIGetSaleItemMapMethod& handle):
crMethod(handle),
m_emporium(handle.m_emporium)
{
}
void crUIGetSaleItemMapMethod::inputParam(int i, void *param)
{
}

void crUIGetSaleItemMapMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_emporium = (bool)(atoi(str.c_str()));
		break;
	}
}

void crUIGetSaleItemMapMethod::operator()(crHandle &handle)
{
	ref_ptr<crInstanceItem> targetItem;
	if(m_emporium)
	{
		targetItem = crMyPlayerData::getInstance()->getScene()->getEmporium();
	}
	else
	{
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		ref_ptr<crMatrixTransform> targetNode;
		me->clientGetTarget(targetItem,targetNode);
	}
	if(targetItem.valid())
	{
		targetItem->doEvent(WCH_GetSaleItemMap);
	}
}
/////////////////////////////////////////
//
//crRecvSaleItemMapMethod
//
/////////////////////////////////////////
crRecvSaleItemMapMethod::crRecvSaleItemMapMethod():
m_netType(GameClient_Game){}
crRecvSaleItemMapMethod::crRecvSaleItemMapMethod(const crRecvSaleItemMapMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvSaleItemMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvSaleItemMapMethod::addParam(int i, const std::string& str)
{
}
void crRecvSaleItemMapMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(512);
				void *param;
                crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_SaleItemMap,param);
                SaleItemMap *saleItemMap = (SaleItemMap*)param;
				if(saleItemMap)
				{
					stream->_writeUChar(saleItemMap->size());
					for( SaleItemMap::iterator itr = saleItemMap->begin();
						itr != saleItemMap->end();
						++itr )
					{
						stream->_writeInt(itr->first);//abstractid
						stream->_writeVec3i(itr->second);
					}
				}
				else
				{
                    stream->_writeUChar(0);
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));

				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvSaleItemMap,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			std::set<int> NeedDownloadItem;
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap *saleItemMap = (SaleItemMap*)param;
			if(saleItemMap)
			{
				unsigned char size = m_stream->_readUChar();
				saleItemMap->clear();
				int int1;
				crVector3i vec3;
				
				for(unsigned char i = 0; i<size; i++)
				{
					int1 = m_stream->_readInt();
					vec3 = m_stream->_readVec3i();
					if(!m_this->findChildItem(vec3[0]))
					{//need download itemchild
                        NeedDownloadItem.insert(vec3[0]);
					}
					saleItemMap->insert(std::make_pair(int1,vec3));
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			if(!NeedDownloadItem.empty())
			{//
				int playerid = crMyPlayerData::getInstance()->getPlayerID();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(256);
				stream->_writeInt(playerid);
				stream->_writeUChar(NeedDownloadItem.size());
				for( std::set<int>::iterator itr = NeedDownloadItem.begin();
					 itr != NeedDownloadItem.end();
					 ++itr )
				{
                    stream->_writeInt(*itr);
				}
				crPlayerServerEventPacket packet;
				crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvDownLoadItemChilds,m_this,stream.get());
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			m_this->doEvent(WCH_BuildSaleItemList,NULL);
		}
	}
}
/////////////////////////////////////////
//
//crRecvDownLoadItemChildsMethod
//
/////////////////////////////////////////
crRecvDownLoadItemChildsMethod::crRecvDownLoadItemChildsMethod():
m_netType(GameClient_Game){}
crRecvDownLoadItemChildsMethod::crRecvDownLoadItemChildsMethod(const crRecvDownLoadItemChildsMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvDownLoadItemChildsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvDownLoadItemChildsMethod::addParam(int i, const std::string& str)
{
}
void crRecvDownLoadItemChildsMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
            ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned char size = m_stream->_readUChar();
				int itemid;
				crItemChild *itemchild;
				std::set< ref_ptr<crItemChild > > ItemChildSet;
				for(unsigned char i = 0; i<size; i++)
				{
					itemid = m_stream->_readInt();
					itemchild = m_this->findChildItem(itemid);
					if(itemchild)
					{
						ItemChildSet.insert(itemchild);
					}
				}
				if(!ItemChildSet.empty())
				{//
					int count = 0;
					std::vector< ref_ptr<crStreamBuf> > BufVec;

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(MTUBUFFERSIZE);//MAXBUFFERSIZE-12);
					stream->_writeUChar(m_this->getItemtype());
					stream->_writeInt(m_this->getID());
					if(m_this->getItemtype() == crInstanceItem::Role)
						stream->_writeInt(m_this->getRoleID());
					stream->_writeInt64(WCH_RecvDownLoadItemChilds);
					stream->_writeUChar(ItemChildSet.size());
					ref_ptr<crItemChild > setItr;
					for( std::set< ref_ptr<crItemChild > >::iterator itr = ItemChildSet.begin();
						itr != ItemChildSet.end();
						++itr )
					{
						setItr = *itr;
						itemchild = setItr.get();
						writeStreamVec(stream,4,BufVec,count);
						stream->_writeInt(itemchild->getItemChildID());//4
						writeItem(itemchild->getInstanceItem(),stream,BufVec,count,NetStream);
					}
					if(stream->getBufSize()>0)
					{
						count += stream->getBufSize();
						BufVec.push_back(stream.get());
					}
					//CRCore::notify(CRCore::ALWAYS)<<"crRecvDownLoadItemChildsMethod count = "<<count<<" playerid = "<<playerid<<std::endl;
					if(count>0)
					{
						int streamid = crDataStreamTransfer::getInstance()->gainStreamID();
						crCreateDataStreamPacket packet;
						crCreateDataStreamPacket::buildRequestPacket(packet,playerid,streamid,crItemEventPacket::ID,count);
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						crDataStreamPacket streamPacket;
						for( std::vector< ref_ptr<crStreamBuf> >::iterator itr = BufVec.begin();
							itr != BufVec.end();
							++itr )
						{
							crDataStreamPacket::buildRequestPacket(streamPacket,playerid,streamid,crItemEventPacket::ID,itr->get());
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),streamPacket);
						}
						crDataStreamTransfer::getInstance()->recycleStreamID(streamid,crGlobalHandle::gData()->gRecycleStreamIDTime_out());
					}
     //               if(BufVec.size()>1)
					//{
					//	CRCore::notify(CRCore::ALWAYS)<<"crRecvDownLoadItemChildsMethod溢出，需要采用DataStream方式传输 count = "<<count<<std::endl;
					//}
					//else
					//{
					//	stream = BufVec[0].get();
					//	crItemEventPacket packet;
					//	crItemEventPacket::buildRequestPacket(packet,playerid,m_this->getItemtype(),m_this->getID(),WCH_RecvDownLoadItemChilds,stream.get());
					//	netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					//}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
            unsigned char size = m_stream->_readUChar();
			ref_ptr<crItemChild> itemchild;
			ref_ptr<crInstanceItem> item;
			for( unsigned char i = 0; i<size; ++i)
			{
                itemchild = new crItemChild;
				itemchild->setItemChildID(m_stream->_readInt());
				readItem(item,m_stream.get(),false);
				itemchild->setInstanceItem(item.get());
				m_this->insertChildItem(itemchild.get());
				crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(itemchild.get(),m_this));
				//crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(NULL,NULL));//清理
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvItemEventStreamMethod
//
/////////////////////////////////////////
crRecvItemEventStreamMethod::crRecvItemEventStreamMethod(){}
crRecvItemEventStreamMethod::crRecvItemEventStreamMethod(const crRecvItemEventStreamMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvItemEventStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvItemEventStreamMethod::addParam(int i, const std::string& str)
{
}

void crRecvItemEventStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crStreamBuf *stream = m_recvDataStream->getStream();
		unsigned char itemtype = stream->_readUChar();
		int id = stream->_readInt();
		int roleid = itemtype == crInstanceItem::Role?stream->_readInt():0;
		_crInt64 msg = stream->_readInt64();
		if(itemtype == crInstanceItem::Role)
		{
			if(id == crMyPlayerData::getInstance()->getPlayerID())
			{
				crRole *role = crMyPlayerData::getInstance()->getRole(roleid);
				if(role) role->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
			else
			{
				crMyPlayerData::RoleNpcPair roleNpcPair;
				if(crMyPlayerData::getInstance()->findInRangePlayer(id,roleid,roleNpcPair))
				{
					roleNpcPair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
				}
				//else if(crMyPlayerData::getInstance()->findOutRangePlayer(id,roleNpcPair))
				//{
				//	roleNpcPair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
				//}
			}
		}
		else if(itemtype == crInstanceItem::Npc)
		{
			crMyPlayerData::ItemNpcPair itemNpcPair;
			if(crMyPlayerData::getInstance()->findInRangeNpc(id,itemNpcPair))
			{
				itemNpcPair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
			else if(crMyPlayerData::getInstance()->findOutRangeNpc(id,itemNpcPair))
			{
				itemNpcPair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
		}
		else
		{
			crMyPlayerData::ItemNodePair itemNodePair;
			if(crMyPlayerData::getInstance()->findInRangeItem(id,itemNodePair))
			{
				itemNodePair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
			else if(crMyPlayerData::getInstance()->findOutRangeItem(id,itemNodePair))
			{
				itemNodePair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvPlayerEventStreamMethod
//
/////////////////////////////////////////
crRecvPlayerEventStreamMethod::crRecvPlayerEventStreamMethod(){}
crRecvPlayerEventStreamMethod::crRecvPlayerEventStreamMethod(const crRecvPlayerEventStreamMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvPlayerEventStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvPlayerEventStreamMethod::addParam(int i, const std::string& str)
{
}

void crRecvPlayerEventStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crStreamBuf *stream = m_recvDataStream->getStream();
		int playerid = stream->_readInt();
		int roleid = stream->_readInt(); 
		_crInt64 msg = stream->_readInt64();
		if(playerid == crMyPlayerData::getInstance()->getPlayerID())
		{
			crRole* role = crMyPlayerData::getInstance()->getRole(roleid);
			if(role) role->doEvent(msg,MAKEINT64(stream,GameClient_Game));
		}
		else
		{
			crMyPlayerData::RoleNpcPair roleNpcPair;
			if(crMyPlayerData::getInstance()->findInRangePlayer(playerid,roleid,roleNpcPair))
			{
				roleNpcPair.first->doEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
			//else if(crMyPlayerData::getInstance()->findOutRangePlayer(playerid,roleNpcPair))
			//{
			//	roleNpcPair.first->doEvent(msg,MAKEINT64(m_streamBuf.get(),netType));
			//}
		}
	}
}
/////////////////////////////////////////
//
//crRecvPlayerMetierEventStreamMethod
//
/////////////////////////////////////////
crRecvPlayerMetierEventStreamMethod::crRecvPlayerMetierEventStreamMethod(){}
crRecvPlayerMetierEventStreamMethod::crRecvPlayerMetierEventStreamMethod(const crRecvPlayerMetierEventStreamMethod& handle):
crMethod(handle),
m_recvDataStream(handle.m_recvDataStream)
{
}
void crRecvPlayerMetierEventStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crRecvPlayerMetierEventStreamMethod::addParam(int i, const std::string& str)
{
}

void crRecvPlayerMetierEventStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crStreamBuf *stream = m_recvDataStream->getStream();
		int playerid = stream->_readInt();
		int roleid = stream->_readInt(); 
		_crInt64 msg = stream->_readInt64();
		if(playerid == crMyPlayerData::getInstance()->getPlayerID())
		{
			crRole *role = crMyPlayerData::getInstance()->getRole(roleid);
			if(role) role->doMetierEvent(msg,MAKEINT64(stream,GameClient_Game));
		}
		else
		{
			crMyPlayerData::RoleNpcPair roleNpcPair;
			if(crMyPlayerData::getInstance()->findInRangePlayer(playerid,roleid,roleNpcPair))
			{
				roleNpcPair.first->doMetierEvent(msg,MAKEINT64(stream,GameClient_Game));
			}
			//else if(crMyPlayerData::getInstance()->findOutRangePlayer(playerid,roleNpcPair))
			//{
			//	roleNpcPair.first->doMetierEvent(msg,MAKEINT64(m_streamBuf.get(),netType));
			//}
		}
	}
}
/////////////////////////////////////////
//
//crBeginExchangeMethod
//
/////////////////////////////////////////
crBeginExchangeMethod::crBeginExchangeMethod()
{
}
crBeginExchangeMethod::crBeginExchangeMethod(const crBeginExchangeMethod& handle):
crMethod(handle)
{
}
void crBeginExchangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crBeginExchangeMethod::addParam(int i, const std::string& str)
{
}
void crBeginExchangeMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	if(m_this && me)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(me->getPlayerID());
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvBeginExchange,m_this,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//CRCore::notify(CRCore::ALWAYS)<<"crBeginExchangeMethod "<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crUIBeginExchangeMethod
//
/////////////////////////////////////////
crUIBeginExchangeMethod::crUIBeginExchangeMethod():
m_emporium(false)
{
}
crUIBeginExchangeMethod::crUIBeginExchangeMethod(const crUIBeginExchangeMethod& handle):
crMethod(handle),
m_emporium(handle.m_emporium)
{
}
void crUIBeginExchangeMethod::inputParam(int i, void *param)
{
}
void crUIBeginExchangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_emporium = (bool)(atoi(str.c_str()));
		break;
	}
}
void crUIBeginExchangeMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	ref_ptr<crInstanceItem> targetItem;
	if(m_emporium)
	{
		targetItem = crMyPlayerData::getInstance()->getScene()->getEmporium();
	}
	else
	{
		ref_ptr<crMatrixTransform> targetNode;
		me->clientGetTarget(targetItem,targetNode);
	}
	if(targetItem.valid())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(me->getPlayerID());
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvBeginExchange,targetItem.get(),stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//CRCore::notify(CRCore::ALWAYS)<<"crUIBeginExchangeMethod "<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crEndExchangeMethod
//
/////////////////////////////////////////
crEndExchangeMethod::crEndExchangeMethod()
{
}
crEndExchangeMethod::crEndExchangeMethod(const crEndExchangeMethod& handle):
crMethod(handle)
{
}
void crEndExchangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crEndExchangeMethod::addParam(int i, const std::string& str)
{
}
void crEndExchangeMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	if(m_this && me)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(me->getPlayerID());
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEndExchange,m_this,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//CRCore::notify(CRCore::ALWAYS)<<"crEndExchangeMethod "<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crUIEndExchangeMethod
//
/////////////////////////////////////////
crUIEndExchangeMethod::crUIEndExchangeMethod():
m_emporium(false)
{
}
crUIEndExchangeMethod::crUIEndExchangeMethod(const crUIEndExchangeMethod& handle):
crMethod(handle),
m_emporium(handle.m_emporium)
{
}
void crUIEndExchangeMethod::inputParam(int i, void *param)
{
}
void crUIEndExchangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_emporium = (bool)(atoi(str.c_str()));
		break;
	}
}
void crUIEndExchangeMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	ref_ptr<crInstanceItem> targetItem;
	if(m_emporium)
	{
		targetItem = crMyPlayerData::getInstance()->getScene()->getEmporium();
	}
	else
	{
		ref_ptr<crMatrixTransform> targetNode;
		me->clientGetTarget(targetItem,targetNode);
	}
	if(targetItem.valid())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(me->getPlayerID());
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEndExchange,targetItem.get(),stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//CRCore::notify(CRCore::ALWAYS)<<"crUIEndExchangeMethod "<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crRecvBeginExchangeMethod
//
/////////////////////////////////////////
crRecvBeginExchangeMethod::crRecvBeginExchangeMethod(){}
crRecvBeginExchangeMethod::crRecvBeginExchangeMethod(const crRecvBeginExchangeMethod& handle):
crMethod(handle)
{
}
void crRecvBeginExchangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvBeginExchangeMethod::addParam(int i, const std::string& str)
{
}
void crRecvBeginExchangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		int playerid = m_stream->_readInt();
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
            crData *thisData = m_this->getDataClass();
			thisData->inputParam(WCHDATA_ExchangePlayerSet,&playerid);
		}
	}
}
/////////////////////////////////////////
//
//crRecvEndExchangeMethod
//
/////////////////////////////////////////
crRecvEndExchangeMethod::crRecvEndExchangeMethod(){}
crRecvEndExchangeMethod::crRecvEndExchangeMethod(const crRecvEndExchangeMethod& handle):
crMethod(handle)
{
}
void crRecvEndExchangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvEndExchangeMethod::addParam(int i, const std::string& str)
{
}
void crRecvEndExchangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		int playerid = m_stream->_readInt();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExchangePlayerSet,param);
		ExchangePlayerSet* exchangePlayerSet = (ExchangePlayerSet* )param;
		if(exchangePlayerSet)
		{
			exchangePlayerSet->erase(playerid);
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crRecvEndExchangeMethod
//
/////////////////////////////////////////
crRecvSaleItemMapChangeMethod::crRecvSaleItemMapChangeMethod(){}
crRecvSaleItemMapChangeMethod::crRecvSaleItemMapChangeMethod(const crRecvSaleItemMapChangeMethod& handle):
crMethod(handle)
{
}
void crRecvSaleItemMapChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvSaleItemMapChangeMethod::addParam(int i, const std::string& str)
{
}
void crRecvSaleItemMapChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
        int itemid = m_stream->_readInt();
		int count = m_stream->_readInt();
		crItemChild *itemchild = m_this->findChildItem(itemid);
		if(!itemchild || !itemchild->isLoaded())
			return;
		crInstanceItem *item = itemchild->getInstanceItem();
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_SaleItemMap,param);
		SaleItemMap* saleItemMap = (SaleItemMap* )param;
		if(saleItemMap)
		{
			SaleItemMap::iterator saleItemItr;
			int abstractid = item->getAbstractItemID();
			saleItemItr = saleItemMap->find(abstractid);
			bool found = false;
			for( ; saleItemItr!=saleItemMap->end() && saleItemItr->first == abstractid; ++saleItemItr )
			{
				if(saleItemItr->second[0] == itemid)
				{
					found = true;
					break;
				}
			}
			if(found)
			{
				if(itemid>0 && count == 0)
				    saleItemMap->erase(saleItemItr);
				else
				{
					saleItemItr->second[1] = count;
					saleItemItr->second[2] = m_stream->_readInt();
				}
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crUICloseTimerMethod
//
/////////////////////////////////////////
crUICloseTimerMethod::crUICloseTimerMethod():
m_interval(5.0f),
m_timer(0.0f),
m_dt(0.0f)
{
}
crUICloseTimerMethod::crUICloseTimerMethod(const crUICloseTimerMethod& handle):
crMethod(handle),
m_interval(handle.m_interval),
m_timer(0.0f),
m_dt(0.0f)
{
}
void crUICloseTimerMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 0:
		m_stage = (CRGUI::crImageStage*)param;
		break;
	case -3:
		m_dt = *(float*)param;
		break;
	}
}
void crUICloseTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crUICloseTimerMethod::operator()(crHandle &handle)
{
	if(m_stage.valid() && m_stage->getShow())
	{
		m_timer += m_dt;
		if(m_timer>m_interval)
		{
			m_timer = 0;
			cr2DStageManager::getInstance()->close(m_stage.get());
		}
	}
}
/////////////////////////////////////////
//
//crUINotifyMethod
//
/////////////////////////////////////////
crUINotifyMethod::crUINotifyMethod():
m_notice(NULL)
{
}
crUINotifyMethod::crUINotifyMethod(const crUINotifyMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_textElement(handle.m_textElement),
m_notice(NULL)
{
}
void crUINotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_notice = (std::string *)(LOINT64(param64));
		}
		break;
	}
}
void crUINotifyMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_textElement = str;
		break;
	}
}
void crUINotifyMethod::operator()(crHandle &handle)
{
	if(m_notice)
	{
		crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
		if(stage)
		{
			crStaticTextBoxElement *textElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_textElement));
			if(textElement)
			{
				textElement->setStringArrayByString(*m_notice);
			}
			cr2DStageManager::getInstance()->showStage(stage,1);
		}
	}
}
/////////////////////////////////////////
//
//crRefashSaleMapMethod
//
/////////////////////////////////////////
crRefashSaleMapMethod::crRefashSaleMapMethod():
m_interval(60.0f),
m_dt(0.0f),
m_timer(0.0f){}
crRefashSaleMapMethod::crRefashSaleMapMethod(const crRefashSaleMapMethod& handle):
crMethod(handle),
m_interval(handle.m_interval),
m_saleItemCountVec(handle.m_saleItemCountVec),
m_dt(0.0f),
m_timer(0.0f)
{
}
void crRefashSaleMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crRefashSaleMapMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	default:
		{
			crVector2i vec2;
			crArgumentParser::appAtoVec(str,vec2);
			m_saleItemCountVec.push_back(vec2);
		}
		break;
	}
}

void crRefashSaleMapMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_this && m_dt>0.0f)
	{
		m_timer += m_dt;
		if(m_timer>m_interval)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap* saleItemMap = (SaleItemMap*)param;
			if(saleItemMap)
			{
				bool needSend = false;
				//同步给正在交易的玩家
				thisData->getParam(WCHDATA_ExchangePlayerSet,param);
				ExchangePlayerSet *exchangePlayerSet = (ExchangePlayerSet *)param;
				if(exchangePlayerSet && !exchangePlayerSet->empty())
				{
					needSend = true;
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(128);
				unsigned char size = m_saleItemCountVec.size();
				stream->_writeUChar(size);
				SaleItemMap::iterator sitr;
				unsigned char relsize = 0;
				for( SaleItemCountVec::iterator itr = m_saleItemCountVec.begin();
					 itr != m_saleItemCountVec.end();
					 ++itr )
				{
					sitr = saleItemMap->find((*itr)[0]);
					if(sitr != saleItemMap->end() && sitr->second[1]!=(*itr)[1])
					{
                        sitr->second[1] = (*itr)[1];
						stream->_writeVec2i(*itr);
						relsize++;
					}
				}
				if(relsize>0 && relsize!=size)
				{
					int bufsize = stream->getBufSize();
					stream->seekBegin();
					stream->_writeUChar(relsize);
					stream->setBufSize(bufsize);
				}
                if(relsize>0)
				{
					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					std::vector<int> EraseID;
					crItemEventPacket packet;
					ref_ptr<crSceneServerPlayerData> playerData;
					for( ExchangePlayerSet::iterator itr = exchangePlayerSet->begin();
						itr != exchangePlayerSet->end();
						++itr )
					{
						playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(*itr));
						if(playerData.valid())
						{
							crItemEventPacket::buildRequestPacket(packet,*itr,m_this,WCH_RecvRefashSaleMap,stream.get());
							sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
						else
						{
							EraseID.push_back(*itr);
						}
					}
					for( std::vector<int>::iterator itr = EraseID.begin();
						itr != EraseID.end();
						++itr )
					{
						exchangePlayerSet->erase(*itr);
					}
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));

			m_timer = 0.0f;
		}
	}
}
/////////////////////////////////////////
//
//crRecvRefashSaleMapMethod
//
/////////////////////////////////////////
crRecvRefashSaleMapMethod::crRecvRefashSaleMapMethod(){}
crRecvRefashSaleMapMethod::crRecvRefashSaleMapMethod(const crRecvRefashSaleMapMethod& handle):
crMethod(handle)
{
}
void crRecvRefashSaleMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvRefashSaleMapMethod::addParam(int i, const std::string& str)
{
}
void crRecvRefashSaleMapMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_SaleItemMap,param);
		SaleItemMap* saleItemMap = (SaleItemMap*)param;
		if(saleItemMap)
		{
			crVector2i vec2;
			SaleItemMap::iterator sitr;
			unsigned char size = m_stream->_readUChar();
			unsigned char i;
			for( i = 0; i<size; i++)
			{
				vec2 = m_stream->_readVec2i();
				sitr = saleItemMap->find(vec2[0]);
				if(sitr != saleItemMap->end())
				{
					sitr->second[1] = vec2[1];
				}
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		m_this->doEvent(WCH_BuildSaleItemList,NULL);
	}
}
/////////////////////////////////////////
//
//crGetPriceFormula1Method
//
/////////////////////////////////////////
crGetPriceFormula1Method::crGetPriceFormula1Method():
m_output(NULL){}
crGetPriceFormula1Method::crGetPriceFormula1Method(const crGetPriceFormula1Method& handle):
crMethod(handle),
m_factor(handle.m_factor),
m_output(NULL)
{
}
void crGetPriceFormula1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (int *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crGetPriceFormula1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_factor);
		break;
	}
}
void crGetPriceFormula1Method::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ItemPrice,param);
		int base = *((int*)param);
		data->getParam(WCHDATA_SkillLevel,param);
		unsigned char lv = *((unsigned char*)param);
	
		float fbase = (float)base;
		float flv = (float)lv;

		*m_output = fbase + (fbase+m_factor[0]) * m_factor[1] * (flv+1.0f);
	}
}
/////////////////////////////////////////
//
//crBuildLearnSkillListMethod
//
/////////////////////////////////////////
crBuildLearnSkillListMethod::crBuildLearnSkillListMethod(){}
crBuildLearnSkillListMethod::crBuildLearnSkillListMethod(const crBuildLearnSkillListMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_learnSkillList(handle.m_learnSkillList)
{
}
void crBuildLearnSkillListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildLearnSkillListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_learnSkillList = str;
		break;
	}
}

void crBuildLearnSkillListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		crListControlElement *learnSkillList = dynamic_cast<crListControlElement *>(imageStage->getElement(m_learnSkillList));
		if(learnSkillList)
		{
			learnSkillList->clear();
			learnSkillList->lockList();
			crListControlElement::ListNodeVec& listNodeVec = learnSkillList->getListNodeVec();
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap* saleItemMap = (SaleItemMap* )param;

			crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
			crData *roleData = role->getDataClass();
			roleData->excHandle(MAKEINT64(WCH_LockData,1));
			roleData->getParam(WCHDATA_SkillMap,param);
			SkillMap* skillMap = (SkillMap* )param;
			SkillMap::iterator skillMapItr;
			unsigned char skillLevel;
			crData *skillData;

			crData *metierData = role->getMetierDataClass();
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			metierData->getParam(WCHDATA_MetierSkillASet,param);
			MetierSkillASet* metierSkillASet = (MetierSkillASet* )param;

			crItemChild *itemchild,*itemchild2;
			crInstanceItem *item,*skill;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			std::string title,title2;
			int price;
			for( SaleItemMap::iterator itr = saleItemMap->begin();
				itr != saleItemMap->end();
				++itr )
			{
				if(itr->second[0]==0)
					continue;
				if(metierSkillASet->find(itr->first) == metierSkillASet->end())
					continue;
				itemchild = m_this->findChildItem(itr->second[0]);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;

					title = item->getIName();
					title2.clear();
					skillLevel = 0;
					price = 0;
					skillMapItr = skillMap->find(itr->first);
					if(skillMapItr != skillMap->end())
					{
                        itemchild2 = role->findChildItem(skillMapItr->second);
						if(itemchild2 && itemchild2->isLoaded())
						{
							skill = itemchild2->getInstanceItem();
                            skillData = skill->getDataClass();
							skillData->getParam(WCHDATA_SkillLevel,param);
							skillLevel = *(unsigned char *)param;
							if(skillLevel >= crGlobalHandle::gData()->gMaxSkillLevelLearn())//已经到达最高可学等级
								continue;
							skill->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
						}
					}
					else
					{
						item->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
					}
					skillLevel++;
					title2 = crArgumentParser::appItoa(skillLevel);
					itr->second[2] = price;

					listNode = new crListNode;
					listNode->setTitle(title);
					listNode->setTitle2(title2);
					listNode->setData(&(itr->second));
					listNode->addBitMapFile(iconfile);
					listNodeVec.push_back(listNode.get());
				}
			}
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
			roleData->excHandle(MAKEINT64(WCH_LockData,0));
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			learnSkillList->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildLearnSkillList2Method
//
/////////////////////////////////////////
crBuildLearnSkillList2Method::crBuildLearnSkillList2Method(){}
crBuildLearnSkillList2Method::crBuildLearnSkillList2Method(const crBuildLearnSkillList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_learnSkillList(handle.m_learnSkillList)
{
}
void crBuildLearnSkillList2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildLearnSkillList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_learnSkillList = str;
		break;
	}
}

void crBuildLearnSkillList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid() && m_this)
	{
		ref_ptr<crListControlWidgetNode>learnSkillList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_learnSkillList));
		if(learnSkillList.valid())
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_SaleItemMap,param);
			SaleItemMap* saleItemMap = (SaleItemMap* )param;

			crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
			crData *metierData = role->getMetierDataClass();
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			metierData->getParam(WCHDATA_MetierSkillASet,param);
			MetierSkillASet* metierSkillASet = (MetierSkillASet* )param;

			std::vector<SaleItemMap::iterator> validVec;
			for( SaleItemMap::iterator itr = saleItemMap->begin();
				itr != saleItemMap->end();
				++itr )
			{
				if(itr->second[0]==0)
					continue;
				if(metierSkillASet->find(itr->first) == metierSkillASet->end())
					continue;
				validVec.push_back(itr);
			}
			learnSkillList->setListNodeCount(validVec.size());
			if(!validVec.empty())
			{
				crData *roleData = role->getDataClass();
				roleData->excHandle(MAKEINT64(WCH_LockData,1));
				roleData->getParam(WCHDATA_SkillMap,param);
				SkillMap* skillMap = (SkillMap* )param;
				SkillMap::iterator skillMapItr;
				unsigned char skillLevel;
				crData *skillData;

				crItemChild *itemchild,*itemchild2;
				crInstanceItem *item,*skill;
				crData *itemData;
				std::string iconfile;
				ref_ptr<crListNode> listNode;
				std::string title,title2;
				int price;
				crListControlWidgetNode::ListNodeVec& listNodeVec = learnSkillList->getListNodeVec();
				int i = 0;
				for( std::vector<SaleItemMap::iterator>::iterator itr = validVec.begin();
					 itr != validVec.end();
					 ++itr )
				{
					itemchild = m_this->findChildItem((*itr)->second[0]);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;

						title = item->getIName();
						title2.clear();
						skillLevel = 0;
						price = 0;
						skillMapItr = skillMap->find((*itr)->first);
						if(skillMapItr != skillMap->end())
						{
							itemchild2 = role->findChildItem(skillMapItr->second);
							if(itemchild2 && itemchild2->isLoaded())
							{
								skill = itemchild2->getInstanceItem();
								skillData = skill->getDataClass();
								skillData->getParam(WCHDATA_SkillLevel,param);
								skillLevel = *(unsigned char *)param;
								if(skillLevel >= crGlobalHandle::gData()->gMaxSkillLevelLearn())//已经到达最高可学等级
									continue;
								skill->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
							}
						}
						else
						{
							item->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
						}
						skillLevel++;
						title2 = crArgumentParser::appItoa(skillLevel);
						(*itr)->second[2] = price;

						listNodeVec[i]->setTitle(title);
						listNodeVec[i]->setTitle2(title2);
						listNodeVec[i]->setData(&((*itr)->second));
						listNodeVec[i]->setImageName(iconfile);
						i++;
					}
				}
				learnSkillList->setListNodeCount(i);
				roleData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crUILearnSkillMethod
//
/////////////////////////////////////////
crUILearnSkillMethod::crUILearnSkillMethod()
{
}
crUILearnSkillMethod::crUILearnSkillMethod(const crUILearnSkillMethod& handle):
crMethod(handle),
m_listControl(handle.m_listControl)
{
}
void crUILearnSkillMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crListControlElement*)param;
}
void crUILearnSkillMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_listControl = str;
		break;
	}
}
void crUILearnSkillMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_element.valid()) break;

		crImageStage *stage = m_element->getParentStage();
		crListControlElement *listControl = dynamic_cast<crListControlElement *>(stage->getElement(m_listControl));
		if(!listControl) break;
		crListNode *listNode = listControl->getSelectNode();
		if(!listNode) break;
		crVector3i *saleParam = (crVector3i *)(listNode->getData());
		if(!saleParam) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		me->clientGetTarget(targetItem,targetNode);
		//me->doEvent(MAKEINT64(WCH_GetTarget,WCH_Client),MAKEINT64(&targetItem,&targetNode));
		if(!targetItem.valid()) break;

		crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
		if(!itemchild || !itemchild->isLoaded()) break;
		void *param;
		crData *myData = me->getDataClass();
		//检查技能点
		myData->getParam(WCHDATA_SkillPoint,param);
		unsigned short skillpoint = *(unsigned short *)param;
		if(skillpoint==0)
		{
			//std::string str = "您没有技能点了！";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			break;
		}
        myData->getParam(WCHDATA_MaxSkill,param);
		unsigned char maxSkill = *(unsigned char *)param;
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		myData->getParam(WCHDATA_SkillMap,param);
		SkillMap *skillMap = (SkillMap *)param;
		if(skillMap->find(itemchild->getInstanceItem()->getAbstractItemID())==skillMap->end())
		{//学习新技能
			if((int)maxSkill<= skillMap->size())
			{
				//std::string str = "您的已经学不了更多的技能了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		//检查钱
		myData->getParam(WCHDATA_Gold,param);
		int gold = *(int *)param;
		if(gold<(*saleParam)[2])
		{
			//std::string str = "您没有足够的金币！";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			break;
		}
        //net send
		//unsigned char itemType = targetItem->getItemtype();
		//int id = targetItem->getID();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(12);
		stream->_writeInt(me->getPlayerID());
		stream->_writeInt(me->getRoleID());
		stream->_writeInt((*saleParam)[0]);
		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvLearnSkill,targetItem.get(),stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
		//CRCore::notify(CRCore::ALWAYS)<<"crUILearnSkillMethod "<<std::endl;
	} while (0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUILearnSkill2Method
//
/////////////////////////////////////////
crUILearnSkill2Method::crUILearnSkill2Method()
{
}
crUILearnSkill2Method::crUILearnSkill2Method(const crUILearnSkill2Method& handle):
crMethod(handle)
{
}
void crUILearnSkill2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_selectIndex = LOINT64(param64);
	//	}
	//	else
	//	{
	//		m_selectIndex = -1;
	//	}
	//	break;
	}
}
void crUILearnSkill2Method::addParam(int i, const std::string& str)
{
}
void crUILearnSkill2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this)
			break;
		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode || !listNode->getVisiable())
		{
			break;
		}
		crVector3i *saleParam = (crVector3i *)(listNode->getData());
		if(!saleParam) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		me->clientGetTarget(targetItem,targetNode);
		if(!targetItem.valid()) break;

		crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
		if(!itemchild || !itemchild->isLoaded()) break;
		void *param;
		crData *myData = me->getDataClass();
		//检查技能点
		myData->getParam(WCHDATA_SkillPoint,param);
		unsigned short skillpoint = *(unsigned short *)param;
		if(skillpoint==0)
		{
			//std::string str = "您没有技能点了！";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			break;
		}
		myData->getParam(WCHDATA_MaxSkill,param);
		unsigned char maxSkill = *(unsigned char *)param;
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		myData->getParam(WCHDATA_SkillMap,param);
		SkillMap *skillMap = (SkillMap *)param;
		if(skillMap->find(itemchild->getInstanceItem()->getAbstractItemID())==skillMap->end())
		{//学习新技能
			if((int)maxSkill<= skillMap->size())
			{
				//std::string str = "您的已经学不了更多的技能了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		//检查钱
		myData->getParam(WCHDATA_Gold,param);
		int gold = *(int *)param;
		if(gold<(*saleParam)[2])
		{
			//std::string str = "您没有足够的金币！";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			break;
		}
		//net send
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(12);
		stream->_writeInt(me->getPlayerID());
		stream->_writeInt(me->getRoleID());
		stream->_writeInt((*saleParam)[0]);
		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvLearnSkill,targetItem.get(),stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
		//CRCore::notify(CRCore::ALWAYS)<<"crUILearnSkillMethod "<<std::endl;
	} while (0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvLearnSkillMethod
//
/////////////////////////////////////////
crRecvLearnSkillMethod::crRecvLearnSkillMethod():
m_netType(GameClient_Game){}
crRecvLearnSkillMethod::crRecvLearnSkillMethod(const crRecvLearnSkillMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvLearnSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvLearnSkillMethod::addParam(int i, const std::string& str)
{
}
void crRecvLearnSkillMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			int itemid = m_stream->_readInt();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				char learnSkillReturn = LC_Success;
				do 
				{
					crItemChild *learnSkillChild = m_this->findChildItem(itemid);
					if(!learnSkillChild || !learnSkillChild->isLoaded()) 
					{
						learnSkillReturn = LC_Error;
						break;
					}
					crInstanceItem *learnSkill = learnSkillChild->getInstanceItem();
					crData *learnSkillData = learnSkill->getDataClass();
					//检查钱是否够
					void *param;
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_SaleItemMap,param);
					SaleItemMap* saleItemMap = (SaleItemMap* )param;
					if(!saleItemMap)
					{
						learnSkillReturn = LC_Error;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					bool found = false;
					SaleItemMap::iterator learnSkillItr;
					int abstractid = learnSkill->getAbstractItemID();
					learnSkillItr = saleItemMap->find(abstractid);
					for( ; learnSkillItr!=saleItemMap->end() && learnSkillItr->first == abstractid; ++learnSkillItr )
					{
						if(learnSkillItr->second[0] == itemid)
						{
							found = true;
							break;
						}
					}
					if(!found)
					{
						learnSkillReturn = LC_Error;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					//
					crRole *learner = playerData->getRole(roleid);
					crData *learnerMetierData = learner->getMetierDataClass();
					learnerMetierData->excHandle(MAKEINT64(WCH_LockData,1));
					learnerMetierData->getParam(WCHDATA_MetierSkillASet,param);
                    MetierSkillASet *metierSkillASet = (MetierSkillASet *)param;
					if(!metierSkillASet || metierSkillASet->find(abstractid) == metierSkillASet->end())
					{
						learnSkillReturn = LC_CantLearn;
						learnerMetierData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					learnerMetierData->excHandle(MAKEINT64(WCH_LockData,0));
					crData *learnerData = learner->getDataClass();
					learnerData->excHandle(MAKEINT64(WCH_LockData,1));
					learnerData->getParam(WCHDATA_SkillPoint,param);
					unsigned short *skillPoint = (unsigned short *)param;
					if(*skillPoint==0)
					{
						learnSkillReturn = LC_SkillPointLack;
						learnerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					//金币
					unsigned char skillLevel = 0;
					int price = 0;
					int* learnerGold = NULL;
					ref_ptr<crInstanceItem>newSkill;
					learnerData->getParam(WCHDATA_SkillMap,param);
					SkillMap *skillMap = (SkillMap *)param;
					SkillMap::iterator smItr = skillMap->find(abstractid);
					if(smItr!=skillMap->end())
					{
						crItemChild *skillItemChild = learner->findChildItem(smItr->second);
						if(!skillItemChild || !skillItemChild->isLoaded())
						{
							learnSkillReturn = LC_Error;
							learnerData->excHandle(MAKEINT64(WCH_LockData,0));
							thisData->excHandle(MAKEINT64(WCH_LockData,0));
							break;
						}
						newSkill = skillItemChild->getInstanceItem();
						newSkill->getDataClass()->getParam(WCHDATA_SkillLevel,param);
						skillLevel = *(unsigned char *)param;
						newSkill->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
					}
					else
					{//学习新技能
						learnerData->getParam(WCHDATA_MaxSkill,param);
						unsigned char maxSkill = *(unsigned char*)param;
						if((int)maxSkill<=skillMap->size())
						{
							learnSkillReturn = LC_SkillMapFull;
							learnerData->excHandle(MAKEINT64(WCH_LockData,0));
							thisData->excHandle(MAKEINT64(WCH_LockData,0));
							break;
						}

                        learnSkill->doEvent(WCH_GetPrice,MAKEINT64(&price,NULL));
					}
					learnerData->getParam(WCHDATA_Gold,param);
					learnerGold = (int*)param;
					if(*learnerGold<price)
					{
						learnSkillReturn = LC_MoneyNotEnough;
						learnerData->excHandle(MAKEINT64(WCH_LockData,0));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					skillLevel++;
					if(!newSkill.valid())
					{//学习新技能
                        //learner->getCreateItemChildLock();
						learner->beginCreateItemChild(WCH_LearnSkillCreater,1);
						crNetConductor *gameNetConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
						crCreateItemChildPacket packet;
						crCreateItemChildPacket::buildRequestPacket(packet,learner,learner->getInstanceItemID(),abstractid);
						gameNetConductor->getNetManager()->sendPacket("all",packet);
						(*skillMap)[abstractid] = 0;
                       
						//crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						//CRNetApp::crScene *scene = callback->getScene();
						//newSkill = dynamic_cast<crInstanceItem *>(learnSkill->clone());
						//newSkill->setInstanceItemID(scene->gainTemporaryItemID());
                        //newSkillItemChild = new crItemChild;
						//newSkillItemChild->setItemChildID(scene->gainTemporaryItemChildID());
						//newSkillItemChild->setInstanceItem(newSkill.get());
						//learner->insertChildItem(newSkillItemChild.get());
						//(*skillMap)[abstractid] = newSkill->getInstanceItemID();//
					}
					else
					{
						crData *newSkillData = newSkill->getDataClass();
						newSkillData->inputParam(WCHDATA_SkillLevel,&skillLevel);
					}
					//后扣钱
					*learnerGold -= price;
					//扣点数
					(*skillPoint)--;
					learnerData->excHandle(MAKEINT64(WCH_LockData,0));//帐户解锁
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
					//m_this->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));
					//发送给客户端
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(17);
					stream->_writeChar(learnSkillReturn);
					stream->_writeInt(roleid);
					stream->_writeInt(*learnerGold);
					stream->_writeUShort(*skillPoint);
					stream->_writeInt(itemid);//buyitemid
					stream->_writeBool(newSkill.valid());
					if(newSkill.valid())
					{//升级
						stream->_writeUChar(skillLevel);
					}
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvLearnSkill,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					return;
				} while (0);
				if(learnSkillReturn!=LC_Success)
				{//向客户端发送失败信息
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeChar(learnSkillReturn);
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvLearnSkill,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char learnSkillReturn = m_stream->_readChar();
			if(learnSkillReturn == LC_Success)
			{
				int roleid = m_stream->_readInt();
				crRole *learner = crMyPlayerData::getInstance()->getRole(roleid);
				int gold = m_stream->_readInt();
				unsigned short skillPoint = m_stream->_readUShort();
				void *param;
				crData *learnerData = learner->getDataClass();
				//扣钱
				learnerData->excHandle(MAKEINT64(WCH_LockData,1));
				learnerData->getParam(WCHDATA_Gold,param);
				int* curGold = (int *)param;
				*curGold = gold;
				learnerData->getParam(WCHDATA_SkillPoint,param);
				unsigned short* curSkillPoint = (unsigned short *)param;
				*curSkillPoint = skillPoint;
				learnerData->excHandle(MAKEINT64(WCH_LockData,0));

				int buyitemid = m_stream->_readInt();
				crItemChild *buyitemchild = m_this->findChildItem(buyitemid);
				if(buyitemchild && buyitemchild->isLoaded())
				{
					crInstanceItem *buyitem = buyitemchild->getInstanceItem();
					int abstractid = buyitem->getAbstractItemID();

					learnerData->excHandle(MAKEINT64(WCH_LockData,1));
					learnerData->getParam(WCHDATA_SkillMap,param);
					SkillMap *skillMap = (SkillMap *)param;
					bool islvup = m_stream->_readBool();
					if(islvup)
					{
						unsigned char skillLevel = m_stream->_readUChar();

						crItemChild *skillItemChild = learner->findChildItem((*skillMap)[abstractid]);
						if(skillItemChild && skillItemChild->isLoaded())
						{
							crInstanceItem *skill = skillItemChild->getInstanceItem();
							skill->getDataClass()->inputParam(WCHDATA_SkillLevel,&skillLevel);
						}
					}
					else
					{
						ref_ptr<crInstanceItem> newSkill = dynamic_cast<crInstanceItem *>(buyitem->clone());
						(*skillMap)[abstractid] = newSkill->getInstanceItemID();
						learner->insertTemporaryItem(newSkill.get());
					}
					learnerData->excHandle(MAKEINT64(WCH_LockData,0));

					if(islvup) 
					{
						m_this->doEvent(WCH_BuildSaleItemList,NULL);
						learner->doEvent(WCH_BuildQuickList,NULL);
					}
					learner->doEvent(WCH_BuildSkillList,NULL);
					learner->doEvent(MAKEINT64(WCH_LearnedSkill,abstractid));
				}
				//learner->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
				//learner->doEvent(MAKEINT64(WCH_LearnedSkill,abstractid));
			}
			else
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crLearnSkillCreaterMethod
//
/////////////////////////////////////////
crLearnSkillCreaterMethod::crLearnSkillCreaterMethod():
m_createItemChildVec(NULL){}
crLearnSkillCreaterMethod::crLearnSkillCreaterMethod(const crLearnSkillCreaterMethod& handle):
crMethod(handle),
m_createItemChildVec(NULL)
{
}
void crLearnSkillCreaterMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_createItemChildVec = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_createItemChildVec = (crInstanceItem::CreateItemChildVec *)(LOINT64(param64));
		}
		else
		{
			m_createItemChildVec = NULL;
		}
		break;
	}
}
void crLearnSkillCreaterMethod::addParam(int i, const std::string& str)
{
}
void crLearnSkillCreaterMethod::operator()(crHandle &handle)
{
    if(m_this && m_createItemChildVec && m_createItemChildVec->size()>0)
	{
        crItemChild *itemChild = (*m_createItemChildVec)[0].get();
        crInstanceItem *skill = itemChild->getInstanceItem();
		crData *data = skill->getDataClass();
		unsigned char skilllevel = 1;
		data->inputParam(WCHDATA_SkillLevel,&skilllevel);

		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_SkillMap,param);
		SkillMap *skillMap = (SkillMap *)param;
		(*skillMap)[skill->getAbstractItemID()] = skill->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		//m_this->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Server));

		//send to client
		if(m_this->getItemtype() == crInstanceItem::Role)
		{
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(12);
				stream->_writeInt(skill->getAbstractItemID());
				stream->_writeInt(skill->getInstanceItemID());
				stream->_writeInt(itemChild->getItemChildID());
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvLearnSkillCreater,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvLearnSkillCreaterMethod
//
/////////////////////////////////////////
crRecvLearnSkillCreaterMethod::crRecvLearnSkillCreaterMethod(){}
crRecvLearnSkillCreaterMethod::crRecvLearnSkillCreaterMethod(const crRecvLearnSkillCreaterMethod& handle):
crMethod(handle)
{
}
void crRecvLearnSkillCreaterMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvLearnSkillCreaterMethod::addParam(int i, const std::string& str)
{
}
void crRecvLearnSkillCreaterMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		int abstractid = m_stream->_readInt();
		int itemid = m_stream->_readInt();
		int itemchildid = m_stream->_readInt();

		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_SkillMap,param);
		SkillMap *skillMap = (SkillMap *)param;
		int tempItemID = (*skillMap)[abstractid];
        ref_ptr<crInstanceItem> tempItem = m_this->findTemporaryItem(tempItemID);
		if(tempItem.valid())
		{
			m_this->removeTemporaryItem(tempItemID);
            tempItem->setInstanceItemID(itemid);
			ref_ptr<crItemChild> itemchild = new crItemChild;
			itemchild->setItemChildID(itemchildid);
			itemchild->setInstanceItem(tempItem.get());
			m_this->insertChildItem(itemchild.get());
			unsigned char skillLevel = 1;
            tempItem->getDataClass()->inputParam(WCHDATA_SkillLevel,&skillLevel);
			(*skillMap)[abstractid] = itemid;
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		//crRole *me = crMyPlayerData::getInstance()->getRole();
		m_this->clientGetTarget(targetItem,targetNode);
		if(targetItem.valid())
		    targetItem->doEvent(WCH_BuildSaleItemList,NULL);

		tempItem->clientLoadItemChildNode(m_this);

		//m_this->doEvent(MAKEINT64(WCH_UpdateQuickList,UT_Client));
		////load skill node
		//CRCore::ref_ptr<crGroup> group = new crGroup;
		////group->setCullingActive(false);
		//const std::string &filename = tempItem->getFileName();
		//if(!filename.empty())
		//{
		//	CRIOManager::crLoadManager::getInstance()->requestNode(filename,group.get(),false);
		//}
		//const std::string &resScript = tempItem->getResScript();
		//if(!resScript.empty())
		//{//group->getChild(0) = weaponMatterObject; group->getChild(1) = bulletMatterObject
		//	CREncapsulation::loadSkillCfg(resScript,group.get());
		//	crData *data;
		//	crNode *child = NULL;
		//	for(int i = 0; i<group->getNumChildren(); ++i)
		//	{
		//		child = group->getChild(i);
		//		if(child)
		//		{
		//			data = child->getDataClass();
		//			if(data)
		//			{
		//				data->inputParam(WCHDATA_Item,tempItem.get());
		//			}
		//		}
		//	}
		//}
		//tempItem->setNode(group.get());
		//CRIOManager::crLoadManager::getInstance()->requestAddNode(dynamic_cast<crGroup *>(m_this->getNode()),group.get(),true);
	}
}
/////////////////////////////////////////
//
//crLearnSkillNotifyMethod
//
/////////////////////////////////////////
crLearnSkillNotifyMethod::crLearnSkillNotifyMethod(){}
crLearnSkillNotifyMethod::crLearnSkillNotifyMethod(const crLearnSkillNotifyMethod& handle):
crMethod(handle)
{
}
void crLearnSkillNotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crLearnSkillNotifyMethod::addParam(int i, const std::string& str)
{
}
void crLearnSkillNotifyMethod::operator()(crHandle &handle)
{
	//std::string str = "网络未响应";
	//if(m_stream.valid())
	//{
	//	char learnSkillReturn = m_stream->_readChar();
	//	switch(learnSkillReturn)
	//	{
	//	case LC_Success:
	//		str = "学习成功！";
	//		break;
	//	case LC_CantLearn:
	//		str = "学习失败，该技能您无法学习！";
	//		break;
	//	case LC_SkillPointLack:
	//		str = "学习失败，您的技能点不足！";
	//		break;
	//	case LC_MoneyNotEnough:
	//		str = "学习失败，您的钱不够！";
	//		break;
	//	case LC_SkillMapFull:
	//		str = "学习失败，您不能学更多的技能了！";
	//		break;
	//	default:
	//		str = "学习失败";
	//		break;
	//	}
	//}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crUIAttrPointLRMethod
//
/////////////////////////////////////////
crUIAttrPointLRMethod::crUIAttrPointLRMethod():
m_step(1)
{
}
crUIAttrPointLRMethod::crUIAttrPointLRMethod(const crUIAttrPointLRMethod& handle):
crMethod(handle),
m_attrpoint(handle.m_attrpoint),
m_attr(handle.m_attr),
m_attrok(handle.m_attrok),
m_step(handle.m_step),
m_attrType(handle.m_attrType)
{
}
void crUIAttrPointLRMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}
void crUIAttrPointLRMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_attrpoint = str;
		break;
	case 1:
		m_attr = str;
		break;
	case 2:
		m_attrok = str;
		break;
	case 3:
		m_step = atoi(str.c_str());
		break;
	case 4:
		m_attrType = atoi(str.c_str());
		break;
	}
}
void crUIAttrPointLRMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(stage)
		{
			crStaticTextBoxElement *attrpointElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_attrpoint));
			crStaticTextBoxElement *attrElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_attr));
			crButtonElement *attrokElement = dynamic_cast<crButtonElement *>(stage->getElement(m_attrok));

			if(attrpointElement && attrElement && attrokElement)
			{
				void *param;
				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
				crData *myData = me->getDataClass();
				myData->getParam(WCHDATA_AttrPoint,param);
				unsigned short attrPoint = *(unsigned short *)param;
				myData->getParam(m_attrType,param);
				short attrValue = *(short *)param;
				if(attrPoint>0)
				{
					std::string attrPointStr = attrpointElement->getStringArrayInString();
					int attrpoint = atoi(attrPointStr.c_str());
					attrpoint -= m_step;
					std::string attrStr = attrElement->getStringArrayInString();
					int attr = atoi(attrStr.c_str());
					attr += m_step;
					if(attrpoint>=0 && attrpoint<=(int)attrPoint && attr>=(int)attrValue)
					{
						attrokElement->setShow(true);
						attrokElement->setEnable(true);
						attrpointElement->setStringArrayByString(CRCore::crArgumentParser::appItoa(attrpoint));
						attrElement->setStringArrayByString(CRCore::crArgumentParser::appItoa(attr));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crUIAttrPointLR2Method
//
/////////////////////////////////////////
crUIAttrPointLR2Method::crUIAttrPointLR2Method():
m_step(1)
{
}
crUIAttrPointLR2Method::crUIAttrPointLR2Method(const crUIAttrPointLR2Method& handle):
crMethod(handle),
m_attrpoint(handle.m_attrpoint),
m_attr(handle.m_attr),
m_attrok(handle.m_attrok),
m_step(handle.m_step),
m_attrType(handle.m_attrType)
{
}
void crUIAttrPointLR2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crUIAttrPointLR2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_attrpoint = str;
		break;
	case 1:
		m_attr = str;
		break;
	case 2:
		m_attrok = str;
		break;
	case 3:
		m_step = atoi(str.c_str());
		break;
	case 4:
		m_attrType = atoi(str.c_str());
		break;
	}
}
void crUIAttrPointLR2Method::operator()(crHandle &handle)
{
	if(m_this)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		if(canvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> attrpointWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_attrpoint));
			ref_ptr<crHypertextWidgetNode> attrWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_attr));
			ref_ptr<crButtonWidgetNode> attrokWidget = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_attrok));

			if(attrpointWidget.valid() && attrWidget.valid() && attrokWidget.valid())
			{
				void *param;
				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
				crData *myData = me->getDataClass();
				myData->getParam(WCHDATA_AttrPoint,param);
				unsigned short attrPoint = *(unsigned short *)param;
				myData->getParam(m_attrType,param);
				short attrValue = *(short *)param;
				if(attrPoint>0)
				{
					const std::wstring& attrPointStr = attrpointWidget->getString();
					int attrpoint = _wtoi(attrPointStr.c_str());
					attrpoint -= m_step;
					std::wstring attrStr;
					attrWidget->getString(0,attrStr);
					int attr = _wtoi(attrStr.c_str());
					attr += m_step;
					if(attrpoint>=0 && attrpoint<=(int)attrPoint && attr>=(int)attrValue)
					{
						attrokWidget->setVisiable(true);
						//attrok->setEnable(true);
						attrpointWidget->setString(CRCore::crArgumentParser::appItoa(attrpoint));
						attrWidget->modifyString(0,CRCore::crArgumentParser::appItoa(attr));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crUIAttrPointOKMethod
//
/////////////////////////////////////////
crUIAttrPointOKMethod::crUIAttrPointOKMethod()
{
}
crUIAttrPointOKMethod::crUIAttrPointOKMethod(const crUIAttrPointOKMethod& handle):
crMethod(handle),
m_attrpoint(handle.m_attrpoint),
m_strength(handle.m_strength),
m_agility(handle.m_agility),
m_intellect(handle.m_intellect)
{
}
void crUIAttrPointOKMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}
void crUIAttrPointOKMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_attrpoint = str;
		break;
	case 1:
		m_strength = str;
		break;
	case 2:
		m_agility = str;
		break;
	case 3:
		m_intellect = str;
		break;
	}
}
void crUIAttrPointOKMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(stage)
		{
			crStaticTextBoxElement *attrpointElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_attrpoint));
			crStaticTextBoxElement *strengthElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_strength));
			crStaticTextBoxElement *agilityElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_agility));
			crStaticTextBoxElement *intellectElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_intellect));
			if(attrpointElement && strengthElement && agilityElement && intellectElement)
			{
				void *param;
				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
				crData *myData = me->getDataClass();
                bool hasChange = false;

				myData->excHandle(MAKEINT64(WCH_LockData,1));

				myData->getParam(WCHDATA_AttrPoint,param);
				unsigned short* attrpoint = (unsigned short *)param;
				unsigned short attrPoint = (unsigned short)(atoi(attrpointElement->getStringArrayInString().c_str()));
				if(*attrpoint!=attrPoint)
				{
					hasChange = true;
					*attrpoint = attrPoint;
				}

				myData->getParam(WCHDATA_Strength,param);
				short* strength = (short *)param;
				unsigned char _strength = (unsigned char)(atoi(strengthElement->getStringArrayInString().c_str()));
				if(*strength!=_strength)
				{
					hasChange = true;
					*strength = _strength;
				}

				myData->getParam(WCHDATA_Agility,param);
				short* agility = (short *)param;
				unsigned char _agility = (unsigned char)(atoi(agilityElement->getStringArrayInString().c_str()));
				if(*agility!=_agility)
				{
					hasChange = true;
					*agility = _agility;
				}

				myData->getParam(WCHDATA_Intellect,param);
				short* intellect = (short *)param;
				unsigned char _intellect = (unsigned char)(atoi(intellectElement->getStringArrayInString().c_str()));
				if(*intellect!=_intellect)
				{
					hasChange = true;
					*intellect = _intellect;
				}

				//send change to net
				if(hasChange)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeUShort(*attrpoint);
					stream->_writeShort(*strength);
					stream->_writeShort(*agility);
					stream->_writeShort(*intellect);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{
						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,me,WCH_RecvAttrChange,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
				myData->excHandle(MAKEINT64(WCH_LockData,0));

				m_element->setShow(false);
				m_element->setEnable(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crUIAttrPointOK2Method
//
/////////////////////////////////////////
crUIAttrPointOK2Method::crUIAttrPointOK2Method()
{
}
crUIAttrPointOK2Method::crUIAttrPointOK2Method(const crUIAttrPointOK2Method& handle):
crMethod(handle),
m_attrpoint(handle.m_attrpoint),
m_strength(handle.m_strength),
m_agility(handle.m_agility),
m_intellect(handle.m_intellect)
{
}
void crUIAttrPointOK2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crUIAttrPointOK2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_attrpoint = str;
		break;
	case 1:
		m_strength = str;
		break;
	case 2:
		m_agility = str;
		break;
	case 3:
		m_intellect = str;
		break;
	}
}
void crUIAttrPointOK2Method::operator()(crHandle &handle)
{
	if(m_this)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		if(canvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> attrpointWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_attrpoint));
			ref_ptr<crHypertextWidgetNode> strengthWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_strength));
			ref_ptr<crHypertextWidgetNode> agilityWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_agility));
			ref_ptr<crHypertextWidgetNode> intellectWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_intellect));
			if(attrpointWidget.valid() && strengthWidget.valid() && agilityWidget.valid() && intellectWidget.valid())
			{
				void *param;
				crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
				crData *myData = me->getDataClass();
				bool hasChange = false;

				myData->excHandle(MAKEINT64(WCH_LockData,1));

				myData->getParam(WCHDATA_AttrPoint,param);
				unsigned short* attrpoint = (unsigned short *)param;
				unsigned short attrPoint = (unsigned short)(_wtoi(attrpointWidget->getString().c_str()));
				if(*attrpoint!=attrPoint)
				{
					hasChange = true;
					*attrpoint = attrPoint;
				}
				
				std::wstring attrStr;
				strengthWidget->getString(0,attrStr);
				myData->getParam(WCHDATA_Strength,param);
				short* strength = (short *)param;
				short _strength = (short)(_wtoi(attrStr.c_str()));
				if(*strength!=_strength)
				{
					hasChange = true;
					*strength = _strength;
				}

				attrStr.clear();
				agilityWidget->getString(0,attrStr);
				myData->getParam(WCHDATA_Agility,param);
				short* agility = (short *)param;
				short _agility = (short)(_wtoi(attrStr.c_str()));
				if(*agility!=_agility)
				{
					hasChange = true;
					*agility = _agility;
				}

				attrStr.clear();
				intellectWidget->getString(0,attrStr);
				myData->getParam(WCHDATA_Intellect,param);
				short* intellect = (short *)param;
				short _intellect = (short)(_wtoi(attrStr.c_str()));
				if(*intellect!=_intellect)
				{
					hasChange = true;
					*intellect = _intellect;
				}

				//send change to net
				if(hasChange)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeUShort(*attrpoint);
					stream->_writeShort(*strength);
					stream->_writeShort(*agility);
					stream->_writeShort(*intellect);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{
						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,me,WCH_RecvAttrChange,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
				myData->excHandle(MAKEINT64(WCH_LockData,0));

				m_this->setVisiable(false);
				//m_this->setEnable(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvAttrChangeMethod
//
/////////////////////////////////////////
crRecvAttrChangeMethod::crRecvAttrChangeMethod():
m_netType(GameClient_Game){}
crRecvAttrChangeMethod::crRecvAttrChangeMethod(const crRecvAttrChangeMethod& handle):
crMethod(handle)
{
}
void crRecvAttrChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvAttrChangeMethod::addParam(int i, const std::string& str)
{
}

void crRecvAttrChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		crData *data = m_this->getDataClass();
        unsigned short attrpoint = m_stream->_readUShort();
		short strength = m_stream->_readShort();
		short agility = m_stream->_readShort();
		short intellect = m_stream->_readShort();
		data->inputParam(WCHDATA_AttrPoint,&attrpoint);
		data->inputParam(WCHDATA_Strength,&strength);
		data->inputParam(WCHDATA_Agility,&agility);
		data->inputParam(WCHDATA_Intellect,&intellect);
	}
}
/////////////////////////////////////////
//
//crBuildSkillListMethod
//
/////////////////////////////////////////
crBuildSkillListMethod::crBuildSkillListMethod(){}
crBuildSkillListMethod::crBuildSkillListMethod(const crBuildSkillListMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_skillList(handle.m_skillList)
{
}
void crBuildSkillListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crBuildSkillListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_skillList = str;
		break;
	}
}
void crBuildSkillListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		if(!crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			return;
		crListControlElement *skillList = dynamic_cast<crListControlElement *>(imageStage->getElement(m_skillList));
		if(skillList)
		{
			skillList->clear();
			skillList->lockList();
			crListControlElement::ListNodeVec& listNodeVec = skillList->getListNodeVec();
			//crRole *me = crMyPlayerData::getInstance()->getRole();
			void *param;
			crData *myData = m_this->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_SkillMap,param);
			SkillMap* skillMap = (SkillMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			unsigned char skilllevel;
			ref_ptr<crListNode> listNode;
			std::string title,title2;
			for( SkillMap::iterator itr = skillMap->begin();
				itr != skillMap->end();
				++itr )
			{
				if(itr->second!=0)
				{
					itemchild = m_this->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;
						itemData->getParam(WCHDATA_SkillLevel,param);
						skilllevel = *(unsigned char*)param;
						title = item->getIName();
						title2 = CRCore::crArgumentParser::appItoa((int)skilllevel);

						listNode = new crListNode;
						listNode->setTitle(title);
						listNode->setTitle2(title2);
						listNode->setData(item);
						listNode->addBitMapFile(iconfile);
						listNodeVec.push_back(listNode.get());
					}
				}
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			skillList->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildSkillList2Method
//
/////////////////////////////////////////
crBuildSkillList2Method::crBuildSkillList2Method(){}
crBuildSkillList2Method::crBuildSkillList2Method(const crBuildSkillList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_listName(handle.m_listName)
{
}
void crBuildSkillList2Method::inputParam(int i, void *param)
{
}
void crBuildSkillList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_listName = str;
		break;
	}
}
void crBuildSkillList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode>skillList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_listName));
		if(skillList.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *myData = me->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_SkillMap,param);
			SkillMap* skillMap = (SkillMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			unsigned char skilllevel;
			ref_ptr<crListNode> listNode;
			std::string title,title2;
			skillList->setListNodeCount(skillMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = skillList->getListNodeVec();
			int i = 0;
			for( SkillMap::iterator itr = skillMap->begin();
				itr != skillMap->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second!=0)
				{
					itemchild = me->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;
						itemData->getParam(WCHDATA_SkillLevel,param);
						skilllevel = *(unsigned char*)param;
						title = item->getIName();
						title2 = CRCore::crArgumentParser::appItoa((int)skilllevel);

						listNodeVec[i]->setTitle(title);
						listNodeVec[i]->setTitle2(title2);
						listNodeVec[i]->setData(item);
						listNodeVec[i]->setImageName(iconfile);
						listNodeVec[i]->setVisiable(true);
					}
				}
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crUIEquipItemMethod
//
/////////////////////////////////////////
crUIEquipItemMethod::crUIEquipItemMethod()
{
}
crUIEquipItemMethod::crUIEquipItemMethod(const crUIEquipItemMethod& handle):
crMethod(handle),
m_backPackControl(handle.m_backPackControl)
{
}
void crUIEquipItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crListControlElement*)param;
}
void crUIEquipItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_backPackControl = str;
		break;
	}
}
void crUIEquipItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_element.valid()) break;

		crImageStage *stage = m_element->getParentStage();
		crListControlElement *listControl = dynamic_cast<crListControlElement *>(stage->getElement(m_backPackControl));
		if(!listControl) break;
		crListNode *listNode = listControl->getSelectNode();
		if(!listNode) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		//检查item是否可装备
		void *param;
		crData *itemData = item->getDataClass();
		itemData->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *((unsigned char*)param);
		int itemid = item->getInstanceItemID();
		if(datatype == DT_Equip)
		{
			//检查是否有空间
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap *equipOnMap = (EquipOnMap *)param;
			myData->getParam(WCHDATA_MaxEquipon,param);
			unsigned char maxEquipOn = *(unsigned char *)param;
			if((int)maxEquipOn<=equipOnMap->size())
			{//
				//std::string str = "您的装备栏已经满了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(itemid);

			crWaitNetReturnStreamLogic::getLock();
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEquipOnItem,me,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			canceleTask = false;
		}
		else if(datatype == DT_Thing || datatype == DT_Skill || datatype == DT_Attack || datatype == DT_AttackThing)
		{//重复性检查(仅客户端校验就可以了)
			//检查是否有空间
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_QuickList,param);
			QuickList *quickList = (QuickList *)param;
			int abstractid = item->getAbstractItemID();
			QuickList::iterator itr = quickList->begin();
			bool found = false;
			for( ; itr != quickList->end() && itr->first == abstractid; ++itr)
			{
				if(itr->second == itemid)
				{
                    found = true;
					break;
				}
			}
			if(found)
			{
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->getParam(WCHDATA_MaxQuick,param);
			unsigned char maxQuick = *(unsigned char *)param;
			if((int)maxQuick<=quickList->size())
			{//
				//std::string str = "您的快捷栏已经满了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(itemid);

			crWaitNetReturnStreamLogic::getLock();
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEquipQuick,me,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			canceleTask = false;
		}
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIEquipItem2Method
//
/////////////////////////////////////////
crUIEquipItem2Method::crUIEquipItem2Method()
{
}
crUIEquipItem2Method::crUIEquipItem2Method(const crUIEquipItem2Method& handle):
crMethod(handle)
{
}
void crUIEquipItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUIEquipItem2Method::addParam(int i, const std::string& str)
{
}
void crUIEquipItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this) break;

		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode||!listNode->getVisiable()) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		//检查item是否可装备
		void *param;
		crData *itemData = item->getDataClass();
		itemData->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *((unsigned char*)param);
		int itemid = item->getInstanceItemID();
		if(datatype == DT_Equip)
		{
			//检查是否有空间
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap *equipOnMap = (EquipOnMap *)param;
			myData->getParam(WCHDATA_MaxEquipon,param);
			unsigned char maxEquipOn = *(unsigned char *)param;
			if((int)maxEquipOn<=equipOnMap->size())
			{//
				//std::string str = "您的装备栏已经满了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(itemid);

			crWaitNetReturnStreamLogic::getLock();
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEquipOnItem,me,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			canceleTask = false;
		}
		else if(datatype == DT_Thing || datatype == DT_Skill || datatype == DT_Attack || datatype == DT_AttackThing)
		{//重复性检查(仅客户端校验就可以了)
			//检查是否有空间
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_QuickList,param);
			QuickList *quickList = (QuickList *)param;
			int abstractid = item->getAbstractItemID();
			QuickList::iterator itr = quickList->begin();
			bool found = false;
			for( ; itr != quickList->end() && itr->first == abstractid; ++itr)
			{
				if(itr->second == itemid)
				{
					found = true;
					break;
				}
			}
			if(found)
			{
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->getParam(WCHDATA_MaxQuick,param);
			unsigned char maxQuick = *(unsigned char *)param;
			if((int)maxQuick<=quickList->size())
			{//
				//std::string str = "您的快捷栏已经满了";
				//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
				myData->excHandle(MAKEINT64(WCH_LockData,0));
				break;
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(itemid);

			crWaitNetReturnStreamLogic::getLock();
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEquipQuick,me,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			canceleTask = false;
		}
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvEquipOnItemMethod
//
/////////////////////////////////////////
crRecvEquipOnItemMethod::crRecvEquipOnItemMethod():
m_netType(GameClient_Game){}
crRecvEquipOnItemMethod::crRecvEquipOnItemMethod(const crRecvEquipOnItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvEquipOnItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvEquipOnItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvEquipOnItemMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			int playerid = m_this->getID();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				int itemid = m_stream->_readInt();
				char returnCode = EC_Success;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				do
				{
					ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
					if(!itemChild || !itemChild->isLoaded()) 
					{
						returnCode = EC_Error;
						break;
					}
					crInstanceItem *item = itemChild->getInstanceItem();
					//检查item是否可装备
					void *param;
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_DataType,param);
					unsigned char datatype = *((unsigned char*)param);
					if(datatype != DT_Equip)
					{
						returnCode = EC_DataTypeError;
						break;
					}
					int abstractid = item->getAbstractItemID();
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_EquipOnMap,param);
					EquipOnMap *equipOnMap = (EquipOnMap *)param;
					thisData->getParam(WCHDATA_MaxEquipon,param);
					unsigned char maxEquipOn = *(unsigned char *)param;
					if((int)maxEquipOn<=equipOnMap->size())
					{//
						returnCode = EC_EquipOnMapFull;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					//获得装备之前的MAXHP
					float maxhp = 0;
					m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
					float maxmp = 0;
					m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
					//放入EquipOnMap
					equipOnMap->insert(std::make_pair(abstractid,itemid));
					//从backpack移除
					char removeItem = -1;
					m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
					if(removeItem<0)
					{
						returnCode = EC_NotInBackPack;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}

					//检查是否有符合合成条件的装备
					crItemChild *composeItemChild;
					crInstanceItem *composeItem;
					crData *composeItemData;
					EquipOnMap::iterator eonitr;
					EquipComposeRequestVec *equipCompose = NULL;
					EquipComposeRequestVec::iterator ecitr;
					std::vector<crVector2i> FindCompose;
					int composeEquipID = 0;
					int composeEquipItemID = 0;
					EquipOnMap equipOnMap2;
					bool foundEquip = false;
					for( EquipOnMap::iterator itr = equipOnMap->begin();
						 itr != equipOnMap->end();
						 ++itr )
					{
						composeItemChild = m_this->findChildItem(itr->second);
						if(!composeItemChild || !composeItemChild->isLoaded()) 
							continue;
						composeItem = composeItemChild->getInstanceItem();
                        composeItemData = composeItem->getDataClass();
						composeItemData->getParam(WCHDATA_EquipComposeRequestVec,param);
						equipCompose = (EquipComposeRequestVec *)param;
						if(!equipCompose->empty())
						{
							FindCompose.clear();
							FindCompose.reserve(equipCompose->size());
							equipOnMap2 = *equipOnMap;
							foundEquip = false;
							for( EquipComposeRequestVec::iterator ecitr = equipCompose->begin();
								ecitr != equipCompose->end();
								++ecitr )
							{
								eonitr = equipOnMap2.find(*ecitr);
								if(eonitr == equipOnMap2.end())
								{
									foundEquip = false;
									break;
								}
								for(; eonitr != equipOnMap2.end() && eonitr->first == *ecitr; ++eonitr)
								{//itemid>0的装备不能合成
									if(eonitr->second<0)
									{
										FindCompose.push_back(crVector2i(eonitr->first,eonitr->second));
										equipOnMap2.erase(eonitr);
										foundEquip = true;
									    break;
									}
								}
								if(!foundEquip)
								{
									break;
								}
							}
							if(foundEquip)
							{//合成
                                composeItemData->getParam(WCHDATA_ComposeEquipID,param);
								composeEquipID = *(int *)param;
								//1次只可能有一个装备符合合成条件
                                break;
							}
						}
					}
					crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
					std::vector<crVector2i>NeedRemoveFromEquipOn;
					std::vector<int>NeedRemoveItemChild;
					if(foundEquip)
					{
						thisData->getParam(WCHDATA_BackPackMap,param);
						BackPackMap *backPackMap = (BackPackMap *)param;
						BackPackMap::iterator bpitr;
						crItemChild *removeItemChild;
						int abstractid,itemid,itemchildid;
						for( std::vector<crVector2i>::iterator fcitr = FindCompose.begin();
							fcitr != FindCompose.end();
							++fcitr )
						{
							abstractid = (*fcitr)[0];
							itemid = (*fcitr)[1];
							NeedRemoveFromEquipOn.push_back(crVector2i(abstractid,itemid));
                            
							eonitr = equipOnMap->find(abstractid);
							for( ; eonitr != equipOnMap->end() && eonitr->first == abstractid; ++eonitr)
							{
								if(eonitr->second == itemid)
								{
									equipOnMap->erase(eonitr);
									break;
								}
							}
						}
						//查找身上装备、包裹、（背包）里是否还有该类型的item，如果没有则RemoveItemChild
						bool found = false;
						for( std::vector<crVector2i>::iterator fcitr = FindCompose.begin();
							fcitr != FindCompose.end();
							++fcitr )
						{
							abstractid = (*fcitr)[0];
							itemid = (*fcitr)[1];
							found = false;
							eonitr = equipOnMap->find(abstractid);
							for( ; eonitr != equipOnMap->end() && eonitr->first == abstractid; ++eonitr)
							{
								if(eonitr->second == itemid)
								{
									found = true;
									break;
								}
							}
							if(!found)
							{
								bpitr = backPackMap->find(abstractid);
								for( ; bpitr != backPackMap->end() && bpitr->first == abstractid; ++bpitr)
								{
									if(bpitr->second == itemid)
									{
										found = true;
										break;
									}
								}
							}
							if(!found)
							{//remove itemchild
								removeItemChild = m_this->findChildItem(itemid);
								if(removeItemChild && removeItemChild->isLoaded())
								{
									itemchildid = removeItemChild->getItemChildID();
									m_this->removeChildItem(itemchildid);
									crGlobalHandle::recycleItemChildID(itemchildid);
									crGlobalHandle::recycleItemID(itemid);
									NeedRemoveItemChild.push_back(itemchildid);
								}
							}
						}
						//查找合成装备是否已经有了，如果没有则创建
						crItemChild *composeItemChild = m_this->findTemporaryItemChild(composeEquipID);
						if(composeItemChild)
						{
							composeEquipItemID = composeItemChild->getInstanceItemID();
							equipOnMap->insert(std::make_pair(composeEquipID,composeEquipItemID));
							returnCode = EC_FoundComposeEquip;
						}
						else
						{
							//m_this->getCreateItemChildLock();
							m_this->beginCreateItemChild(WCH_ComposeEquipCreater,1);
							crNetConductor *gameNetConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
							crCreateTemporaryItemChildPacket packet;
							crCreateTemporaryItemChildPacket::buildRequestPacket(packet,m_this,m_this->getInstanceItemID(),composeEquipID);
							gameNetConductor->getNetManager()->sendPacket("all",packet);
							equipOnMap->insert(std::make_pair(composeEquipID,-1));

							returnCode = EC_CreateComposeEquip;
						}
					}
					//获得装备之后的MAXHP
					float maxhp2 = 0;
					m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp2,NULL));
					float maxmp2 = 0;
					m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp2,NULL));
					thisData->getParam(WCHDATA_RTHP,param);
					float* rthp = (float*)param;
					*rthp += maxhp2-maxhp;
					thisData->getParam(WCHDATA_RTMP,param);
					float* rtmp = (float*)param;
					*rtmp += maxmp2-maxmp;
					if(returnCode != EC_Success)
					{//10+8*8+8
						stream->createBuf(99);
						stream->_writeChar(returnCode);
						stream->_writeInt(abstractid);
						stream->_writeInt(itemid);
						stream->_writeUChar((unsigned char)(NeedRemoveFromEquipOn.size()));
						for( std::vector< crVector2i >::iterator itr = NeedRemoveFromEquipOn.begin();
							 itr != NeedRemoveFromEquipOn.end();
							 ++itr )
						{
							stream->_writeVec2i(*itr);
						}
						stream->_writeUChar((unsigned char)(NeedRemoveItemChild.size()));
						for( std::vector< int >::iterator itr = NeedRemoveItemChild.begin();
							itr != NeedRemoveItemChild.end();
							++itr )
						{
							stream->_writeInt(*itr);
						}
                        stream->_writeInt(composeEquipID);
						if(returnCode == EC_FoundComposeEquip)
                            stream->_writeInt(composeEquipItemID);
					}
					else
					{
						stream->createBuf(17);
						stream->_writeChar(returnCode);
						stream->_writeInt(abstractid);
						stream->_writeInt(itemid);
					}
					stream->_writeFloat(*rthp);
					stream->_writeFloat(*rtmp);

					//ref_ptr<crStreamBuf> equipOnStream = new crStreamBuf;
					//equipOnStream->createBuf(equipOnMap->size() * 8+1);//8*10
					//equipOnStream->_writeUChar(equipOnMap->size());
					//for( EquipOnMap::iterator itr = equipOnMap->begin();
					//	itr != equipOnMap->end();
					//	++itr )
					//{
					//	equipOnStream->_writeInt(itr->first);
					//	equipOnStream->_writeInt(itr->second);
					//}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvEquipOnItem,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					scene->sendPacketToItemNeighbor(m_this,packet);
					
					//crPlayerEventPacket::buildRequestPacket(packet,0,playerData->getPlayerID(),WCH_RecvEquipOnMap,equipOnStream.get());
					//playerData->sendPacketToNeighbor(packet);
                    return;
				} while (0);
				stream->createBuf(1);
				stream->_writeChar(returnCode);
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvEquipOnItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char returnCode = m_stream->_readChar();
			if(returnCode == EC_Success || returnCode == EC_CreateComposeEquip || returnCode == EC_FoundComposeEquip)
			{
				int abstractid = m_stream->_readInt();
				int itemid = m_stream->_readInt();
				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_EquipOnMap,param);
                EquipOnMap *equipOnMap = (EquipOnMap *)param;

				ref_ptr<crItemChild>itemChild = m_this->findChildItem(itemid);
				if(itemChild.valid() && itemChild->isLoaded())
				{
					equipOnMap->insert(std::make_pair(abstractid,itemid));
					crInstanceItem *item = itemChild->getInstanceItem();
					char removeItem = -1;
					m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
				}
				else if(returnCode == EC_Success)
				{//需要下载itemChild
					equipOnMap->insert(std::make_pair(abstractid,0/*INT_MIN*/));
					crRequestItemChildPacket packet;
					crRequestItemChildPacket::buildRequestPacket(packet,m_this,itemid);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{
					equipOnMap->insert(std::make_pair(abstractid,itemid));
				}
				if(returnCode == EC_CreateComposeEquip || returnCode == EC_FoundComposeEquip)
				{
					crVector2i vec2i;
					int itemchildid;
                    unsigned char size = m_stream->_readUChar();
					unsigned char i = 0;
					EquipOnMap::iterator eitr;
					for( i=0; i<size; ++i)
					{
						vec2i = m_stream->_readVec2i();
						eitr = equipOnMap->find(vec2i[0]);
						for( ; eitr != equipOnMap->end() && eitr->first == vec2i[0]; ++eitr )
						{
							if(eitr->second = vec2i[1])
							{
								equipOnMap->erase(eitr);
								break;
							}
						}
					}
					size = m_stream->_readUChar();
					for( i=0; i<size; ++i)
					{
						itemchildid = m_stream->_readInt();
						m_this->removeChildItem(itemchildid);
					}
					int composeEquipID = m_stream->_readInt();
					int composeEquipItemID = 0/*INT_MIN*/;//资源稍后会传送过来//crComposeEquipCreaterMethod
					if(returnCode == EC_FoundComposeEquip)
					{
						composeEquipItemID = m_stream->_readInt();
						itemChild = m_this->findChildItem(composeEquipItemID);
						if(!itemChild.valid() || !itemChild->isLoaded())
						{//需要下载itemChild
							crRequestItemChildPacket packet;
							crRequestItemChildPacket::buildRequestPacket(packet,m_this,composeEquipItemID);
							crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
					equipOnMap->insert(std::make_pair(composeEquipID,composeEquipItemID));
				}
				thisData->getParam(WCHDATA_RTHP,param);
				float* rthp = (float*)param;
				*rthp = m_stream->_readFloat();
				thisData->getParam(WCHDATA_RTMP,param);
				float* rtmp = (float*)param;
				*rtmp = m_stream->_readFloat();
                thisData->excHandle(MAKEINT64(WCH_LockData,0));

				m_this->doEvent(WCH_CheckAndRackEquipOnMesh,NULL);
				if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
				{
					m_this->doEvent(WCH_BuildEquipOnList,NULL);
					//m_this->doEvent(WCH_BuildBackPackList,NULL);
				}
				else
				{
					return;
				}
			}
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crComposeEquipCreaterMethod
//
/////////////////////////////////////////
crComposeEquipCreaterMethod::crComposeEquipCreaterMethod():
m_createItemChildVec(NULL){}
crComposeEquipCreaterMethod::crComposeEquipCreaterMethod(const crComposeEquipCreaterMethod& handle):
crMethod(handle),
m_createItemChildVec(NULL)
{
}
void crComposeEquipCreaterMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_createItemChildVec = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_createItemChildVec = (crInstanceItem::CreateItemChildVec *)(LOINT64(param64));
		}
		else
		{
			m_createItemChildVec = NULL;
		}
		break;
	}
}
void crComposeEquipCreaterMethod::addParam(int i, const std::string& str)
{
}
void crComposeEquipCreaterMethod::operator()(crHandle &handle)
{
	if(m_this && m_createItemChildVec && m_createItemChildVec->size()>0)
	{
		crItemChild *itemChild = (*m_createItemChildVec)[0].get();
		crInstanceItem *equip = itemChild->getInstanceItem();
		//send to client
		if(m_this->getItemtype() == crInstanceItem::Role)
		{
			int playerid = m_this->getID();
			crData *data = equip->getDataClass();
			data->inputParam(WCHDATA_BelongPlayerID,&playerid);

			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				int count = 0;
				std::vector< ref_ptr<crStreamBuf> > BufVec;

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(MTUBUFFERSIZE);//MAXBUFFERSIZE-12);
				stream->_writeInt(m_this->getID());
				stream->_writeInt(m_this->getRoleID());
				stream->_writeInt64(WCH_RecvComposeEquipCreater);
				stream->_writeInt(itemChild->getItemChildID());
				writeItem(equip,stream,BufVec,count,NetStream);
				if(stream->getBufSize()>0)
				{
					count += stream->getBufSize();
					BufVec.push_back(stream.get());
				}
				if(count>0)
				{
					int streamid = crDataStreamTransfer::getInstance()->gainStreamID();
					crCreateDataStreamPacket packet;
					crCreateDataStreamPacket::buildRequestPacket(packet,playerid,streamid,crPlayerEventPacket::ID,count);
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					crDataStreamPacket streamPacket;
					for( std::vector< ref_ptr<crStreamBuf> >::iterator itr = BufVec.begin();
						itr != BufVec.end();
						++itr )
					{
						crDataStreamPacket::buildRequestPacket(streamPacket,playerid,streamid,crPlayerEventPacket::ID,itr->get());
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),streamPacket);
					}
					crDataStreamTransfer::getInstance()->recycleStreamID(streamid,crGlobalHandle::gData()->gRecycleStreamIDTime_out());
				}
				//if(BufVec.size()>1)
				//{
				//	CRCore::notify(CRCore::ALWAYS)<<"crComposeEquipCreaterMethod溢出，需要采用DataStream方式传输"<<std::endl;
				//}
				//else
				//{
				//	stream = BufVec[0].get();
				//	crPlayerEventPacket packet;
				//	crPlayerEventPacket::buildRequestPacket(packet,playerid,playerid,WCH_RecvComposeEquipCreater,stream.get());
				//	netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				//	playerData->sendPacketToNeighbor(packet);
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvComposeEquipCreaterMethod
//
/////////////////////////////////////////
crRecvComposeEquipCreaterMethod::crRecvComposeEquipCreaterMethod(){}
crRecvComposeEquipCreaterMethod::crRecvComposeEquipCreaterMethod(const crRecvComposeEquipCreaterMethod& handle):
crMethod(handle)
{
}
void crRecvComposeEquipCreaterMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvComposeEquipCreaterMethod::addParam(int i, const std::string& str)
{
}
void crRecvComposeEquipCreaterMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		ref_ptr<crItemChild> itemchild;
		ref_ptr<crInstanceItem> item;

		itemchild = new crItemChild;
		itemchild->setItemChildID(m_stream->_readInt());
		readItem(item,m_stream.get(),false);
		itemchild->setInstanceItem(item.get());
		m_this->insertChildItem(itemchild.get());
		crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(itemchild.get(),m_this));
		//crGlobalHandle::getInstance()->doEvent(WCH_DownloadItemChild,MAKEINT64(NULL,NULL));//清理
	}
}
/////////////////////////////////////////
//
//crEquipOnItemNotifyMethod
//
/////////////////////////////////////////
crEquipOnItemNotifyMethod::crEquipOnItemNotifyMethod(){}
crEquipOnItemNotifyMethod::crEquipOnItemNotifyMethod(const crEquipOnItemNotifyMethod& handle):
crMethod(handle)
{
}
void crEquipOnItemNotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crEquipOnItemNotifyMethod::addParam(int i, const std::string& str)
{
}
void crEquipOnItemNotifyMethod::operator()(crHandle &handle)
{
	//std::string str = "网络未响应";
	//if(m_stream.valid())
	//{
	//	char returnCode = m_stream->_readChar();
	//	switch(returnCode)
	//	{
	//	case EC_Success:
	//	case EC_FoundComposeEquip:
	//	case EC_CreateComposeEquip:
	//		if(m_this)
	//		{
	//			crListControlNode *listNode = m_this->getSelectNode();
	//			if(listNode && listNode->getVisiable())
	//			{
	//				std::string title2 = listNode->getTitle2();
	//				int count = atoi(title2.c_str());
	//				if(count == 1)
	//				{//delete
	//					m_this->removeSelectListNode();
	//				}
	//				else
	//				{
	//					std::string newTitle2;
	//					int count = atoi(title2.c_str());
	//					count--;
	//					newTitle2 = crArgumentParser::appItoa(count);
	//					listNode->setTitle2(newTitle2);
	//				}
	//			}
	//		}
	//		return;
	//	case EC_DataTypeError:
	//		str = "DataType错误，不是装备类型";
	//		break;
	//	case EC_EquipOnMapFull:
	//		str = "装备栏已经满了";
	//		break;
	//	case EC_NotInBackPack:
	//		str = "该装备没有在BackPack里";
	//		break;
	//	case QC_Success:
	//		return;
	//	case QC_DataTypeError:
	//		str = "DataType错误，不是装备类型";
	//		break;
	//	case QC_QuickMapFull:
	//		str = "快捷栏已经满了";
	//		break;
	//	case QC_NotInBackPack:
	//		str = "该道具没有在BackPack里";
	//		break;
	//	case QC_NotInSkillMap:
	//		str = "该技能没有在SkillMap里";
	//		break;
	//	case QC_NotInAttackMap:
	//		str = "该攻击没有在AttackMap里";
	//		break;
	//	default:
	//		str = "装备失败";
	//		break;
	//	}
	//}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crBuildEquipOnListMethod
//
/////////////////////////////////////////
crBuildEquipOnListMethod::crBuildEquipOnListMethod(){}
crBuildEquipOnListMethod::crBuildEquipOnListMethod(const crBuildEquipOnListMethod& handle):
crMethod(handle)
{
}
void crBuildEquipOnListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildEquipOnListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_equiponList = str;
		break;
	}
}
void crBuildEquipOnListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		if(!crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			return;
		crListControlElement *equiponList = dynamic_cast<crListControlElement *>(imageStage->getElement(m_equiponList));
		if(equiponList)
		{
			equiponList->clear();
			equiponList->lockList();
			crListControlElement::ListNodeVec& listNodeVec = equiponList->getListNodeVec();
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap* equipOnMap = (EquipOnMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			for( EquipOnMap::iterator itr = equipOnMap->begin();
				itr != equipOnMap->end();
				++itr )
			{
				if(itr->second==0)
					continue;
				itemchild = m_this->findChildItem(itr->second);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;

					listNode = new crListNode;
					listNode->setData(item);
					listNode->addBitMapFile(iconfile);
					listNodeVec.push_back(listNode.get());
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			equiponList->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildEquipOnList2Method
//
/////////////////////////////////////////
crBuildEquipOnList2Method::crBuildEquipOnList2Method(){}
crBuildEquipOnList2Method::crBuildEquipOnList2Method(const crBuildEquipOnList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_equiponList(handle.m_equiponList)
{
}
void crBuildEquipOnList2Method::inputParam(int i, void *param)
{
}

void crBuildEquipOnList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_equiponList = str;
		break;
	}
}
void crBuildEquipOnList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode>equiponList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_equiponList));
		if(equiponList.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *thisData = me->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap* equipOnMap = (EquipOnMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			equiponList->setListNodeCount(equipOnMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = equiponList->getListNodeVec();
			int i = 0;
			for( EquipOnMap::iterator itr = equipOnMap->begin();
				itr != equipOnMap->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second==0)
					continue;
				itemchild = me->findChildItem(itr->second);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;

					listNodeVec[i]->setData(item);
					listNodeVec[i]->setImageName(iconfile);
					listNodeVec[i]->setVisiable(true);
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crUIBuildBackPackListMethod
//
/////////////////////////////////////////
crUIBuildBackPackListMethod::crUIBuildBackPackListMethod(){}
crUIBuildBackPackListMethod::crUIBuildBackPackListMethod(const crUIBuildBackPackListMethod& handle):
crMethod(handle)
{
}
void crUIBuildBackPackListMethod::inputParam(int i, void *param)
{
}
void crUIBuildBackPackListMethod::addParam(int i, const std::string& str)
{
}
void crUIBuildBackPackListMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	me->doEvent(WCH_BuildBackPackList,NULL);
}
/////////////////////////////////////////
//
//crUIBuildSkillListMethod
//
/////////////////////////////////////////
crUIBuildSkillListMethod::crUIBuildSkillListMethod(){}
crUIBuildSkillListMethod::crUIBuildSkillListMethod(const crUIBuildSkillListMethod& handle):
crMethod(handle)
{
}
void crUIBuildSkillListMethod::inputParam(int i, void *param)
{
}
void crUIBuildSkillListMethod::addParam(int i, const std::string& str)
{
}
void crUIBuildSkillListMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	me->doEvent(WCH_BuildSkillList,NULL);
} 
/////////////////////////////////////////
//
//crBuildQuickListMethod
//
/////////////////////////////////////////
crBuildQuickListMethod::crBuildQuickListMethod(){}
crBuildQuickListMethod::crBuildQuickListMethod(const crBuildQuickListMethod& handle):
crMethod(handle)
{
}
void crBuildQuickListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crBuildQuickListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_quickList = str;
		break;
	}
}
void crBuildQuickListMethod::operator()(crHandle &handle)
{
	crImageStage * imageStage = cr2DStageManager::getInstance()->findStage(m_stageName);
	if(imageStage && imageStage->getShow() && m_this)
	{
		if(!crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			return;
		crListControlElement *quickListControl = dynamic_cast<crListControlElement *>(imageStage->getElement(m_quickList));
		if(quickListControl)
		{
			quickListControl->clear();
			quickListControl->lockList();
			crListControlElement::ListNodeVec& listNodeVec = quickListControl->getListNodeVec();
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_QuickList,param);
			QuickList* quickList = (QuickList* )param;
			thisData->getParam(WCHDATA_QuickKeyVec,param);
			QuickKeyVec* quickKeyVec = (QuickKeyVec* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			unsigned char dataType,skilllevel;
			std::string title,title2;
			//std::vector<QuickList::iterator>EraseVec;
			for( QuickList::iterator itr = quickList->begin();
				itr != quickList->end();
				)
			{
				if(itr->second==0)
					continue;
				itemchild = m_this->findChildItem(itr->second);
				if(itemchild && itemchild->isLoaded())
				{
					title2.clear();
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					if(!itemData)
						continue;
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;
					itemData->getParam(WCHDATA_DataType,param);
					dataType = *(unsigned char *)param;
					if(dataType == DT_Skill || dataType == DT_Attack)
					{
                        itemData->getParam(WCHDATA_SkillLevel,param);
                        skilllevel = *(unsigned char *)param;
						title2 = CRCore::crArgumentParser::appItoa((int)skilllevel);
					}
					else
					{
						short count;
						m_this->doEvent(WCH_GetItemCountInBackPack,MAKEINT64(item,&count));
						title2 = CRCore::crArgumentParser::appItoa((int)count);
					}
					title.clear();
					for( QuickKeyVec::iterator qkItr = quickKeyVec->begin();
						 qkItr != quickKeyVec->end();
						 ++qkItr )
					{
						if(qkItr->second == item->getAbstractItemID())
						{
					        title = qkItr->first;
							break;
						}
					}
					listNode = new crListNode;
					listNode->setData(item);
					listNode->addBitMapFile(iconfile);
					listNode->setTitle(title);//快捷键
					listNode->setTitle2(title2);//等级或数量
					listNodeVec.push_back(listNode.get());
					++itr;
				}
				else
				{
					itr = quickList->erase(itr);
				}
			}
			//for( std::vector<QuickList::iterator>::iterator itr = EraseVec.begin();
			//	 itr != EraseVec.end();
			//	 ++itr )
			//{
   //             quickList->erase(*itr);
			//}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			quickListControl->unlockList();
			imageStage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crBuildQuickList2Method
//
/////////////////////////////////////////
crBuildQuickList2Method::crBuildQuickList2Method(){}
crBuildQuickList2Method::crBuildQuickList2Method(const crBuildQuickList2Method& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_quickList(handle.m_quickList)
{
}
void crBuildQuickList2Method::inputParam(int i, void *param)
{
}

void crBuildQuickList2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_quickList = str;
		break;
	}
}
void crBuildQuickList2Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode>quickListControl = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_quickList));
		if(quickListControl.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *thisData = me->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_QuickList,param);
			QuickList* quickList = (QuickList* )param;
			thisData->getParam(WCHDATA_QuickKeyVec,param);
			QuickKeyVec* quickKeyVec = (QuickKeyVec* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			unsigned char dataType,skilllevel;
			std::string title,title2;
			std::vector<QuickList::iterator>EraseVec;
			quickListControl->setListNodeCount(quickList->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = quickListControl->getListNodeVec();
			int i = 0;
			for( QuickList::iterator itr = quickList->begin();
				itr != quickList->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second==0)
					continue;
				itemchild = me->findChildItem(itr->second);
				if(itemchild && itemchild->isLoaded())
				{
					title2.clear();
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					if(!itemData)
						continue;
					itemData->getParam(WCHDATA_ItemIcon,param);
					iconfile = *(std::string *)param;
					itemData->getParam(WCHDATA_DataType,param);
					dataType = *(unsigned char *)param;
					if(dataType == DT_Skill || dataType == DT_Attack)
					{
						itemData->getParam(WCHDATA_SkillLevel,param);
						skilllevel = *(unsigned char *)param;
						title2 = CRCore::crArgumentParser::appItoa((int)skilllevel);
					}
					else
					{
						short count;
						me->doEvent(WCH_GetItemCountInBackPack,MAKEINT64(item,&count));
						title2 = CRCore::crArgumentParser::appItoa((int)count);
					}
					title.clear();
					for( QuickKeyVec::iterator qkItr = quickKeyVec->begin();
						qkItr != quickKeyVec->end();
						++qkItr )
					{
						if(qkItr->second == item->getAbstractItemID())
						{
							title = qkItr->first;
							break;
						}
					}
					listNodeVec[i]->setTitle(title);
					listNodeVec[i]->setTitle2(title2);
					listNodeVec[i]->setData(item);
					listNodeVec[i]->setImageName(iconfile);
					listNodeVec[i]->setVisiable(true);
				}
				else
				{
					EraseVec.push_back(itr);
				}
			}
			for( std::vector<QuickList::iterator>::iterator itr = EraseVec.begin();
				itr != EraseVec.end();
				++itr )
			{
				quickList->erase(*itr);
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crEquipValueMethod
//
/////////////////////////////////////////
crEquipValueMethod::crEquipValueMethod():
m_output(NULL){}
crEquipValueMethod::crEquipValueMethod(const crEquipValueMethod& handle):
crMethod(handle),
m_value(handle.m_value),
m_output(NULL)
{
}
void crEquipValueMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_bot = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_bot = (crInstanceItem *)(LOINT64(param64));
			m_output = (float *)(HIINT64(param64));
		}
		else
		{
			m_bot = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crEquipValueMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_value = atof(str.c_str());
		break;
	}
}
void crEquipValueMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		*m_output = m_value;
	}
}
/////////////////////////////////////////
//
//crUISetUseButtonTextMethod
//
/////////////////////////////////////////
crUISetUseButtonTextMethod::crUISetUseButtonTextMethod(){}
crUISetUseButtonTextMethod::crUISetUseButtonTextMethod(const crUISetUseButtonTextMethod& handle):
crMethod(handle),
m_useButtonText(handle.m_useButtonText),
m_thingText(handle.m_thingText),
m_equipText(handle.m_equipText)
{
}
void crUISetUseButtonTextMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_itemListElement = (CRGUI::crListControlElement*)param;
}

void crUISetUseButtonTextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_useButtonText = str;
		break;
	case 1:
		m_thingText = str;
		break;
	case 2:
		m_equipText = str;
		break;
	}
}

void crUISetUseButtonTextMethod::operator()(crHandle &handle)
{
	if(m_itemListElement.valid())
	{
		std::string str = m_thingText;
		crImageStage *stage = m_itemListElement->getParentStage();
		crStaticTextBoxElement *useButtonTextElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_useButtonText));
		crListNode *listNode = m_itemListElement->getSelectNode();
		if(listNode) 
		{
			crInstanceItem *item = (crInstanceItem *)(listNode->getData());
			if(item)
			{
				void *param;
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_DataType,param);
				unsigned char dataType = *(unsigned char *)param;
				if(dataType == DT_Thing || dataType == DT_AttackThing)
				{
					str = m_thingText;
				}
				else if(dataType == DT_Equip)
				{
                    str = m_equipText;
				}
			}
		}
        useButtonTextElement->setStringArrayByString(str);
	}
}
/////////////////////////////////////////
//
//crUIUnEquipItemMethod
//
/////////////////////////////////////////
crUIUnEquipItemMethod::crUIUnEquipItemMethod()
{
}
crUIUnEquipItemMethod::crUIUnEquipItemMethod(const crUIUnEquipItemMethod& handle):
crMethod(handle)
{
}
void crUIUnEquipItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_equipOnElement = (CRGUI::crListControlElement*)param;
}
void crUIUnEquipItemMethod::addParam(int i, const std::string& str)
{
}
void crUIUnEquipItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_equipOnElement.valid()) break;
		crListNode *listNode = m_equipOnElement->getSelectNode();
		if(!listNode) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		//检查是否有空间
		void *param;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		int abstractid = item->getAbstractItemID();
		int itemid = item->getInstanceItemID();
		myData->getParam(WCHDATA_EquipOnMap,param);
		EquipOnMap *equipOnMap = (EquipOnMap *)param;
		EquipOnMap::iterator itr = equipOnMap->find(abstractid);
		bool found = false;
		for( ; itr != equipOnMap->end() && itr->first == abstractid; ++itr )
		{
			if(itr->second == itemid)
			{
				found = true;
				break;
			}
		}
		if(!found)
		{
			//std::string str = "装备栏ID没有对应";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap *backPackMap = (BackPackMap *)param;
		myData->getParam(WCHDATA_MaxBackPack,param);
		unsigned char maxBackPack = *(unsigned char *)param;
		if((int)maxBackPack<=backPackMap->size())
		{//
			//std::string str = "您的背包已经满了";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(itemid);

		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvUnEquipItem,me,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIUnEquipItem2Method
//
/////////////////////////////////////////
crUIUnEquipItem2Method::crUIUnEquipItem2Method()
{
}
crUIUnEquipItem2Method::crUIUnEquipItem2Method(const crUIUnEquipItem2Method& handle):
crMethod(handle)
{
}
void crUIUnEquipItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUIUnEquipItem2Method::addParam(int i, const std::string& str)
{
}
void crUIUnEquipItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this) break;
		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode || !listNode->getVisiable()) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		//检查是否有空间
		void *param;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		int abstractid = item->getAbstractItemID();
		int itemid = item->getInstanceItemID();
		myData->getParam(WCHDATA_EquipOnMap,param);
		EquipOnMap *equipOnMap = (EquipOnMap *)param;
		EquipOnMap::iterator itr = equipOnMap->find(abstractid);
		bool found = false;
		for( ; itr != equipOnMap->end() && itr->first == abstractid; ++itr )
		{
			if(itr->second == itemid)
			{
				found = true;
				break;
			}
		}
		if(!found)
		{
			//std::string str = "装备栏ID没有对应";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->getParam(WCHDATA_BackPackMap,param);
		BackPackMap *backPackMap = (BackPackMap *)param;
		myData->getParam(WCHDATA_MaxBackPack,param);
		unsigned char maxBackPack = *(unsigned char *)param;
		if((int)maxBackPack<=backPackMap->size())
		{//
			//std::string str = "您的背包已经满了";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(itemid);

		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvUnEquipItem,me,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvUnEquipItemMethod
//
/////////////////////////////////////////
crRecvUnEquipItemMethod::crRecvUnEquipItemMethod():
m_netType(GameClient_Game){}
crRecvUnEquipItemMethod::crRecvUnEquipItemMethod(const crRecvUnEquipItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvUnEquipItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvUnEquipItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvUnEquipItemMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(13);
				int itemid = m_stream->_readInt();
				char returnCode = UC_Success;
				do
				{
					crItemChild *itemChild = m_this->findChildItem(itemid);
					if(!itemChild || !itemChild->isLoaded()) 
					{
						returnCode = UC_Error;
						break;
					}
					crInstanceItem *item = itemChild->getInstanceItem();
					int abstractid = item->getAbstractItemID();
					crData *thisData = m_this->getDataClass();
					void *param;
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_EquipOnMap,param);
					EquipOnMap *equipOnMap = (EquipOnMap *)param;
					EquipOnMap::iterator itr = equipOnMap->find(abstractid);
					bool found = false;
					for( ; itr != equipOnMap->end() && itr->first == abstractid; ++itr )
					{
						if(itr->second == itemid)
						{
							found = true;
							break;
						}
					}
					if(!found)
					{
						returnCode = UC_NotInEquip;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					thisData->getParam(WCHDATA_BackPackMap,param);
					BackPackMap *backPackMap = (BackPackMap *)param;
					thisData->getParam(WCHDATA_MaxBackPack,param);
					unsigned char maxBackPack = *(unsigned char *)param;
					if((int)maxBackPack<=backPackMap->size())
					{//
						returnCode = UC_BackpackIsFull;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					//插入到backpack
					char insertToBackPack = -1;
					m_this->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item,&insertToBackPack));
					if(insertToBackPack<0)
					{
						returnCode = UC_InsertBackpackError;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					//获得卸载装备之前的MAXHP
					float maxhp = 0;
					m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
					float maxmp = 0;
					m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
					equipOnMap->erase(itr);
					//获得卸载装备之前的MAXHP
					float maxhp2 = 0;
					m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp2,NULL));
					float maxmp2 = 0;
					m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp2,NULL));
					thisData->getParam(WCHDATA_RTHP,param);
					float* rthp = (float*)param;
					*rthp += maxhp2-maxhp;
					thisData->getParam(WCHDATA_RTMP,param);
					float* rtmp = (float*)param;
					*rtmp += maxmp2-maxmp;
					stream->_writeChar(returnCode);
					stream->_writeInt(itemid);
					stream->_writeFloat(*rthp);
					stream->_writeFloat(*rtmp);
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				} while (0);
				if(returnCode != UC_Success)
				{
					stream->_writeChar(returnCode);
				}
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvUnEquipItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if(returnCode == UC_Success)
				{
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
					crScene *scene = callback->findScene(m_this->getSceneID());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char returnCode = m_stream->_readChar();
			if(returnCode == UC_Success)
			{
				int itemid = m_stream->_readInt();
				crItemChild *itemChild = m_this->findChildItem(itemid);
				if(itemChild && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					int abstractid = item->getAbstractItemID();
					char insertToBackPack = -1;
					m_this->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item,&insertToBackPack));

					void *param;
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_EquipOnMap,param);
					EquipOnMap *equipOnMap = (EquipOnMap *)param;
					EquipOnMap::iterator itr = equipOnMap->find(abstractid);
					bool found = false;
					for( ; itr != equipOnMap->end() && itr->first == abstractid; ++itr )
					{
						if(itr->second == itemid)
						{
							found = true;
							break;
						}
					}
					if(found)
					{
						equipOnMap->erase(itr);
					}
					thisData->getParam(WCHDATA_RTHP,param);
					float* rthp = (float*)param;
					*rthp = m_stream->_readFloat();
					thisData->getParam(WCHDATA_RTMP,param);
					float* rtmp = (float*)param;
					*rtmp = m_stream->_readFloat();
					thisData->excHandle(MAKEINT64(WCH_LockData,0));

					m_this->doEvent(WCH_CheckAndRackEquipOnMesh,NULL);
					if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
					{
						m_this->doEvent(WCH_BuildEquipOnList,NULL);
						m_this->doEvent(WCH_BuildBackPackList,NULL);
					}
					else
					{
						return;
					}
				}
			}
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crUnEquipItemNotifyMethod
//
/////////////////////////////////////////
crUnEquipItemNotifyMethod::crUnEquipItemNotifyMethod(){}
crUnEquipItemNotifyMethod::crUnEquipItemNotifyMethod(const crUnEquipItemNotifyMethod& handle):
crMethod(handle)
{
}
void crUnEquipItemNotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crUnEquipItemNotifyMethod::addParam(int i, const std::string& str)
{
}
void crUnEquipItemNotifyMethod::operator()(crHandle &handle)
{
	std::string str = "网络未响应";
	if(m_stream.valid())
	{
		char returnCode = m_stream->_readChar();
		switch(returnCode)
		{
		case UC_Success:
			return;
		case UC_NotInEquip:
			str = "在装备栏里没有找到对应的装备";
			break;
		case UC_BackpackIsFull:
			str = "背包已经满了";
			break;
		case UC_InsertBackpackError:
			str = "放入背包失败";
			break;
		default:
			str = "装备失败";
			break;
		}
	}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crRecvEquipQuickMethod
//
/////////////////////////////////////////
crRecvEquipQuickMethod::crRecvEquipQuickMethod():
m_netType(GameClient_Game){}
crRecvEquipQuickMethod::crRecvEquipQuickMethod(const crRecvEquipQuickMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvEquipQuickMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvEquipQuickMethod::addParam(int i, const std::string& str)
{
}
void crRecvEquipQuickMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int itemid = m_stream->_readInt();
				char returnCode = QC_Success;
				do
				{
					ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
					if(!itemChild.valid() || !itemChild->isLoaded()) 
					{
						returnCode = QC_Error;
						break;
					}
					crInstanceItem *item = itemChild->getInstanceItem();
					//检查item是否可装备
					void *param;
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_DataType,param);
					unsigned char datatype = *((unsigned char*)param);
					if(datatype != DT_Thing && datatype != DT_Skill && datatype != DT_Attack && datatype != DT_AttackThing)
					{
						returnCode = EC_DataTypeError;
						break;
					}
					int abstractid = item->getAbstractItemID();
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_QuickList,param);
					QuickList *quickList = (QuickList *)param;
					thisData->getParam(WCHDATA_MaxQuick,param);
					unsigned char maxQuick = *(unsigned char *)param;
					if((int)maxQuick<=quickList->size())
					{//
						returnCode = QC_QuickMapFull;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					if(datatype == DT_Thing || datatype == DT_AttackThing)
					{
						thisData->getParam(WCHDATA_BackPackMap,param);
						BackPackMap *backPackMap = (BackPackMap *)param;
						BackPackMap::iterator itr = backPackMap->find(abstractid);
						bool found = false;
						for( ; itr != backPackMap->end() && itr->first == abstractid; ++itr)
						{
							if(itr->second == itemid)
							{
								found = true;
							}
						}
						if(!found)
						{
							returnCode = QC_NotInBackPack;
							thisData->excHandle(MAKEINT64(WCH_LockData,0));
							break;
						}
					}
					else if(datatype == DT_Skill)
					{
						thisData->getParam(WCHDATA_SkillMap,param);
						SkillMap *skillMap = (SkillMap *)param;
						if(skillMap->find(abstractid) == skillMap->end())
						{
							returnCode = QC_NotInSkillMap;
							thisData->excHandle(MAKEINT64(WCH_LockData,0));
							break;
						}
					}
					else if(datatype == DT_Attack)
					{
						thisData->getParam(WCHDATA_AttackMap,param);
						AttackMap *attackMap = (AttackMap *)param;
						if(attackMap->find(abstractid) == attackMap->end())
						{
							returnCode = QC_NotInAttackMap;
							thisData->excHandle(MAKEINT64(WCH_LockData,0));
							break;
						}
					}
					quickList->push_back(std::make_pair(abstractid,itemid));
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				} while (0);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeChar(returnCode);
				if(returnCode == QC_Success)
				{
					stream->_writeInt(itemid);
				}
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvEquipQuick,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if(returnCode == QC_Success)
				{
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
					crScene *scene = callback->findScene(m_this->getSceneID());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char returnCode = m_stream->_readChar();
			if(returnCode == QC_Success)
			{
				int itemid = m_stream->_readInt();
				ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
				if(itemChild.valid() && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					int abstractid = item->getAbstractItemID();

					void *param;
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_QuickList,param);
					QuickList *quickList = (QuickList *)param;
					quickList->push_back(std::make_pair(abstractid,itemid));
					thisData->excHandle(MAKEINT64(WCH_LockData,0));

					if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
						m_this->doEvent(WCH_BuildQuickList,NULL);
					else
						return;
				}
			}
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crUIUnEquipQuickMethod
//
/////////////////////////////////////////
crUIUnEquipQuickMethod::crUIUnEquipQuickMethod()
{
}
crUIUnEquipQuickMethod::crUIUnEquipQuickMethod(const crUIUnEquipQuickMethod& handle):
crMethod(handle)
{
}
void crUIUnEquipQuickMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_quickElement = (CRGUI::crListControlElement*)param;
}
void crUIUnEquipQuickMethod::addParam(int i, const std::string& str)
{
}
void crUIUnEquipQuickMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_quickElement.valid()) break;
		crListNode *listNode = m_quickElement->getSelectNode();
		if(!listNode) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		//检查是否有空间
		void *param;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		int abstractid = item->getAbstractItemID();
		int itemid = item->getInstanceItemID();
		myData->getParam(WCHDATA_QuickList,param);
		QuickList *quickList = (QuickList *)param;
		QuickList::iterator itr = quickList->begin();
		bool found = false;
		for( ; itr != quickList->end() && itr->first == abstractid; ++itr )
		{
			if(itr->second == itemid)
			{
				found = true;
				break;
			}
		}
		if(!found)
		{
			std::string str = "快捷栏ID没有对应";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(itemid);

		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvUnEquipQuick,me,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIUnEquipQuick2Method
//
/////////////////////////////////////////
crUIUnEquipQuick2Method::crUIUnEquipQuick2Method()
{
}
crUIUnEquipQuick2Method::crUIUnEquipQuick2Method(const crUIUnEquipQuick2Method& handle):
crMethod(handle)
{
}
void crUIUnEquipQuick2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUIUnEquipQuick2Method::addParam(int i, const std::string& str)
{
}
void crUIUnEquipQuick2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this) break;
		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode || !listNode->getVisiable()) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		//检查是否有空间
		void *param;
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myData = me->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		int abstractid = item->getAbstractItemID();
		int itemid = item->getInstanceItemID();
		myData->getParam(WCHDATA_QuickList,param);
		QuickList *quickList = (QuickList *)param;
		QuickList::iterator itr = quickList->begin();
		bool found = false;
		for( ; itr != quickList->end() && itr->first == abstractid; ++itr )
		{
			if(itr->second == itemid)
			{
				found = true;
				break;
			}
		}
		if(!found)
		{
			std::string str = "快捷栏ID没有对应";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
			myData->excHandle(MAKEINT64(WCH_LockData,0));
			break;
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(itemid);

		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvUnEquipQuick,me,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvUnEquipQuickMethod
//
/////////////////////////////////////////
crRecvUnEquipQuickMethod::crRecvUnEquipQuickMethod():
m_netType(GameClient_Game){}
crRecvUnEquipQuickMethod::crRecvUnEquipQuickMethod(const crRecvUnEquipQuickMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvUnEquipQuickMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvUnEquipQuickMethod::addParam(int i, const std::string& str)
{
}
void crRecvUnEquipQuickMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			int playerid = m_this->getID();
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int itemid = m_stream->_readInt();
				char returnCode = UQ_Success;
				do
				{
					crItemChild *itemChild = m_this->findChildItem(itemid);
					if(!itemChild || !itemChild->isLoaded()) 
					{
						returnCode = UQ_Error;
						break;
					}
					crInstanceItem *item = itemChild->getInstanceItem();
					int abstractid = item->getAbstractItemID();
					crData *thisData = m_this->getDataClass();
					void *param;
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_QuickList,param);
					QuickList *quickList = (QuickList *)param;
					QuickList::iterator itr = quickList->begin();
					bool found = false;
					for( ; itr != quickList->end() && itr->first == abstractid; ++itr )
					{
						if(itr->second == itemid)
						{
							found = true;
							break;
						}
					}
					if(!found)
					{
						returnCode = UQ_NotInQuick;
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					quickList->erase(itr);
					//QuickKeyVec
					thisData->getParam(WCHDATA_QuickKeyVec,param);
					QuickKeyVec *quickKeyVec = (QuickKeyVec *)param;
					for( QuickKeyVec::iterator itr = quickKeyVec->begin();
						itr != quickKeyVec->end(); ++itr )
					{
						if(itr->second == abstractid)
						{
							quickKeyVec->erase(itr);
							break;
						}
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				} while (0);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeChar(returnCode);
				if(returnCode == UQ_Success)
				{
					stream->_writeInt(itemid);
				}
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvUnEquipQuick,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if(returnCode == UQ_Success)
				{
					crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
					crScene *scene = callback->findScene(m_this->getSceneID());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char returnCode = m_stream->_readChar();
			if(returnCode == UQ_Success)
			{
				int itemid = m_stream->_readInt();
				crItemChild *itemChild = m_this->findChildItem(itemid);
				if(itemChild && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					int abstractid = item->getAbstractItemID();

					void *param;
					crData *thisData = m_this->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_QuickList,param);
					QuickList *quickList = (QuickList *)param;
					QuickList::iterator itr = quickList->begin();
					bool found = false;
					for( ; itr != quickList->end() && itr->first == abstractid; ++itr )
					{
						if(itr->second == itemid)
						{
							found = true;
							break;
						}
					}
					if(found)
					{
						quickList->erase(itr);
					}
					//QuickKeyVec
					thisData->getParam(WCHDATA_QuickKeyVec,param);
					QuickKeyVec *quickKeyVec = (QuickKeyVec *)param;
					for( QuickKeyVec::iterator itr = quickKeyVec->begin();
						itr != quickKeyVec->end(); ++itr )
					{
						if(itr->second == abstractid)
						{
							quickKeyVec->erase(itr);
							break;
						}
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
					if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
						m_this->doEvent(WCH_BuildQuickList,NULL);
					else
						return;
				}
			}
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				char *ptr2 = m_stream->getPtr();
				m_stream->seek(ptr - ptr2);
				crWaitNetReturnStreamLogic::netReturn(m_stream.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crUnEquipQuickNotifyMethod
//
/////////////////////////////////////////
crUnEquipQuickNotifyMethod::crUnEquipQuickNotifyMethod(){}
crUnEquipQuickNotifyMethod::crUnEquipQuickNotifyMethod(const crUnEquipQuickNotifyMethod& handle):
crMethod(handle)
{
}
void crUnEquipQuickNotifyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crUnEquipQuickNotifyMethod::addParam(int i, const std::string& str)
{
}
void crUnEquipQuickNotifyMethod::operator()(crHandle &handle)
{
	std::string str = "网络未响应";
	if(m_stream.valid())
	{
		char returnCode = m_stream->_readChar();
		switch(returnCode)
		{
		case UQ_Success:
			return;
		case UQ_NotInQuick:
			str = "在快捷栏里没有找到对应的装备";
			break;
		case UQ_BackpackIsFull:
			str = "背包已经满了";
			break;
		default:
			str = "装备失败";
			break;
		}
	}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crUISetQuickKeyMethod
//
/////////////////////////////////////////
crUISetQuickKeyMethod::crUISetQuickKeyMethod():
m_key(0)
{
}
crUISetQuickKeyMethod::crUISetQuickKeyMethod(const crUISetQuickKeyMethod& handle):
crMethod(handle),
m_key(0)
{
}
void crUISetQuickKeyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		m_quickElement = (CRGUI::crListControlElement*)param;
		break;
	case -4:
		m_key = *(wchar_t *)param;
		break;
	}
}
void crUISetQuickKeyMethod::addParam(int i, const std::string& str)
{
}
void crUISetQuickKeyMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_quickElement.valid()) break;
		crListNode *listNode = m_quickElement->getSelectNode();
		if(!listNode) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		if(m_key<'0'||m_key>'z') break;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(5);
		stream->_writeChar((char)m_key);
		stream->_writeInt(item->getAbstractItemID());
		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSetQuickKey,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUISetQuickKey2Method
//
/////////////////////////////////////////
crUISetQuickKey2Method::crUISetQuickKey2Method():
m_key(0)
{
}
crUISetQuickKey2Method::crUISetQuickKey2Method(const crUISetQuickKey2Method& handle):
crMethod(handle),
m_key(0)
{
}
void crUISetQuickKey2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_key = LOINT64(param64);
		}
		break;
	}
}
void crUISetQuickKey2Method::addParam(int i, const std::string& str)
{
}
void crUISetQuickKey2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	do 
	{
		if(!m_this) break;
		crListControlNode *listNode = m_this->getSelectNode();
		if(!listNode || !listNode->getVisiable()) break;
		crInstanceItem *item = (crInstanceItem*)(listNode->getData());
		if(!item) break;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!netConductor) break;
		if(m_key<'0'||m_key>'z') break;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(5);
		stream->_writeChar((char)m_key);
		stream->_writeInt(item->getAbstractItemID());
		crWaitNetReturnStreamLogic::getLock();
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvSetQuickKey,crMyPlayerData::getInstance()->getCurrentRole(),stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
		canceleTask = false;
	}
	while(0);
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crRecvSetQuickKeyMethod
//
/////////////////////////////////////////
crRecvSetQuickKeyMethod::crRecvSetQuickKeyMethod():
m_netType(GameClient_Game){}
crRecvSetQuickKeyMethod::crRecvSetQuickKeyMethod(const crRecvSetQuickKeyMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvSetQuickKeyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvSetQuickKeyMethod::addParam(int i, const std::string& str)
{
}
void crRecvSetQuickKeyMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_this->getID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				char key = m_stream->_readUChar();
				int abstractid = m_stream->_readInt();
				char returnCode = RC_Success;
				do
				{
					if(key<'0'||key>'z')
					{
						returnCode = RC_Error;
						break;
					}
					crData *thisData = m_this->getDataClass();
					void *param;
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_QuickKeyVec,param);
					QuickKeyVec *quickKeyVec = (QuickKeyVec *)param;
					bool found = false;
					for( QuickKeyVec::iterator itr = quickKeyVec->begin();
						 itr != quickKeyVec->end(); ++itr )
					{
						if(itr->second == abstractid)
						{
                            itr->first = key;
							found = true;
							break;
						}
					}
					if(!found)
					{
						quickKeyVec->push_back(std::make_pair(key,abstractid));
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				} while (0);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(6);
				stream->_writeChar(returnCode);
				if(returnCode == RC_Success)
				{
					stream->_writeInt(abstractid);
					stream->_writeChar(key);
				}
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvSetQuickKey,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			char returnCode = m_stream->_readChar();
			if(returnCode == RC_Success)
			{
				int abstractid = m_stream->_readInt();
				char key = m_stream->_readChar();
				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_QuickKeyVec,param);
				QuickKeyVec *quickKeyVec = (QuickKeyVec *)param;
				bool found = false;
				for( QuickKeyVec::iterator itr = quickKeyVec->begin();
					itr != quickKeyVec->end(); ++itr )
				{
					if(itr->second == abstractid)
					{
						itr->first = key;
						found = true;
						break;
					}
				}
				if(!found)
				{
					quickKeyVec->push_back(std::make_pair(key,abstractid));
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
				m_this->doEvent(WCH_BuildQuickList,NULL);
			}
			char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr - ptr2);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crUIShowItemInfoMethod
//
/////////////////////////////////////////
crUIShowItemInfoMethod::crUIShowItemInfoMethod():m_flg(1){}
crUIShowItemInfoMethod::crUIShowItemInfoMethod(const crUIShowItemInfoMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_itemIcon(handle.m_itemIcon),
m_infoText(handle.m_infoText),
m_flg(handle.m_flg)
{
}
void crUIShowItemInfoMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_itemListElement = (CRGUI::crListControlElement*)param;
}

void crUIShowItemInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_itemIcon = str;
		break;
	case 2:
		m_infoText = str;
		break;
	case 3:
		m_flg = (char)(atoi(str.c_str()));
		break;
	}
}

void crUIShowItemInfoMethod::operator()(crHandle &handle)
{
	if(m_itemListElement.valid())
	{
		crListNode *listNode = m_itemListElement->getSelectNode();
		if(listNode)
		{
			ref_ptr<crInstanceItem> item;
			if(m_flg == 0)
			{
				crVector3i *saleParam = (crVector3i *)(listNode->getData());
				if(saleParam)
				{
					crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
					ref_ptr<crInstanceItem> targetItem;
					ref_ptr<crMatrixTransform> targetNode;
					me->clientGetTarget(targetItem,targetNode);
					//me->doEvent(MAKEINT64(WCH_GetTarget,WCH_Client),MAKEINT64(&targetItem,&targetNode));
					if(targetItem.valid())
					{
						crItemChild *itemchild = targetItem->findChildItem((*saleParam)[0]);
						if(itemchild && itemchild->isLoaded())
						{
							item = itemchild->getInstanceItem();
						}
					}
				}
			}
			else if(m_flg == 1)
			{
				item = (crInstanceItem *)(listNode->getData());
			}
			if(item.valid())
			{
				crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
				if(stage)
				{
					crImageBoxElement *itemIconElement = dynamic_cast<crImageBoxElement *>(stage->getElement(m_itemIcon));
					crStaticTextBoxElement *infoTextElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_infoText));
                    crData *itemData = item->getDataClass();
					void *param;
					if(itemIconElement)
					{
						itemData->getParam(WCHDATA_ItemIcon,param);
						std::string iconFile = *(std::string *)param;
						itemIconElement->setImageFile(iconFile);
					}
                    if(infoTextElement)
					{
						std::vector<std::string> infoTextArray;
						item->doEvent(WCH_GetItemInfo,MAKEINT64(&infoTextArray,NULL));
                        infoTextElement->clearString();
						for( std::vector<std::string>::iterator itr = infoTextArray.begin();
							 itr != infoTextArray.end();
							 ++itr )
						{
                            infoTextElement->addString(*itr);
						}
					}
					stage->setNeedReDraw();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crItemInfoMethod
//
/////////////////////////////////////////
crItemInfoMethod::crItemInfoMethod():
m_output(NULL){}
crItemInfoMethod::crItemInfoMethod(const crItemInfoMethod& handle):
crMethod(handle),
m_infoArray(handle.m_infoArray),
m_output(NULL)
{
}
void crItemInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (std::vector<std::string> *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crItemInfoMethod::addParam(int i, const std::string& str)
{
	m_infoArray.push_back(str);
}
void crItemInfoMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		*m_output = m_infoArray;
	}
}
/////////////////////////////////////////
//
//crUIShowTaskInfoMethod
//
/////////////////////////////////////////
crUIShowTaskInfoMethod::crUIShowTaskInfoMethod(){}
crUIShowTaskInfoMethod::crUIShowTaskInfoMethod(const crUIShowTaskInfoMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_infoText(handle.m_infoText)
{
}
void crUIShowTaskInfoMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIShowTaskInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_infoText = str;
		break;
	}
}

void crUIShowTaskInfoMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crGameTask *curGameTask = crMyPlayerData::getInstance()->getCurrentGameTask();
		if(!curGameTask)
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			crData *myMetierData = me->getMetierDataClass();
			void *param;
			myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
			myMetierData->getParam(WCHDATA_GameTaskMap,param);
			GameTaskMap *gameTaskMap = (GameTaskMap *)param;
			if(!gameTaskMap||gameTaskMap->empty())
			{
				myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
				return;
			}
			for( GameTaskMap::iterator itr = gameTaskMap->begin();
				itr != gameTaskMap->end();
				++itr )
			{
				curGameTask = itr->second.get();
				if(!curGameTask->isComplete())
				{
					break;
				}
			}
			myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
            crMyPlayerData::getInstance()->setCurrentGameTask(curGameTask);
		}
		crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
		if(stage)
		{
			crStaticTextBoxElement *infoTextElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_infoText));
			if(infoTextElement)
			{
				infoTextElement->clearString();
				if(curGameTask)
				{
					std::string str = curGameTask->getTaskName();
					char strBuf[64];
					if(!curGameTask->getActivation())
						str += "(未接)";
					else if(!curGameTask->isComplete())
					{
						sprintf(strBuf,"(进度:%d/%d)\0",(int)(curGameTask->getTaskProgress()),(int)(curGameTask->getTaskSteps()));
						str += strBuf;
					}
					else
						str += "(已完成)";
                    infoTextElement->addString(str);
                    infoTextElement->addString(curGameTask->getHyperText());
					int exp = curGameTask->getExp();
					if(exp>0)
					{
						str = "经验奖励："+CRCore::crArgumentParser::appItoa(exp);
						infoTextElement->addString(str);
					}
					else if(exp<0)
					{
						str = "经验扣除："+CRCore::crArgumentParser::appItoa(exp);
						infoTextElement->addString(str);
					}
					int gold = curGameTask->getGold();
					if(gold>0)
					{
						str = "金币奖励："+CRCore::crArgumentParser::appItoa(gold);
						infoTextElement->addString(str);
					}
					else if(gold<0)
					{
						str = "金币扣除："+CRCore::crArgumentParser::appItoa(gold);
						infoTextElement->addString(str);
					}
                    //装备奖励
				}
				else
				{
					infoTextElement->addString("没有了");
				}
			}
			stage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crUIShowNextTaskInfoMethod
//
/////////////////////////////////////////
crUIShowNextTaskInfoMethod::crUIShowNextTaskInfoMethod():
m_nextOrPre(0){}
crUIShowNextTaskInfoMethod::crUIShowNextTaskInfoMethod(const crUIShowNextTaskInfoMethod& handle):
crMethod(handle),
m_infoText(handle.m_infoText),
m_nextOrPre(handle.m_nextOrPre)
{
}
void crUIShowNextTaskInfoMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIShowNextTaskInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_infoText = str;
		break;
	case 1:
		m_nextOrPre = atoi(str.c_str());
		break;
	}
}

void crUIShowNextTaskInfoMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crGameTask *curGameTask = crMyPlayerData::getInstance()->getCurrentGameTask();
		int taskid = 0;
		if(curGameTask)
		{
			taskid = curGameTask->getTaskID();
		}
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		crData *myMetierData = me->getMetierDataClass();
		void *param;
		myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
		myMetierData->getParam(WCHDATA_GameTaskMap,param);
		GameTaskMap *gameTaskMap = (GameTaskMap *)param;
		if(!gameTaskMap||gameTaskMap->empty())
		{
			myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
			return;
		}
		if(taskid == 0)
		{
            curGameTask = gameTaskMap->begin()->second.get();
		}
		else
		{
			GameTaskMap::iterator itr = gameTaskMap->find(taskid);
			if(itr == gameTaskMap->end())
				itr = gameTaskMap->begin();
            if(m_nextOrPre)
			{
				GameTaskMap::iterator itr2 = itr;
                itr2++;
				if(itr2 != gameTaskMap->end())
					itr = itr2;
				curGameTask = itr->second.get();
			}
			else if(itr != gameTaskMap->begin())
			{
				itr--;
				curGameTask = itr->second.get();
			}
		}
		myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
        if(curGameTask) crMyPlayerData::getInstance()->setCurrentGameTask(curGameTask);
		crImageStage *stage = m_element->getParentStage();
		if(stage)
		{
			crStaticTextBoxElement *infoTextElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_infoText));
			if(infoTextElement)
			{
				infoTextElement->clearString();
				if(curGameTask)
				{
					std::string str = curGameTask->getTaskName();
					char strBuf[64];
					if(!curGameTask->getActivation())
						str += "(未接)";
					else if(!curGameTask->isComplete())
					{
						sprintf(strBuf,"(进度:%d/%d)\0",(int)(curGameTask->getTaskProgress()),(int)(curGameTask->getTaskSteps()));
						str += strBuf;
					}
					else
						str += "(已完成)";
					infoTextElement->addString(str);
					infoTextElement->addString(curGameTask->getHyperText());
					int exp = curGameTask->getExp();
					if(exp>0)
					{
						str = "经验奖励："+CRCore::crArgumentParser::appItoa(exp);
						infoTextElement->addString(str);
					}
					else if(exp<0)
					{
						str = "经验扣除："+CRCore::crArgumentParser::appItoa(exp);
						infoTextElement->addString(str);
					}
					int gold = curGameTask->getGold();
					if(gold>0)
					{
						str = "金币奖励："+CRCore::crArgumentParser::appItoa(gold);
						infoTextElement->addString(str);
					}
					else if(gold<0)
					{
						str = "金币扣除："+CRCore::crArgumentParser::appItoa(gold);
						infoTextElement->addString(str);
					}
					//装备奖励
				}
				else
				{
					infoTextElement->addString("没有了");
				}
			}
			stage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crUIUseItemMethod
//
/////////////////////////////////////////
crUIUseItemMethod::crUIUseItemMethod(){}
crUIUseItemMethod::crUIUseItemMethod(const crUIUseItemMethod& handle):
crMethod(handle)
{
}
void crUIUseItemMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_itemListElement = (CRGUI::crListControlElement*)param;
}

void crUIUseItemMethod::addParam(int i, const std::string& str)
{
}

void crUIUseItemMethod::operator()(crHandle &handle)
{
	if(m_itemListElement.valid())
	{
		crListNode *listNode = m_itemListElement->getSelectNode();
		if(listNode)
		{
			ref_ptr<crInstanceItem> item = (crInstanceItem *)(listNode->getData());
			if(item.valid())
			{
				crData *itemData = item->getDataClass();
				void *param;
				itemData->getParam(WCHDATA_DataType,param);
				unsigned char dataType = *(unsigned char *)param;
				crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
				crData *thisData = role->getDataClass();
				int itemid = item->getInstanceItemID();
				if(dataType == DT_Thing || dataType == DT_AttackThing)
				{
                    role->doEvent(WCH_NetUseThing,MAKEINT64(item.get(),NULL));
				}
				else if(dataType == DT_Skill)
				{
					//roleData->inputParam(WCHDATA_AboutToUseItemID,&itemid);
					//crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
					//bindview->showCursor("UseSkill");
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_AboutToUseItemID,param);
					int *id = (int *)param;
					if(*id != itemid)
					{
						*id = itemid;
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(*id);

						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,role,WCH_RecvAboutToUseItemID,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				else if(dataType == DT_Attack)
				{
					thisData->inputParam(WCHDATA_CurrentAttackID,&itemid);
					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_AboutToUseItemID,param);
					int *id = (int *)param;
					if(*id != 0)
					{
						*id = 0;
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(*id);

						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,role,WCH_RecvAboutToUseItemID,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crUIUseItem2Method
//
/////////////////////////////////////////
crUIUseItem2Method::crUIUseItem2Method(){}
crUIUseItem2Method::crUIUseItem2Method(const crUIUseItem2Method& handle):
crMethod(handle)
{
}
void crUIUseItem2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}

void crUIUseItem2Method::addParam(int i, const std::string& str)
{
}

void crUIUseItem2Method::operator()(crHandle &handle)
{
	bool canceleTask = true;
	if(m_this)
	{
		crListControlNode *selectNode = m_this->getSelectNode();
		if(selectNode)
		{
			ref_ptr<crInstanceItem> item = (crInstanceItem *)(selectNode->getData());
			if(item.valid())
			{
				crData *itemData = item->getDataClass();
				void *param;
				itemData->getParam(WCHDATA_DataType,param);
				unsigned char dataType = *(unsigned char *)param;
				crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
				crData *roleData = role->getDataClass();
				int itemid = item->getInstanceItemID();
				if(dataType == DT_Thing || dataType == DT_AttackThing)
				{
					role->doEvent(WCH_NetUseThing,MAKEINT64(item.get(),NULL));
				}
				else if(dataType == DT_Skill)
				{
					//roleData->inputParam(WCHDATA_AboutToUseItemID,&itemid);
					//crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
					//bindview->showCursor("UseSkill");
					roleData->excHandle(MAKEINT64(WCH_LockData,1));
					roleData->getParam(WCHDATA_AboutToUseItemID,param);
					int *id = (int *)param;
					if(*id != itemid)
					{
						*id = itemid;
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(*id);

						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,role,WCH_RecvAboutToUseItemID,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
					roleData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				else if(dataType == DT_Attack)
				{
					roleData->inputParam(WCHDATA_CurrentAttackID,&itemid);
					roleData->excHandle(MAKEINT64(WCH_LockData,1));
					roleData->getParam(WCHDATA_AboutToUseItemID,param);
					int *id = (int *)param;
					if(*id != 0)
					{
						*id = 0;
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(*id);

						crPlayerEventPacket packet;
						crPlayerEventPacket::buildRequestPacket(packet,role,WCH_RecvAboutToUseItemID,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
					roleData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				else if(dataType == DT_Equip)
				{//检查是否有空间
					roleData->excHandle(MAKEINT64(WCH_LockData,1));
					roleData->getParam(WCHDATA_EquipOnMap,param);
					EquipOnMap *equipOnMap = (EquipOnMap *)param;
					roleData->getParam(WCHDATA_MaxEquipon,param);
					unsigned char maxEquipOn = *(unsigned char *)param;
					if((int)maxEquipOn<=equipOnMap->size())
					{//
						std::string str = "您的装备栏已经满了";
						//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
						roleData->excHandle(MAKEINT64(WCH_LockData,0));
					}
					else
					{
						roleData->excHandle(MAKEINT64(WCH_LockData,0));
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						if(netConductor)
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(4);
							stream->_writeInt(itemid);

							crWaitNetReturnStreamLogic::getLock();
							crPlayerServerEventPacket packet;
							crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvEquipOnItem,role,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
							canceleTask = false;
						}
					}
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crNetUseThingMethod
//
/////////////////////////////////////////
crNetUseThingMethod::crNetUseThingMethod()
{
}
crNetUseThingMethod::crNetUseThingMethod(const crNetUseThingMethod& handle):
crMethod(handle)
{
}
void crNetUseThingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_item = NULL;
		}
		break;
	}
}
void crNetUseThingMethod::addParam(int i, const std::string& str)
{
}
void crNetUseThingMethod::operator()(crHandle &handle)
{
	if(m_this && m_item.valid())
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_RTHP,param);
		float rthp = *(float *)param;
		if(rthp<=0)
		{
			return;
		}
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(m_item->getInstanceItemID());
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{//client to server
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvNetUseThing,m_this,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvNetUseThingMethod
//
/////////////////////////////////////////
crRecvNetUseThingMethod::crRecvNetUseThingMethod(){}
crRecvNetUseThingMethod::crRecvNetUseThingMethod(const crRecvNetUseThingMethod& handle):
crMethod(handle)
{
}
void crRecvNetUseThingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvNetUseThingMethod::addParam(int i, const std::string& str)
{
}
void crRecvNetUseThingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			int playerid = m_this->getID();
			int roleid = m_this->getRoleID();
			crRole *role = NULL;
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
			    int itemid = m_stream->_readInt();
				char returnCode = RC_Success;
				do
				{
					void *param;
					role = playerData->getRole(roleid);
					crData *roleData = role->getDataClass();
					roleData->getParam(WCHDATA_RTHP,param);
					float rthp = *(float *)param;
					if(rthp<=0)
					{
						returnCode = RC_Error;
						break;
					}
					ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
					if(!itemChild.valid() || !itemChild->isLoaded())
					{
						returnCode = RC_Error;
						break;
					}
					crInstanceItem *item = itemChild->getInstanceItem();
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_DataType,param);
					unsigned char dataType = *(unsigned char *)param;
					if(dataType == DT_AttackThing)
					{
						roleData->excHandle(MAKEINT64(WCH_LockData,1));
						roleData->getParam(WCHDATA_AboutToUseItemID,param);
						int *id = (int *)param;
						if(*id != itemid)
						{
							*id = itemid;
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(4);
							stream->_writeInt(*id);
							crPlayerEventPacket packet;
							crPlayerEventPacket::buildRequestPacket(packet,playerid,role,WCH_RecvAboutToUseItemID,stream.get());
							//netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
							crScene *scene = callback->findScene(m_this->getSceneID());
							scene->sendPacketToItemNeighbor(m_this,packet);
						}
						roleData->excHandle(MAKEINT64(WCH_LockData,0));
					}
					else if(dataType == DT_Thing)
					{
						int abstractid = item->getAbstractItemID();
						int itemid = item->getInstanceItemID();
						char removeItem = -1;
						role->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
						if(removeItem<0)
						{
							returnCode = RC_Error;
							break;
						}
						item->doEvent(MAKEINT64(WCH_ThingUse,UT_Server),MAKEINT64(role,NULL));
					}
					else
					{
						returnCode = RC_Error;
						break;
					}
				} while (0);
				if(role)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(5);
					stream->_writeChar(returnCode);
					if(returnCode == RC_Success)
						stream->_writeInt(itemid);
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,playerid,role,WCH_RecvNetUseThing,stream.get());
					netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readBool();
			if(returnCode == RC_Success)
			{
				int itemid = m_stream->_readInt();
				ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
				if(itemChild.valid() && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					void *param;
					crData *itemData = item->getDataClass();
					itemData->getParam(WCHDATA_DataType,param);
					unsigned char dataType = *(unsigned char *)param;
					if(dataType == DT_Thing)
					{
						item->doEvent(MAKEINT64(WCH_ThingUse,UT_Client),MAKEINT64(m_this,NULL));
						char removeItem = -1;
						m_this->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
						m_this->doEvent(WCH_BuildBackPackList,NULL);
						m_this->doEvent(WCH_BuildQuickList,NULL);
					}
					else if(dataType == DT_AttackThing)
					{
						crData *roleData = m_this->getDataClass();
						roleData->inputParam(WCHDATA_AboutToUseItemID,&itemid);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crUTCureHPMethod
//
/////////////////////////////////////////
crUTCureHPMethod::crUTCureHPMethod(){}
crUTCureHPMethod::crUTCureHPMethod(const crUTCureHPMethod& handle):
crMethod(handle),
m_curehp(handle.m_curehp)
{
}
void crUTCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_user = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_user = NULL;
		}
		break;
	}
}
void crUTCureHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curehp = (short)(atoi(str.c_str()));
		break;
	}
}
void crUTCureHPMethod::operator()(crHandle &handle)
{
	if(m_this && m_user.valid())
	{
		void *param;
		crData *userData = m_user->getDataClass();
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		userData->getParam(WCHDATA_RTHP,param);
		float* rthp = (float *)param;
		short curehp = *rthp;
		*rthp+=m_curehp;
		float maxhp = 0;
		m_user->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		if(*rthp>maxhp)
			*rthp = maxhp;
		curehp = (short)(*rthp) - curehp;
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//send
		//将信息传给m_this以及其附近玩家
		unsigned char usertype = m_user->getItemtype();
		int userid = m_user->getID();

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(6);
		stream->_writeShort(curehp);
		stream->_writeFloat(*rthp);
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_user->getSceneID());
		if(usertype == crInstanceItem::Role)
		{
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,userid,m_user.get(),WCH_RecvCureHP,stream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(userid));
			if(hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
			}
			scene->sendPacketToItemNeighbor(m_user.get(),packet);
		}
		else
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_user.get(),WCH_RecvCureHP,stream.get());
			scene->sendPacketToItemNeighbor(m_user.get(),packet);
		}
	}
}
/////////////////////////////////////////
//
//crUTCureMPMethod
//
/////////////////////////////////////////
crUTCureMPMethod::crUTCureMPMethod(){}
crUTCureMPMethod::crUTCureMPMethod(const crUTCureMPMethod& handle):
crMethod(handle),
m_curemp(handle.m_curemp)
{
}
void crUTCureMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_user = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_user = NULL;
		}
		break;
	}
}
void crUTCureMPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curemp = (short)(atoi(str.c_str()));
		break;
	}
}
void crUTCureMPMethod::operator()(crHandle &handle)
{
	if(m_this && m_user.valid())
	{
		void *param;
		crData *userData = m_user->getDataClass();
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		userData->getParam(WCHDATA_RTMP,param);
		float* rtmp = (float *)param;
		short curemp = *rtmp;
		*rtmp+=m_curemp;
		float maxmp = 0;
		m_user->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
		if(*rtmp>maxmp)
			*rtmp = maxmp;
		curemp = (short)(*rtmp) - curemp;
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//将信息传给m_this以及其附近玩家
		unsigned char hittype = m_user->getItemtype();
		int hitid = m_user->getID();

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(6);
		stream->_writeShort(curemp);
		stream->_writeFloat(*rtmp);
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_user->getSceneID());
		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,hitid,m_user.get(),WCH_RecvCureMP,stream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if(hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
			}
			scene->sendPacketToItemNeighbor(m_user.get(),packet);
		}
		else
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_user.get(),WCH_RecvCureMP,stream.get());
			scene->sendPacketToItemNeighbor(m_user.get(),packet);
		}
	}
}
///////////////////////////////////////////
////
////crUTClientCureHPMethod
////
///////////////////////////////////////////
//crUTClientCureHPMethod::crUTClientCureHPMethod(){}
//crUTClientCureHPMethod::crUTClientCureHPMethod(const crUTClientCureHPMethod& handle):
//crMethod(handle),
//m_hp(handle.m_hp)
//{
//}
//void crUTClientCureHPMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_user = (crInstanceItem *)(LOINT64(param64));
//		}
//		else
//		{
//			m_user = NULL;
//		}
//		break;
//	}
//}
//void crUTClientCureHPMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_hp = (short)(atoi(str.c_str()));
//		break;
//	}
//}
//void crUTClientCureHPMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_user.valid())
//	{
//		void *param;
//		crData *userData = m_user->getDataClass();
//		userData->excHandle(MAKEINT64(WCH_LockData,1));
//		userData->getParam(WCHDATA_RTHP,param);
//		float* rthp = (float *)param;
//		short hp = *rthp;
//		*rthp+=m_hp;
//		float maxhp = 0;
//		m_user->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
//		if(*rthp>maxhp)
//			*rthp = maxhp;
//		hp = (short)(*rthp) - hp;
//		userData->excHandle(MAKEINT64(WCH_LockData,0));
//
//		crNode *node;
//		if(m_user->getItemtype() == crInstanceItem::instanceitem)
//		{
//			node = m_user->getNode();
//		}
//		else
//		{
//			node = (dynamic_cast<crGroup *>(m_user->getNode()))->getChild(0);
//		}
//		node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_CureHP,MAKEINT32(hp,-1)));
//	}
//}
///////////////////////////////////////////
////
////crUTClientCureMPMethod
////
///////////////////////////////////////////
//crUTClientCureMPMethod::crUTClientCureMPMethod(){}
//crUTClientCureMPMethod::crUTClientCureMPMethod(const crUTClientCureMPMethod& handle):
//crMethod(handle),
//m_mp(handle.m_mp)
//{
//}
//void crUTClientCureMPMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_user = (crInstanceItem *)(LOINT64(param64));
//		}
//		else
//		{
//			m_user = NULL;
//		}
//		break;
//	}
//}
//void crUTClientCureMPMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_mp = (short)(atoi(str.c_str()));
//		break;
//	}
//}
//void crUTClientCureMPMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_user.valid())
//	{
//		void *param;
//		crData *userData = m_user->getDataClass();
//		userData->excHandle(MAKEINT64(WCH_LockData,1));
//		userData->getParam(WCHDATA_RTMP,param);
//		float* rtmp = (float *)param;
//		short mp = *rtmp;
//		*rtmp+=m_mp;
//		float maxmp = 0;
//		m_user->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
//		if(*rtmp>maxmp)
//			*rtmp = maxmp;
//		mp = (short)(*rtmp) - mp;
//		userData->excHandle(MAKEINT64(WCH_LockData,0));
//
//		crNode *node;
//		if(m_user->getItemtype() == crInstanceItem::instanceitem)
//		{
//			node = m_user->getNode();
//		}
//		else
//		{
//			node = (dynamic_cast<crGroup *>(m_user->getNode()))->getChild(0);
//		}
//		node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_CureMP,MAKEINT32(mp,-1)));
//	}
//}
/////////////////////////////////////////
//
//crCancelUseSkillMethod
//
/////////////////////////////////////////
crCancelUseSkillMethod::crCancelUseSkillMethod()
{
}

crCancelUseSkillMethod::crCancelUseSkillMethod(const crCancelUseSkillMethod& handle):
crMethod(handle)
{
}

void crCancelUseSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}

void crCancelUseSkillMethod::addParam(int i, const std::string& str)
{
}

void crCancelUseSkillMethod::operator()(crHandle &handle)
{
	if(!m_this) return;

	crData *thisData = m_this->getDataClass();
	thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);
	//if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	//{
	//	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	//	bindview->showCursor("Default");
	//}
}
/////////////////////////////////////////
//
//crShowTargetInfoMethod
//
/////////////////////////////////////////
crShowTargetInfoMethod::crShowTargetInfoMethod(){}
crShowTargetInfoMethod::crShowTargetInfoMethod(const crShowTargetInfoMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName)
{
}
void crShowTargetInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_targetItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetItem = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_targetItem = NULL;
		}
		break;
	}
}

void crShowTargetInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	}
}

void crShowTargetInfoMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_targetItem.valid())
		{
			crFilterRenderManager::getInstance()->showCanvas(m_stageName,true);
		    //cr2DStageManager::getInstance()->showStage(m_stageName,true);
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(m_stageName,false);
			//cr2DStageManager::getInstance()->showStage(m_stageName,false);
		}
	}
}
/////////////////////////////////////////
//
//crUIUpdateTargetMethod
//
/////////////////////////////////////////
crUIUpdateTargetMethod::crUIUpdateTargetMethod(){}
crUIUpdateTargetMethod::crUIUpdateTargetMethod(const crUIUpdateTargetMethod& handle):
crMethod(handle),
m_itemIcon(handle.m_itemIcon),
m_name(handle.m_name),
m_lv(handle.m_lv),
m_hp(handle.m_hp),
m_addGroup(handle.m_addGroup),
m_addFriend(handle.m_addFriend),
m_chatWithFriend(handle.m_chatWithFriend)
{
}
void crUIUpdateTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		m_this = (crImageStage*)(param);
		break;
	}
}
void crUIUpdateTargetMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemIcon = str;
		break;
	case 1:
		m_name = str;
		break;
	case 2:
		m_lv = str;
		break;
	case 3:
		m_hp = str;
		break;
	case 4:
		m_addGroup = str;
		break;
	case 5:
		m_addFriend = str;
		break;
	case 6:
		m_chatWithFriend = str;
		break;
	}
}
void crUIUpdateTargetMethod::operator()(crHandle &handle)
{
	if(m_this && !m_this->isHide())
	{
		crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
		if(!role) return;
		void *param;
		crData *roleData = role->getDataClass();
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		role->clientGetTarget(targetItem,targetNode);
		//role->doEvent(MAKEINT64(WCH_GetTarget,WCH_Client),MAKEINT64(&targetItem,&targetNode));
		if(targetItem.valid())
		{
			crImageBoxElement *itemIconElement = dynamic_cast<crImageBoxElement *>(m_this->getElement(m_itemIcon));
			crStaticTextBoxElement *nameElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_name));
			crStaticTextBoxElement *lvElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_lv));
			crStaticTextBoxElement *hpElement = dynamic_cast<crStaticTextBoxElement *>(m_this->getElement(m_hp));
			crButtonElement *addGroupElement = dynamic_cast<crButtonElement *>(m_this->getElement(m_addGroup));
			crButtonElement *addFriendElement = dynamic_cast<crButtonElement *>(m_this->getElement(m_addFriend));
			crButtonElement *chatWithFriendElement = dynamic_cast<crButtonElement *>(m_this->getElement(m_chatWithFriend));
			bool needReDraw = false;
			std::string str,oldstr;

			crData *itemData = targetItem->getDataClass();
			if(itemIconElement)
			{
				itemData->getParam(WCHDATA_ItemIcon,param);
				std::string iconFile = *(std::string *)param;
				needReDraw = itemIconElement->setImageFile(iconFile);
			}
			if(nameElement)
			{
				str = targetItem->getIName();
				oldstr = nameElement->getStringArrayInString();
				if(str.compare(oldstr)!=0)
				{
					nameElement->setStringArrayByString(str);
					needReDraw = true;
				}
			}
			if(lvElement)
			{
				itemData->getParam(WCHDATA_Level,param);
				unsigned char* lv = (unsigned char*)param;
				if(lv)
				{
					str = crArgumentParser::appItoa((int)(*lv));
					oldstr = lvElement->getStringArrayInString();
					if(str.compare(oldstr)!=0)
					{
						lvElement->setStringArrayByString(str);
						needReDraw = true;
					}
				}
				else
				{
					lvElement->clearString();
				}
			}
			if(hpElement)
			{
				if(targetItem->getItemtype()>crInstanceItem::instanceitem)
				{
					float maxhp = 0;
					targetItem->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
					itemData->getParam(WCHDATA_RTHP,param);
					float* rthp = (float*)param;
					if(rthp)
					{
						str = crArgumentParser::appItoa(*rthp) + "/" + crArgumentParser::appItoa(maxhp);
						oldstr = hpElement->getStringArrayInString();
						if(str.compare(oldstr)!=0)
						{
							hpElement->setStringArrayByString(str);
							needReDraw = true;
						}
					}
					else
					{
						hpElement->clearString();
					}
				}
				else
				{
					hpElement->clearString();
				}
			}

			bool addGroup = false;
			bool addFriend = false;
			bool chatWithFriend = false;
			int playerid = targetItem->getID();
			if(targetItem->getItemtype() == crInstanceItem::Role && playerid != role->getPlayerID())
			{//检查是否是朋友
				crData *roleData = role->getDataClass();
				roleData->getParam(WCHDATA_GroupMemberSet,param);
				GroupMemberSet groupMemberSet = *(GroupMemberSet *)param;
				if(groupMemberSet.empty()||(groupMemberSet.size() < crGlobalHandle::gData()->gMaxgroupmember() && groupMemberSet.find(targetItem->getID()) == groupMemberSet.end()))
				{//可以加入组队
					addGroup = true;
				}
				//
				crNetChatData *myChatData = crMyPlayerData::getInstance()->getMyChatData();
				if(myChatData)
				{//可以加为好友
					if(!myChatData->isFriend(targetItem->getID()))
					{
						addFriend = true;
					}
					else
					{
						chatWithFriend = true;
					}
				}
			}
			if(addGroupElement)
			{
				if(addGroup != addGroupElement->getShow())
				{
					needReDraw = true;
				}
				addGroupElement->setShow(addGroup);
				addGroupElement->setEnable(addGroup);
			}
			if(addFriendElement)
			{
				if(addFriend != addFriendElement->getShow())
				{
					needReDraw = true;
				}
				addFriendElement->setShow(addFriend);
				addFriendElement->setEnable(addFriend);
			}
			if(chatWithFriendElement)
			{
				if(chatWithFriend != addFriendElement->getShow())
				{
					needReDraw = true;
				}
				chatWithFriendElement->setShow(chatWithFriend);
				chatWithFriendElement->setEnable(chatWithFriend);
			}
			if(needReDraw) m_this->setNeedReDraw();
		}
		else
		{
			cr2DStageManager::getInstance()->close(m_this);
		}
	}
}
/////////////////////////////////////////
//
//crCureHPCollideMethod
//
/////////////////////////////////////////
crCureHPCollideMethod::crCureHPCollideMethod():
m_lvfactor(0.0f){}
crCureHPCollideMethod::crCureHPCollideMethod(const crCureHPCollideMethod& handle):
crMethod(handle),
m_lvfactor(handle.m_lvfactor)
{
}
void crCureHPCollideMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitItem = NULL;
			m_fireItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitItem = (crInstanceItem *)(LOINT64(param64));
			m_fireItem = (crInstanceItem *)(HIINT64(param64));
		}
		else
		{
			m_hitItem = NULL;
			m_fireItem = NULL;
		}
		break;
	}
}
void crCureHPCollideMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_lvfactor = atof(str.c_str());
		break;
	}
}
void crCureHPCollideMethod::operator()(crHandle &handle)
{
	if(m_this && m_hitItem.valid())
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SkillLevel,param);
		unsigned char skilllevel = *((unsigned char*)param);

		data->getParam(WCHDATA_PhysicsDM,param);
		crVector2s curehp;
		if(param) curehp = *((crVector2s*)param);

		CRCore::rangef curehpR(curehp[0],curehp[1]);
		float curehpF = curehpR.get_random();
		curehpF += (float)skilllevel * m_lvfactor;

		m_hitItem->doEvent(WCH_CureHP,MAKEINT64(&curehpF,m_fireItem.get()));
	}
}
/////////////////////////////////////////
//
//crCureMPCollideMethod
//
/////////////////////////////////////////
crCureMPCollideMethod::crCureMPCollideMethod():
m_lvfactor(0.0f){}
crCureMPCollideMethod::crCureMPCollideMethod(const crCureMPCollideMethod& handle):
crMethod(handle),
m_lvfactor(handle.m_lvfactor)
{
}
void crCureMPCollideMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitItem = NULL;
			m_fireItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitItem = (crInstanceItem *)(LOINT64(param64));
			m_fireItem = (crInstanceItem *)(HIINT64(param64));
		}
		else
		{
			m_hitItem = NULL;
			m_fireItem = NULL;
		}
		break;
	}
}
void crCureMPCollideMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_lvfactor = atof(str.c_str());
		break;
	}
}
void crCureMPCollideMethod::operator()(crHandle &handle)
{
	if(m_this && m_hitItem.valid())
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SkillLevel,param);
		unsigned char skilllevel = *((unsigned char*)param);

		data->getParam(WCHDATA_MagicDM,param);
		crVector2s curemp;
		if(param) curemp = *((crVector2s*)param);

		CRCore::rangef curempR(curemp[0],curemp[1]);
		float curempF = curempR.get_random();
		curempF += (float)skilllevel * m_lvfactor;

		m_hitItem->doEvent(WCH_CureMP,MAKEINT64(&curempF,m_fireItem.get()));
	}
}
/////////////////////////////////////////
//
//crCureHPMethod
//
/////////////////////////////////////////
crCureHPMethod::crCureHPMethod():
m_curehp(0.0f){}
crCureHPMethod::crCureHPMethod(const crCureHPMethod& handle):
crMethod(handle),
m_curehp(0.0f)
{
}
void crCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_fireItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_curehp = *(float *)(LOINT64(param64));
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_curehp = 0;
			m_fireItem = NULL;
		}
		break;
	}
}
void crCureHPMethod::addParam(int i, const std::string& str)
{
}
void crCureHPMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *userData = m_this->getDataClass();
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		userData->getParam(WCHDATA_RTHP,param);
		float* rthp = (float *)param;
		short curehp = *rthp;
		*rthp+=m_curehp;
		float maxhp = 0;
		m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		if(*rthp>maxhp)
			*rthp = maxhp;
		curehp = (short)(*rthp) - curehp;
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//将信息传给m_this以及其附近玩家
		unsigned char hittype = m_this->getItemtype();
		int hitid = m_this->getID();

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(6);
		stream->_writeShort(curehp);
		stream->_writeFloat(*rthp);
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,hitid,m_this,WCH_RecvCureHP,stream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if(hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
			}
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
		else
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvCureHP,stream.get());
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvCureHPMethod
//
/////////////////////////////////////////
crRecvCureHPMethod::crRecvCureHPMethod(){}
crRecvCureHPMethod::crRecvCureHPMethod(const crRecvCureHPMethod& handle):
crMethod(handle)
{
}
void crRecvCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvCureHPMethod::addParam(int i, const std::string& str)
{
}
void crRecvCureHPMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		short curehp = m_stream->_readShort();
		float rthp = m_stream->_readFloat();
		data->inputParam(WCHDATA_RTHP,&rthp);
		//客户端显示
		crNode *node = m_this->getRelNode();
		if(node)
		    node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_CureHP,MAKEINT32(curehp,-1)));
	}
}
/////////////////////////////////////////
//
//crCureMPMethod
//
/////////////////////////////////////////
crCureMPMethod::crCureMPMethod():
m_curemp(0.0f){}
crCureMPMethod::crCureMPMethod(const crCureMPMethod& handle):
crMethod(handle),
m_curemp(0.0f)
{
}
void crCureMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_fireItem = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_curemp = *(float *)(LOINT64(param64));
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_curemp = 0;
			m_fireItem = NULL;
		}
		break;
	}
}
void crCureMPMethod::addParam(int i, const std::string& str)
{
}
void crCureMPMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *userData = m_this->getDataClass();
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		userData->getParam(WCHDATA_RTMP,param);
		float* rtmp = (float *)param;
		short curemp = *rtmp;
		*rtmp+=m_curemp;
		float maxmp = 0;
		m_this->doEvent(MAKEINT64(WCH_GetMP,NULL),MAKEINT64(&maxmp,NULL));
		if(*rtmp>maxmp)
			*rtmp = maxmp;
		curemp = (short)(*rtmp) - curemp;
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//将信息传给m_this以及其附近玩家
		unsigned char hittype = m_this->getItemtype();
		int hitid = m_this->getID();

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(6);
		stream->_writeShort(curemp);
		stream->_writeFloat(*rtmp);
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,hitid,m_this,WCH_RecvCureMP,stream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if(hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
			}
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
		else
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvCureMP,stream.get());
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvCureMPMethod
//
/////////////////////////////////////////
crRecvCureMPMethod::crRecvCureMPMethod(){}
crRecvCureMPMethod::crRecvCureMPMethod(const crRecvCureMPMethod& handle):
crMethod(handle)
{
}
void crRecvCureMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvCureMPMethod::addParam(int i, const std::string& str)
{
}
void crRecvCureMPMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		short curemp = m_stream->_readShort();
		float rtmp = m_stream->_readFloat();
		data->inputParam(WCHDATA_RTMP,&rtmp);
		//客户端显示
		crNode *node = m_this->getRelNode();
		if(node)
		    node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_CureMP,MAKEINT32(curemp,-1)));
	}
}
/////////////////////////////////////////
//
//crServerRefuseMethod
//
/////////////////////////////////////////
crServerRefuseMethod::crServerRefuseMethod():
m_code(0),
m_netType(GameClient_Game){}
crServerRefuseMethod::crServerRefuseMethod(const crServerRefuseMethod& handle):
crMethod(handle),
m_code(0),
m_netType(GameClient_Game)
{
}
void crServerRefuseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_code = LOINT64(param64);
			m_netType = HIINT64(param64);
		}
		else
		{
			m_code = 0;
			m_netType = GameClient_Game;
		}
		break;
	}
}
void crServerRefuseMethod::addParam(int i, const std::string& str)
{
}
void crServerRefuseMethod::operator()(crHandle &handle)
{
	std::string str = "您在异地登陆了，被迫退出";
	switch(m_netType) 
	{
	case GameClient_Chat:
		str+="(ChatServer)";
		break;
	case GameClient_Game:
		str+="(GameServer)";
		break;
	case GameClient_Download:
		str+="(DownloadServer)";
		break;
	case GameClient_Login:
		str+="(LoginServer)";
		break;
	}
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
}
/////////////////////////////////////////
//
//crUTTransportToBaseMethod
//
/////////////////////////////////////////
crUTTransportToBaseMethod::crUTTransportToBaseMethod(){}
crUTTransportToBaseMethod::crUTTransportToBaseMethod(const crUTTransportToBaseMethod& handle):
crMethod(handle)
{
}
void crUTTransportToBaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_user = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_user = NULL;
		}
		break;
	}
}
void crUTTransportToBaseMethod::addParam(int i, const std::string& str)
{
}
void crUTTransportToBaseMethod::operator()(crHandle &handle)
{
	if(m_this && m_user.valid())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = callback->findScene(m_user->getSceneID());
		int index = -1;
		int roomid = m_user->getRoomID();
		if(roomid!=0)
		{
			crRoom *room = callback->findRoom(roomid);
			if(room)
				index = room->getBirthPointIndex(room->getMember(m_user->getID()));
		}
		//crVector3i pos = scene->gainBirthPoint(m_user->getLayerID(),m_user->getZoffset() * crGlobalHandle::gData()->gUnitScale(),index);
		//m_user->setPosx(pos[0]);
		//m_user->setPosy(pos[1]);
		//m_user->setPosz(pos[2]);
		scene->gainBirthPoint(m_user.get(),index);
		crData *userData = m_user->getDataClass();
		unsigned char targettype = Target_Coord;
		userData->inputParam(WCHDATA_TargetType,&targettype);
		unsigned char itemstate = IS_Stop;
		userData->inputParam(WCHDATA_ItemState,&itemstate);
		//send
		//将信息传给user,不需要同步给附近玩家
		unsigned char usertype = m_user->getItemtype();
		if(usertype == crInstanceItem::Role)
		{
			int userid = m_user->getID();
			crNetManager *netManager = sceneServerConductor->getNetManager();
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(13);
			stream->_writeUChar(TM_None);
			stream->_writeInt(m_user->getPosx());
			stream->_writeInt(m_user->getPosy());
			stream->_writeInt(m_user->getPosz());

			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,userid,m_user.get(),WCH_Transport,stream.get());
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(userid));
			if(playerData.valid())
				netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
		}
	}
}
/////////////////////////////////////////
//
//crUIShowStaticTextMethod
//
/////////////////////////////////////////
crUIShowStaticTextMethod::crUIShowStaticTextMethod(){}
crUIShowStaticTextMethod::crUIShowStaticTextMethod(const crUIShowStaticTextMethod& handle):
crMethod(handle),
m_textElement(handle.m_textElement),
m_text(handle.m_text)
{
}
void crUIShowStaticTextMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIShowStaticTextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textElement = str;
		break;
	case 1:
		m_text = str;
		break;
	}
}

void crUIShowStaticTextMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
        crImageStage *stage = m_element->getParentStage();
		crStaticTextBoxElement *testElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_textElement));
		testElement->setStringArrayByString(m_text);
		stage->setNeedReDraw();
	}
}
/////////////////////////////////////////
//
//crUIShowStaticText2Method
//
/////////////////////////////////////////
crUIShowStaticText2Method::crUIShowStaticText2Method(){}
crUIShowStaticText2Method::crUIShowStaticText2Method(const crUIShowStaticText2Method& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_textElement(handle.m_textElement),
m_text(handle.m_text)
{
}
void crUIShowStaticText2Method::inputParam(int i, void *param)
{
}

void crUIShowStaticText2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_textElement = str;
		break;
	case 2:
		m_text = str;
		break;
	}
}

void crUIShowStaticText2Method::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(stage && stage->getShow())
	{
		crStaticTextBoxElement *textBox = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_textElement));
		if(textBox)
		{
			textBox->setStringArrayByString(m_text);
			stage->setNeedReDraw();
		}
	}
}
/////////////////////////////////////////
//
//crUIAddGameGroupMethod
//
/////////////////////////////////////////
crUIAddGameGroupMethod::crUIAddGameGroupMethod(){}
crUIAddGameGroupMethod::crUIAddGameGroupMethod(const crUIAddGameGroupMethod& handle):
crMethod(handle)
{
}
void crUIAddGameGroupMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIAddGameGroupMethod::addParam(int i, const std::string& str)
{
}

void crUIAddGameGroupMethod::operator()(crHandle &handle)
{

}
/////////////////////////////////////////
//
//crUIAddGameFriendMethod
//
/////////////////////////////////////////
crUIAddGameFriendMethod::crUIAddGameFriendMethod(){}
crUIAddGameFriendMethod::crUIAddGameFriendMethod(const crUIAddGameFriendMethod& handle):
crMethod(handle)
{
}
void crUIAddGameFriendMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIAddGameFriendMethod::addParam(int i, const std::string& str)
{
}

void crUIAddGameFriendMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
		if(!role) return;
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		role->clientGetTarget(targetItem,targetNode);
		if(targetItem.valid() && targetItem->getItemtype() == crInstanceItem::Role)
		{
			int playerid = targetItem->getID();

			crNetChatData *myChatData = crMyPlayerData::getInstance()->getMyChatData();
			if(myChatData && !myChatData->isFriend(playerid))
			{
				crAddChatFriendPacket packet;
				crAddChatFriendPacket::buildRequestPacket(packet,playerid);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Chat);
				if(netConductor)
				    netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		m_element->setShow(false);
		m_element->setEnable(false);
	}
}
/////////////////////////////////////////
//
//crUIChatWithFriendMethod
//
/////////////////////////////////////////
crUIChatWithFriendMethod::crUIChatWithFriendMethod(){}
crUIChatWithFriendMethod::crUIChatWithFriendMethod(const crUIChatWithFriendMethod& handle):
crMethod(handle),
m_stageName(handle.m_stageName),
m_titleElement(handle.m_titleElement),
m_chatRecElement(handle.m_chatRecElement)
{
}
void crUIChatWithFriendMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crUIChatWithFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stageName = str;
		break;
	case 1:
		m_titleElement = str;
		break;
	case 2:
		m_chatRecElement = str;
		break;
	}
}

void crUIChatWithFriendMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crNetChatData *netChatData = crMyPlayerData::getInstance()->getMyChatData();
		crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
		if(!role || !netChatData) return;
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		role->clientGetTarget(targetItem,targetNode);
		if(targetItem.valid() && targetItem->getItemtype() == crInstanceItem::Role)
		{
			int playerid = targetItem->getID();
			crNetChatData::crChatFriend *chatFriend = netChatData->getFriend(playerid);
			crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stageName);
			if(stage && chatFriend)
			{
				netChatData->setChatTarget(crNetChatData::ChatFriend,chatFriend);
				crStaticTextBoxElement *titleElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_titleElement));
				if(titleElement)
				{
					char title[64];
					sprintf(title,"与 %s 聊天中\0",chatFriend->getNickName().c_str());
					titleElement->setStringArrayByString(title);
				}
				crStaticTextBoxElement *chatRecElement = dynamic_cast<crStaticTextBoxElement *>(stage->getElement(m_chatRecElement));
				if(chatRecElement)
				{
					chatRecElement->lockArray();
					chatFriend->getChatRec(chatRecElement->getStringArray());
					chatRecElement->unLockArray();

					chatRecElement->updateData();
				}
				if(stage->getShow())
				{
					stage->setNeedReDraw();
				}
				else
				{
					cr2DStageManager::getInstance()->showStage(stage,true);
				}
				chatFriend->setHasNewMsg(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crExitProgramMethod
//
/////////////////////////////////////////
crExitProgramMethod::crExitProgramMethod(){}
crExitProgramMethod::crExitProgramMethod(const crExitProgramMethod& handle):
crMethod(handle)
{
}
void crExitProgramMethod::inputParam(int i, void *param)
{
}

void crExitProgramMethod::addParam(int i, const std::string& str)
{
}

void crExitProgramMethod::operator()(crHandle &handle)
{
	crMyPlayerData::getInstance()->setExitCode(EC_ExitGame);
    //crMyPlayerData::getInstance()->clear();
}
/////////////////////////////////////////
//
//crRpgChangeCameraMethod
//
/////////////////////////////////////////
crRpgChangeCameraMethod::crRpgChangeCameraMethod():
m_current(0)
{
}

crRpgChangeCameraMethod::crRpgChangeCameraMethod(const crRpgChangeCameraMethod& handle):
crMethod(handle),
m_normal(handle.m_normal),
m_near(handle.m_near),
m_current(0)
{
}

void crRpgChangeCameraMethod::inputParam(int i, void *param)
{
}

void crRpgChangeCameraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_normal);
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_near);
		break;
	}
}

void crRpgChangeCameraMethod::operator()(crHandle &handle)
{
	crViewMatterObject *bot = crSceneManager::getInstance()->getPlayer();
	if(m_current == 0)
	{
		m_current = 1;
        bot->setViewPitch(m_near[0]);
		bot->setViewOffset(m_near[1]);
		bot->setViewPitchRange(crVector2(m_near[0],m_near[0]));
	}
	else if(m_current == 1)
	{
		m_current = 0;
		bot->setViewPitch(m_normal[0]);
		bot->setViewOffset(m_normal[1]);
		bot->setViewPitchRange(crVector2(m_normal[0],m_normal[0]));
	}
}
/////////////////////////////////////////
//
//crCameraShakeMethod
//
/////////////////////////////////////////
crCameraShakeMethod::crCameraShakeMethod():
m_range(0.1f),
m_interval(0.5f)
{
}

crCameraShakeMethod::crCameraShakeMethod(const crCameraShakeMethod& handle):
crMethod(handle),
m_range(handle.m_range),
m_interval(handle.m_interval)
{
}

void crCameraShakeMethod::inputParam(int i, void *param)
{
}

void crCameraShakeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_range = atof(str.c_str());
		break;
	case 1:
		m_interval = atof(str.c_str());
		break;
	}
}

void crCameraShakeMethod::operator()(crHandle &handle)
{
	crViewMatterObject *bot = crSceneManager::getInstance()->getPlayer();
    bot->setViewShake(m_range,m_interval);
}

/////////////////////////////////////////
//
//crUseItemProtectTimeUpdateMethod
//
/////////////////////////////////////////
crUseItemProtectTimeUpdateMethod::crUseItemProtectTimeUpdateMethod():
m_dt(0.0f){}
crUseItemProtectTimeUpdateMethod::crUseItemProtectTimeUpdateMethod(const crUseItemProtectTimeUpdateMethod& handle):
crMethod(handle),
m_dt(0.0f)
{
}
void crUseItemProtectTimeUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crUseItemProtectTimeUpdateMethod::addParam(int i, const std::string& str)
{
}

void crUseItemProtectTimeUpdateMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	//if(m_this && m_dt>0.0f)
	//{
	//	void *param;
	//	crData *data = m_this->getDataClass();
	//	//data->excHandle(MAKEINT64(WCH_LockData,1));
	//	data->getParam(WCHDATA_CurUseItemProtectTime,param);
	//	float* protectTime = (float*)param;
	//	if(protectTime && *protectTime>0.0f)
	//		*protectTime -= m_dt;
	//	//data->excHandle(MAKEINT64(WCH_LockData,0));
	//}
}
////////////开房间式网游
/////////////////////////////////////////
//
//crQuerySceneListMethod
//
/////////////////////////////////////////
crQuerySceneListMethod::crQuerySceneListMethod(){}
crQuerySceneListMethod::crQuerySceneListMethod(const crQuerySceneListMethod& handle):
crMethod(handle)
{
}
void crQuerySceneListMethod::inputParam(int i, void *param)
{
}

void crQuerySceneListMethod::addParam(int i, const std::string& str)
{
}

void crQuerySceneListMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crQuerySceneListPacket packet;
		crQuerySceneListPacket::buildRequestPacket(packet,0,100);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvSceneListMethod
//
/////////////////////////////////////////
crRecvSceneListMethod::crRecvSceneListMethod(){}
crRecvSceneListMethod::crRecvSceneListMethod(const crRecvSceneListMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crRecvSceneListMethod::inputParam(int i, void *param)
{
}

void crRecvSceneListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crRecvSceneListMethod::operator()(crHandle &handle)
{
	crImageStage *stage = cr2DStageManager::getInstance()->findStage(m_stage);
	if(!stage) return;

	crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
	if(columnListElement)
	{
		columnListElement->clearData();
		QuerySceneList &sceneList = crMyPlayerData::getInstance()->getSceneList();
		crQuerySceneInfoData *sceneInfo;
		int i = 0;
		crColumnNode *columnNode;
		for( QuerySceneList::iterator itr = sceneList.begin();
			 itr != sceneList.end();
			 ++itr,++i )
		{
			sceneInfo = itr->get();
			columnNode = new crColumnNode;
			columnNode->addTitle(CRCore::crArgumentParser::appItoa(i));
			columnNode->addTitle(sceneInfo->getSceneName());
			columnNode->setData(sceneInfo);

			columnListElement->addData(columnNode);
		}
		columnListElement->setSelect(1);
		columnListElement->updateData();
	}
}
/////////////////////////////////////////
//
//crSetSelectedSceneMethod
//
/////////////////////////////////////////
crSetSelectedSceneMethod::crSetSelectedSceneMethod(){}
crSetSelectedSceneMethod::crSetSelectedSceneMethod(const crSetSelectedSceneMethod& handle):
crMethod(handle),
m_columnListElement(handle.m_columnListElement)
{
}
void crSetSelectedSceneMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crElement*)param;
}

void crSetSelectedSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_columnListElement = str;
		break;
	}
}

void crSetSelectedSceneMethod::operator()(crHandle &handle)
{
	if(m_element.valid())
	{
		crImageStage *stage = m_element->getParentStage();
		if(!stage) return;

		crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
		if(columnListElement)
		{
			int i = columnListElement->getSelect() - 1;
			if(i>=0)
			{
				crColumnNode *selectNode = columnListElement->getData(i);
				if(selectNode)
				{
					crQuerySceneInfoData *sceneInfoData = (crQuerySceneInfoData *)(selectNode->getData());
					crMyPlayerData::getInstance()->setSceneInfoData(sceneInfoData);
					crGlobalHandle::getInstance()->doEvent(WCH_RecvSceneInfo,MAKEINT64(NULL,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crQuerySceneRoomsMethod
//
/////////////////////////////////////////
crQuerySceneRoomsMethod::crQuerySceneRoomsMethod(){}
crQuerySceneRoomsMethod::crQuerySceneRoomsMethod(const crQuerySceneRoomsMethod& handle):
crMethod(handle)
{
}
void crQuerySceneRoomsMethod::inputParam(int i, void *param)
{
}

void crQuerySceneRoomsMethod::addParam(int i, const std::string& str)
{
}

void crQuerySceneRoomsMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crQuerySceneRoomsPacket packet;
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvSceneRoomsMethod
//
/////////////////////////////////////////
crRecvSceneRoomsMethod::crRecvSceneRoomsMethod(){}
crRecvSceneRoomsMethod::crRecvSceneRoomsMethod(const crRecvSceneRoomsMethod& handle):
crMethod(handle),
m_canvas(handle.m_canvas),
m_tableWidget(handle.m_tableWidget)
{
}
void crRecvSceneRoomsMethod::inputParam(int i, void *param)
{
}

void crRecvSceneRoomsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_tableWidget = str;
		break;
	}
}

void crRecvSceneRoomsMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(!canvas.valid()) return;

	ref_ptr<crTableWidgetNode>tableWidget = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_tableWidget));
	if(tableWidget.valid())
	{
		tableWidget->clearData();
        crMyPlayerData::getInstance()->lockRoomMap();
		RoomMap &roomMap = crMyPlayerData::getInstance()->getRoomMap();
		crRoom *room;
		int i = 0;
		char buf[32];
		for( RoomMap::iterator itr = roomMap.begin();
			itr != roomMap.end();
			++itr,++i )
		{
			room = itr->second.get();
			if(room->getName().empty())
				tableWidget->addData(0,i,"未命名");
			else
				tableWidget->addData(0,i,room->getName());
			switch (room->getGameMode())
			{
			case crRoom::Melee:
				tableWidget->addData(1,i,"混战");
				break;
			case crRoom::TwoGroup:
				tableWidget->addData(1,i,"对抗");
				break;
			case crRoom::CTF:
				tableWidget->addData(1,i,"夺旗");
				break;
			case crRoom::Dota:
				tableWidget->addData(1,i,"Dota");
				break;
			default:
				tableWidget->addData(1,i,CRCore::crArgumentParser::appItoa(room->getGameMode()));
			}
			tableWidget->addData(2,i,CRCore::crArgumentParser::appItoa(room->getGameTime()));
			tableWidget->addData(3,i,room->getFriendlyFire()?"是":"否");
			tableWidget->addData(4,i,"是");
			sprintf(buf,"%d|%d\0",(int)(room->getPlayerCount()),(int)(room->getMaxPlayerCount()));
			tableWidget->addData(5,i,buf);
		}
		crMyPlayerData::getInstance()->unlockRoomMap();
		tableWidget->selectRow(0);
	}
}
///////////////////////////////////////////
////
////crCreateSceneRoomMethod
////
///////////////////////////////////////////
//crCreateSceneRoomMethod::crCreateSceneRoomMethod(){}
//crCreateSceneRoomMethod::crCreateSceneRoomMethod(const crCreateSceneRoomMethod& handle):
//crMethod(handle),
//m_roomNameElement(handle.m_roomNameElement),
//m_gameModeElement(handle.m_gameModeElement),
//m_passwordElement(handle.m_passwordElement),
//m_maxPlayerCountElement(handle.m_maxPlayerCountElement)
//{
//}
//void crCreateSceneRoomMethod::inputParam(int i, void *param)
//{
//	if(i==0)
//		m_element = (CRGUI::crElement*)param;
//}
//
//void crCreateSceneRoomMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_roomNameElement = str;
//		break;
//	case 1:
//		m_gameModeElement = str;
//		break;
//	case 2:
//		m_passwordElement = str;
//		break;
//	case 3:
//		m_maxPlayerCountElement = str;
//		break;
//	}
//}
//
//void crCreateSceneRoomMethod::operator()(crHandle &handle)
//{
//	if(m_element.valid())
//	{
//		crImageStage *stage = m_element->getParentStage();
//		if(!stage) return;
//
//		std::string roomName;
//		unsigned char gameMode = 0;
//		std::string password;
//	    unsigned char maxPlayerCount = 0;
//		crEditBoxElement *roomNameElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_roomNameElement));
//		if(roomNameElement)
//		{
//		    roomName = roomNameElement->getStringArrayInString();
//		}
//		crEditBoxElement *gameModeElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_gameModeElement));
//		if(gameModeElement)
//		{
//			gameMode = (unsigned char)(atoi(gameModeElement->getStringArrayInString().c_str()));
//		}
//		crEditBoxElement *passwordElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_passwordElement));
//		if(passwordElement)
//		{
//			password = passwordElement->getStringArrayInString();
//		}
//		crEditBoxElement *maxPlayerCountElement = dynamic_cast<crEditBoxElement *>(stage->getElement(m_maxPlayerCountElement));
//		if(maxPlayerCountElement)
//		{
//			maxPlayerCount = (unsigned char)(atoi(maxPlayerCountElement->getStringArrayInString().c_str()));
//		}
//
//		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//		if(netConductor)
//		{
//			crWaitNetReturnStreamLogic::getLock();
//			crCreateSceneRoomPacket packet;
//			crCreateSceneRoomPacket::buildRequestPacket(packet,roomName,gameMode,password,maxPlayerCount);
//			netConductor->getNetManager()->sendPacket("all",packet);
//		}
//	}
//}
/////////////////////////////////////////
//
//crCreateSceneRoomMethod
//
/////////////////////////////////////////
crCreateSceneRoomMethod::crCreateSceneRoomMethod():
m_autoStart(true),
m_autoStartTime(5.0f){}
crCreateSceneRoomMethod::crCreateSceneRoomMethod(const crCreateSceneRoomMethod& handle):
	crMethod(handle),
	m_battleMode(handle.m_battleMode),
	m_battleName(handle.m_battleName),
	m_timeLimit(handle.m_timeLimit),
	m_friendlyFire(handle.m_friendlyFire),
	m_timeLimits(handle.m_timeLimits),
	m_autoStart(handle.m_autoStart),
	m_autoStartTime(handle.m_autoStartTime)
{
}
void crCreateSceneRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crCreateSceneRoomMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battleMode = str;
		break;
	case 1:
		m_battleName = str;
		break;
	case 2:
		m_timeLimit = str;//从索引转换为时间
		break;
	case 3:
		m_friendlyFire = str;
		break;
	case 4:
		m_autoStart = (bool)atoi(str.c_str());
		break;
	case 5:
		m_autoStartTime = atof(str.c_str());
		break;
	default:
		m_timeLimits.push_back((short)(atoi(str.c_str())));
		break;
	}
}

void crCreateSceneRoomMethod::operator()(crHandle &handle)
{
	if(m_this && crMyPlayerData::getInstance()->getSelectedGameRole())
	{
		crCanvasNode *canvas = m_this->getParentCanvas();
		if(!canvas) return;

		char battleMode = 0;
		std::string battleName;
		int timeLimit = 0;
		bool friendlyFire = false;
		crMultiSwitch *battleModeNode = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_battleMode));
		if(battleModeNode)
		{
			battleMode = (char)(battleModeNode->getActiveSwitchSet());
		}
		crEditWidgetNode *battleNameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_battleName));
		if(battleNameWidget)
		{
			battleName = battleNameWidget->getUTF8String();
		}
		crMultiSwitch *timeLimitNode = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_timeLimit));
		if(timeLimitNode)
		{
			timeLimit = m_timeLimits[timeLimitNode->getActiveSwitchSet()];
		}
		crMultiSwitch *friendlyFireNode = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_friendlyFire));
		if(friendlyFireNode)
		{
			friendlyFire = (bool)(friendlyFireNode->getActiveSwitchSet());
		}
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			if(battleName.size()>16)
				battleName = battleName.substr(0,16);
			crWaitNetReturnStreamLogic::getLock();
			ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
			streamBuf->createBuf(33);
			streamBuf->_writeChar(battleMode);//1
			streamBuf->_writeString(battleName);//16+4
			streamBuf->_writeInt(timeLimit);//4
			streamBuf->_writeShort(16);//playercount
			streamBuf->_writeBool(friendlyFire);//1
			streamBuf->_writeBool(m_autoStart);//1
			streamBuf->_writeFloat(m_autoStartTime);//4
			//streamBuf->_writeString(password);//8+4
			crCreateSceneRoomPacket packet;
			crCreateSceneRoomPacket::buildRequestPacket(packet,streamBuf.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvCreateSceneRoomMethod
//
/////////////////////////////////////////
crRecvCreateSceneRoomMethod::crRecvCreateSceneRoomMethod():
m_success(false){}
crRecvCreateSceneRoomMethod::crRecvCreateSceneRoomMethod(const crRecvCreateSceneRoomMethod& handle):
crMethod(handle),
m_success(false)
{
}
void crRecvCreateSceneRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_success = LOINT64(param64);
		}
		else
		{
			m_success = false;
		}
		break;
	}
}

void crRecvCreateSceneRoomMethod::addParam(int i, const std::string& str)
{
}

void crRecvCreateSceneRoomMethod::operator()(crHandle &handle)
{
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(1);
	stream->_writeBool(m_success);
	stream->seekBegin();
	crWaitNetReturnStreamLogic::netReturn(stream.get());
}
/////////////////////////////////////////
//
//crCreateRoomReturnMethod
//
/////////////////////////////////////////
crEnterRoomReturnMethod::crEnterRoomReturnMethod(){}
crEnterRoomReturnMethod::crEnterRoomReturnMethod(const crEnterRoomReturnMethod& handle):
crMethod(handle)
{
}
void crEnterRoomReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 3:
		m_stream = (crStreamBuf *)(param);
		break;
	}
}
void crEnterRoomReturnMethod::addParam(int i, const std::string& str)
{
}
void crEnterRoomReturnMethod::operator()(crHandle &handle)
{
	bool success = false;
	if(m_stream.valid())
	{
		success = m_stream->_readBool();
	}
	handle.outputParam(0,&success);
}
///////////////////////////////////////////
////
////crEnterSceneRoomMethod
////
///////////////////////////////////////////
//crEnterSceneRoomMethod::crEnterSceneRoomMethod(){}
//crEnterSceneRoomMethod::crEnterSceneRoomMethod(const crEnterSceneRoomMethod& handle):
//crMethod(handle),
//m_columnListElement(handle.m_columnListElement)
//{
//}
//void crEnterSceneRoomMethod::inputParam(int i, void *param)
//{
//	if(i==0)
//		m_element = (CRGUI::crElement*)param;
//}
//
//void crEnterSceneRoomMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_columnListElement = str;
//		break;
//	}
//}
//
//void crEnterSceneRoomMethod::operator()(crHandle &handle)
//{
//	bool success = false;
//	if(m_element.valid())
//	{
//		crImageStage *stage = m_element->getParentStage();
//		if(!stage) return;
//
//		crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(stage->getElement(m_columnListElement));
//		if(columnListElement)
//		{
//			int i = columnListElement->getSelect() - 1;
//			if(i>=0)
//			{
//				crColumnNode *selectNode = columnListElement->getData(i);
//				if(selectNode)
//				{
//					crRoom *room = (crRoom *)(selectNode->getData());
//					if(room->getPlayerCount() < room->getMaxPlayerCount())
//					{
//						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//						if(netConductor)
//						{
//							crWaitNetReturnStreamLogic::getLock();
//							crEnterSceneRoomPacket packet;
//							crEnterSceneRoomPacket::buildRequestPacket(packet,room->getRoomID());
//							netConductor->getNetManager()->sendPacket("all",packet);
//							success = true; 
//						}
//					}
//				}
//			}
//		}
//	}
//	handle.outputParam(0,&success);
//}
/////////////////////////////////////////
//
//crPreEnterSceneRoomMethod
//
/////////////////////////////////////////
crPreEnterSceneRoomMethod::crPreEnterSceneRoomMethod(){}
crPreEnterSceneRoomMethod::crPreEnterSceneRoomMethod(const crPreEnterSceneRoomMethod& handle):
	crMethod(handle)
{
}
void crPreEnterSceneRoomMethod::inputParam(int i, void *param)
{
}

void crPreEnterSceneRoomMethod::addParam(int i, const std::string& str)
{
}

void crPreEnterSceneRoomMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crRole *role = crMyPlayerData::getInstance()->getSelectedGameRole();
	if(role && room && room->isCanJoin())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			//std::string str = "登陆房间...";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(3,NULL));
			//crWaitNetReturnStreamLogic::getLock();
			crPreEnterSceneRoomPacket packet;
			crPreEnterSceneRoomPacket::buildRequestPacket(packet,room->getRoomID(),crMyPlayerData::getInstance()->getCharacterName());
			netConductor->getNetManager()->sendPacket("all",packet);
			return;
		}
	}
	//false
	crBrain::getInstance()->doEvent(WCH_RecvEnterSceneRoom,MAKEINT64(0,NULL));
	//char mode = crMyPlayerData::getInstance()->getLoginGameSceneMode();
	//if(mode == 2)
	//{
	//	crMyPlayerData::getInstance()->getPlayerGameData()->doEvent(WCH_RecvEnterSceneRoom,MAKEINT64(0,NULL));
	//}
	//else
	//{
	//	crBrain::getInstance()->doEvent(WCH_RecvEnterSceneRoom,MAKEINT64(0,NULL));
	//}
	//if(taskCanceled)
	//{
		//std::string str = "登陆房间失败...";
		//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(4,NULL));
	//}
	//handle.outputParam(0,&taskCanceled);
}
/////////////////////////////////////////
//
//crRecvEnterSceneRoomMethod
//
/////////////////////////////////////////
crRecvEnterSceneRoomMethod::crRecvEnterSceneRoomMethod():
m_success(false){}
crRecvEnterSceneRoomMethod::crRecvEnterSceneRoomMethod(const crRecvEnterSceneRoomMethod& handle):
crMethod(handle),
m_success(false)
{
}
void crRecvEnterSceneRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_success = LOINT64(param64);
		}
		else
		{
			m_success = false;
		}
		break;
	}
}

void crRecvEnterSceneRoomMethod::addParam(int i, const std::string& str)
{
}

void crRecvEnterSceneRoomMethod::operator()(crHandle &handle)
{
	//char mode = crMyPlayerData::getInstance()->getLoginGameSceneMode();
	//if(mode == 2)
	//{
	//	crMyPlayerData::getInstance()->getPlayerGameData()->doEvent(WCH_RecvEnterSceneRoom,MAKEINT64(m_success,NULL));
	//}
	//else
	//{
	//	//ref_ptr<crStreamBuf> stream = new crStreamBuf;
	//	//stream->createBuf(1);
	//	//stream->_writeBool(m_success);
	//	//stream->seekBegin();
	//	//crWaitNetReturnStreamLogic::netReturn(stream.get());
	//	crBrain::getInstance()->doEvent(WCH_RecvEnterSceneRoom,MAKEINT64(m_success,NULL));
	//}
}
/////////////////////////////////////////
//
//crRoomInfoChangeMethod
//
/////////////////////////////////////////
crRoomInfoChangeMethod::crRoomInfoChangeMethod(){}
crRoomInfoChangeMethod::crRoomInfoChangeMethod(const crRoomInfoChangeMethod& handle):
crMethod(handle),
m_stage(handle.m_stage),
m_columnListElement(handle.m_columnListElement)
{
}
void crRoomInfoChangeMethod::inputParam(int i, void *param)
{
}

void crRoomInfoChangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stage = str;
		break;
	case 1:
		m_columnListElement = str;
		break;
	}
}

void crRoomInfoChangeMethod::operator()(crHandle &handle)
{
}

////////////////////////////////////////
//
//crUIRoomInfoUpdateMethod
//
/////////////////////////////////////////
crUIRoomInfoUpdateMethod::crUIRoomInfoUpdateMethod(){}
crUIRoomInfoUpdateMethod::crUIRoomInfoUpdateMethod(const crUIRoomInfoUpdateMethod& handle):
crMethod(handle),
m_playerListElement(handle.m_playerListElement)
{
}
void crUIRoomInfoUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		m_this = (crImageStage*)(param);
		break;
	}
}
void crUIRoomInfoUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerListElement = str;
		break;
	}
}
void crUIRoomInfoUpdateMethod::operator()(crHandle &handle)
{
	//crColumnListElement *columnListElement = dynamic_cast<crColumnListElement *>(m_this->getElement(m_playerListElement));
	//crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	//if(columnListElement && room)
	//{
	//	columnListElement->clearData();
	//	room->lockPlayerMap();
	//	crRoom::PlayerMap &roomPlayerMap = room->getPlayerMap();
	//	crRoom::crRoomPlayer *roomPlayer;
	//	crColumnNode *columnNode;
	//	crRole *role;
	//	unsigned char lv;
	//	crData *data;
	//	void *param;
	//	for( crRoom::PlayerMap::iterator itr = roomPlayerMap.begin();
	//		itr != roomPlayerMap.end();
	//		++itr )
	//	{
	//		roomPlayer = itr->second.get();
	//		columnNode = new crColumnNode;
	//		columnNode->addTitle(CRCore::crArgumentParser::appItoa(roomPlayer->getGroupID()));
	//		role = roomPlayer->getRole();
	//		if(role)
	//		{
	//			columnNode->addTitle(role->getIName());
	//			lv = 0;
	//			data = role->getMetierDataClass();
	//			if(data)
	//			{
	//				data->getParam(WCHDATA_Level,param);
	//				lv = *(unsigned char *)param;
	//			}

	//			columnNode->addTitle(CRCore::crArgumentParser::appItoa((int)lv));
	//		}
	//		else
	//		{
	//			columnNode->addTitle("");
	//			columnNode->addTitle("0");
	//		}
	//		if(room->getRoomHost() == roomPlayer->getPlayerID())
	//		{
	//			columnNode->addTitle("房主");
	//		}
	//		columnNode->setData(roomPlayer);
	//		columnListElement->addData(columnNode);
	//	}
	//	room->unlockPlayerMap();
	//	columnListElement->updateData();
	//}
}
///////////////////////////////////////////
////
////crLeaveSceneRoomMethod
////
///////////////////////////////////////////
//crLeaveSceneRoomMethod::crLeaveSceneRoomMethod(){}
//crLeaveSceneRoomMethod::crLeaveSceneRoomMethod(const crLeaveSceneRoomMethod& handle):
//crMethod(handle)
//{
//}
//void crLeaveSceneRoomMethod::inputParam(int i, void *param)
//{
//}
//
//void crLeaveSceneRoomMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crLeaveSceneRoomMethod::operator()(crHandle &handle)
//{
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(netConductor)
//	{
//		crLeaveSceneRoomPacket packet;
//		netConductor->getNetManager()->sendPacket("all",packet);
//	}
//	crMyPlayerData::getInstance()->setSelectedRoom(NULL);
//}
///////////////////////////////////////////
////
////crRecvRoomPlayerDataMethod
////
///////////////////////////////////////////
//crRecvRoomPlayerDataMethod::crRecvRoomPlayerDataMethod(){}
//crRecvRoomPlayerDataMethod::crRecvRoomPlayerDataMethod(const crRecvRoomPlayerDataMethod& handle):
//crMethod(handle),
//m_recvDataStream(handle.m_recvDataStream)
//{
//}
//void crRecvRoomPlayerDataMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_recvDataStream = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
//		}
//		else
//		{
//			m_recvDataStream = NULL;
//		}
//		break;
//	}
//}
//
//void crRecvRoomPlayerDataMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRecvRoomPlayerDataMethod::operator()(crHandle &handle)
//{
//	//if(m_recvDataStream.valid())
//	//{
//	//	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
//	//	crStreamBuf *stream = m_recvDataStream->getStream();
//	//	unsigned char groupid = stream->_readUChar();
//	//	ref_ptr<crInstanceItem> item;
//	//	readItem(item,m_recvDataStream->getStream(),false);
//	//	ref_ptr<crRoom::crRoomPlayer> roomPlayer = new crRoom::crRoomPlayer;
//	//	roomPlayer->setGroupID(groupid);
//	//	roomPlayer->setRole(dynamic_cast<crRole *>(item.get()));
//	//	room->addMember(roomPlayer.get());
//	//	crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
//	//}
//}
/////////////////////////////////////////
//
//crStartRoomGameMethod
//
/////////////////////////////////////////
crStartRoomGameMethod::crStartRoomGameMethod(){}
crStartRoomGameMethod::crStartRoomGameMethod(const crStartRoomGameMethod& handle):
crMethod(handle)
{
}
void crStartRoomGameMethod::inputParam(int i, void *param)
{
}

void crStartRoomGameMethod::addParam(int i, const std::string& str)
{
}

void crStartRoomGameMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crStartRoomGamePacket packet;
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvStartRoomGameMethod
//
/////////////////////////////////////////
crRecvStartRoomGameMethod::crRecvStartRoomGameMethod(){}
crRecvStartRoomGameMethod::crRecvStartRoomGameMethod(const crRecvStartRoomGameMethod& handle):
crMethod(handle)
{
}
void crRecvStartRoomGameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvStartRoomGameMethod::addParam(int i, const std::string& str)
{
}

void crRecvStartRoomGameMethod::operator()(crHandle &handle)
{
	char count = m_stream->_readChar();
	int roleid;
	crRole *role;
	crData *roleData;
	//unsigned char itemstate = IS_Stop;
	crNode *relNode;
	float dt = 0.1f;
	for(int i = 0; i <count;  i++)
	{
		roleid = m_stream->_readInt();
		role = crMyPlayerData::getInstance()->getRole(roleid);
		if(role)
		{
			roleData = role->getDataClass();
			roleData->excHandle(MAKEINT64(WCH_InitData,role));
			//roleData->inputParam(WCHDATA_ItemState, &itemstate);
			role->setPosxy(m_stream->_readVec2());
			role->setPosz(m_stream->_readFloat());
			relNode = role->getRelNode();
			if(relNode)
			{
				role->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
				//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
				relNode->setVisiable(true);
				relNode->setEnableIntersect(true);
			}
			role->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Idle,&dt));
			role->doEvent(WCH_CheckAndRackEquipOnMesh);
			//CRCore::notify(CRCore::ALWAYS)<<"crRecvStartRoomGameMethod "<<role->getRoleID()<<" "<<role->getPosition()<<std::endl;
		}
		else
		{
			m_stream->seek(12);
		}
	}
	float timeremain = m_stream->_readFloat();
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(room)
	{
		room->setGameRunning(true);
		room->timeRemain() = timeremain;
		room->doEvent(WCH_GameStart);
	}
	crBrain::getInstance()->doEvent(WCH_GameStart);
	//crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	//crData *roleData = role->getDataClass();
	//roleData->excHandle(MAKEINT64(WCH_InitData,NULL));
	//unsigned char itemstate = IS_Stop;
	//roleData->inputParam(WCHDATA_ItemState, &itemstate);
	//role->setPosx(m_stream->_readInt());
	//role->setPosy(m_stream->_readInt());
	//role->setPosz(m_stream->_readInt());
	//crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	//room->setGameRunning(true);
	//crNode *node = role->getRelNode();
	//if(node)
	//{
	//	role->doEvent(WCH_ItemCoordToNode,MAKEINT64(node,crMatterObject::MD_FullMatrix));
	//	node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
	//}
}
/////////////////////////////////////////
//
//crRecvEndRoomGameMethod
//
/////////////////////////////////////////
crRecvEndRoomGameMethod::crRecvEndRoomGameMethod(){}
crRecvEndRoomGameMethod::crRecvEndRoomGameMethod(const crRecvEndRoomGameMethod& handle):
crMethod(handle)
{
}
void crRecvEndRoomGameMethod::inputParam(int i, void *param)
{
}

void crRecvEndRoomGameMethod::addParam(int i, const std::string& str)
{
}

void crRecvEndRoomGameMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(room)
	{
		room->setGameRunning(false);
		crBrain::getInstance()->doEvent(WCH_GameEnd);
	}
}
/////////////////////////////////////////
//
//crCheckAndRackEquipOnMeshMethod
//
/////////////////////////////////////////
crCheckAndRackEquipOnMeshMethod::crCheckAndRackEquipOnMeshMethod(){}
crCheckAndRackEquipOnMeshMethod::crCheckAndRackEquipOnMeshMethod(const crCheckAndRackEquipOnMeshMethod& handle):
crMethod(handle),
m_partRange(m_partRange)
{
}
void crCheckAndRackEquipOnMeshMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crCheckAndRackEquipOnMeshMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_partRange);
	}
}
void crCheckAndRackEquipOnMeshMethod::operator()(crHandle &handle)
{
	crViewMatterObject *bot= dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
	if(bot)
	{
		CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(bot->getBodyChild());
		if(bodyNode)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap* equipOnMap = (EquipOnMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string meshFile;
			EquipOnMeshMap equipOnMeshMap;
			for(int i = m_partRange[0]; i<m_partRange[1]; i++)
			{//如果该ID是基础部件，需装载基础部件
				equipOnMeshMap[i] = (MeshScript*)0;
			}
			ref_ptr<MeshScript> meshScript;
			std::string path;
			std::string str;
			int nMesh = 1;
			int int1;
			for( EquipOnMap::iterator itr = equipOnMap->begin();
				itr != equipOnMap->end();
				++itr )
			{
				if(itr->second==0)
					continue;
				itemchild = m_this->findChildItem(itr->second);
				if(itemchild && itemchild->isLoaded())
				{
					item = itemchild->getInstanceItem();
					itemData = item->getDataClass();
					if(!itemData)
						continue;
					itemData->getParam(WCHDATA_MeshFileName,param);
					if(!param)
						continue;
					meshFile = *(std::string *)param;
					if(!meshFile.empty())
					{//换装
						rcfg::ConfigScript cfg_script;
						if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,meshFile))
						{
							CRCore::notify(CRCore::FATAL)<<"crCheckAndRackEquipOnMeshMethod::operator(): file open error"<<std::endl;
							continue;
						}
						if(cfg_script.Push("Character"))
						{
							cfg_script.Get("path", path);
							nMesh = 1;
							while(cfg_script.Push("Mesh",nMesh++))
							{
								meshScript = new MeshScript;
								meshScript->setPath(path);
								meshScript->setRbodyFile(meshFile);
								cfg_script.Get("partid", int1);
								meshScript->setPartID(int1);
								cfg_script.Get("name", str);
								meshScript->setName(str);
								cfg_script.Get("filename", str);
								meshScript->setFileName(str);
								equipOnMeshMap[meshScript->getPartID()] = meshScript;
								if (!cfg_script.Pop())
									CRCore::notify(CRCore::FATAL)<<"crCheckAndRackEquipOnMeshMethod::operator(): "<<cfg_script.GetLastError()<<std::endl;
							}
							cfg_script.Pop();
						}
					}
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			std::string currentPartMeshName;
			std::string meshName;
			Mesh *mesh;
			for( EquipOnMeshMap::iterator itr = equipOnMeshMap.begin();
				 itr != equipOnMeshMap.end();
				 ++itr )
			{
				currentPartMeshName = bodyNode->getCurrentPartMeshName(itr->first);
				if(!itr->second.valid())
				{
					if(currentPartMeshName.compare("NULL")!=0)
						bodyNode->deleteMesh(currentPartMeshName);
				}
				else
				{
					meshName = itr->second->getName();
					if(currentPartMeshName.compare(meshName)==0) 
					{
						bodyNode->attachMesh(meshName);
					}
					else
					{
						mesh = new Mesh;
						mesh->setMaterialFileName(itr->second->getRbodyFile());
						mesh->setPartID(itr->second->getPartID());
						mesh->setName(meshName);
						mesh->setFilename(itr->second->getFileName());
						mesh->setIsDefault(false);
						bodyNode->getBody()->getCoreBody()->setPath(path);
						bodyNode->addMesh(mesh);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crLenFadeInitMethod
//
/////////////////////////////////////////
crLenFadeInitMethod::crLenFadeInitMethod()
{
	m_color.set(0.0f,0.0f,0.0f,1.0f);
}

crLenFadeInitMethod::crLenFadeInitMethod(const crLenFadeInitMethod& handle):
crMethod(handle),
m_color(handle.m_color)
{
}

void crLenFadeInitMethod::inputParam(int i, void *param)
{
}

void crLenFadeInitMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_color);
		m_color/=255.0f;
		break;
	}
}

void crLenFadeInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>lenCanvas = crFilterRenderManager::getInstance()->findCanvas("LenCanvas");
	if(lenCanvas.valid())
	{
		lenCanvas->setCanvasPos(CANVAS_TOPMOST);
		crObject *lenObject = dynamic_cast<crObject *>(lenCanvas->getChild(0));
		crDrawable *drawable = lenObject->getDrawable(0);
		drawable->setColor(m_color);
		crFilterRenderManager::getInstance()->showCanvas(lenCanvas.get(),true);
	}
}
/////////////////////////////////////////
//
//crLenFadeInit2Method
//
/////////////////////////////////////////
crLenFadeInit2Method::crLenFadeInit2Method()
{
	m_color.set(0.0f,0.0f,0.0f,1.0f);
}

crLenFadeInit2Method::crLenFadeInit2Method(const crLenFadeInit2Method& handle):
	crMethod(handle),
	m_color(handle.m_color)
{
}

void crLenFadeInit2Method::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_color = *(crVector4*)(LOINT64(param64));
		}
		break;
	}
}

void crLenFadeInit2Method::addParam(int i, const std::string& str)
{
}

void crLenFadeInit2Method::operator()(crHandle &handle)
{
	m_this->setCanvasPos(CANVAS_TOPMOST);
	crObject *lenObject = dynamic_cast<crObject *>(m_this->getChild(0));
	crDrawable *drawable = lenObject->getDrawable(0);
	drawable->setColor(m_color);
	crFilterRenderManager::getInstance()->showCanvas(m_this,true);
}
/////////////////////////////////////////
//
//crLenFadeUpdateMethod
//
/////////////////////////////////////////
crLenFadeUpdateMethod::crLenFadeUpdateMethod():
m_speed(2.0f),
m_dt(NULL)
{
}

crLenFadeUpdateMethod::crLenFadeUpdateMethod(const crLenFadeUpdateMethod& handle):
crMethod(handle),
m_speed(handle.m_speed),
m_dt(NULL)
{
}

void crLenFadeUpdateMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_dt = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		break;
	}
}

void crLenFadeUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_speed = atof(str.c_str());
		break;
	}
}

void crLenFadeUpdateMethod::operator()(crHandle &handle)
{
	crObject *lenObject = dynamic_cast<crObject *>(m_this->getChild(0));
	crDrawable *drawable = lenObject->getDrawable(0);
	crVector4 color = drawable->getColor();
	float& alpha = color[3];
	if(m_speed>0.0f && alpha >= 1.0f)
	{
		alpha = 1.0f;
		m_speed = -m_speed;
	}
	else if(m_speed<0.0f && alpha <= 0.0f)
	{
		alpha = 0.0f;
		crFilterRenderManager::getInstance()->closeCanvas(m_this);
		//m_this->setVisiable(false);
	}
	else
	{
		alpha += ((float)m_speed / 255.0f) * (*m_dt);
	}
	drawable->setColor(color);
}
/////////////////////////////////////////
//
//crAttachCameraToNodeMethod
//
/////////////////////////////////////////
crAttachCameraToNodeMethod::crAttachCameraToNodeMethod()
{
}

crAttachCameraToNodeMethod::crAttachCameraToNodeMethod(const crAttachCameraToNodeMethod& handle):
crMethod(handle),
m_cameraName(handle.m_cameraName)
{
}

void crAttachCameraToNodeMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crNode*)param;
		break;
	}
}

void crAttachCameraToNodeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_cameraName = str;
		break;
	}
}

void crAttachCameraToNodeMethod::operator()(crHandle &handle)
{
	crCamera *camera = crCameraManager::getInstance()->getCamera(m_cameraName);
	if(m_this && camera)
	{
		camera->attachNode(m_this);
	}
}
/////////////////////////////////////////
//
//crChangeCameraMethod
//
/////////////////////////////////////////
crChangeCameraMethod::crChangeCameraMethod()
{
}

crChangeCameraMethod::crChangeCameraMethod(const crChangeCameraMethod& handle):
crMethod(handle),
m_cameraName(handle.m_cameraName)
{
}

void crChangeCameraMethod::inputParam(int i, void *param)
{
}

void crChangeCameraMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_cameraName = str;
		break;
	}
}

void crChangeCameraMethod::operator()(crHandle &handle)
{
	crCamera *mainCamera = crCameraManager::getInstance()->getMainCamera();
	crCamera *camera = crCameraManager::getInstance()->getCamera(m_cameraName);
	if(camera && camera != mainCamera)
	{
		crNode *cameraNode = mainCamera->getAttachedNode();
		cameraNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_BorrowCamera,camera));
	}
}
/////////////////////////////////////////
//
//crIfInVolumeNodeIsMeMethod
//
/////////////////////////////////////////
crIfInVolumeNodeIsMeMethod::crIfInVolumeNodeIsMeMethod():
	m_inVolumeNode(NULL)
{
}

crIfInVolumeNodeIsMeMethod::crIfInVolumeNodeIsMeMethod(const crIfInVolumeNodeIsMeMethod& handle):
	crMethod(handle),
	m_inVolumeNode(NULL)
{
}

void crIfInVolumeNodeIsMeMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_inVolumeNode = (crNode *)(LOINT64(param64));
		}
		else
		{
			m_inVolumeNode = 0;
		}
		break;
	}
}

void crIfInVolumeNodeIsMeMethod::addParam(int i, const std::string& str)
{
}

void crIfInVolumeNodeIsMeMethod::operator()(crHandle &handle)
{
	bool bln = crMyPlayerData::getInstance()->ifNodeIsMe(m_inVolumeNode);
	handle.outputParam(0,&bln);
}
/////////////////////////////////////////
//
//crBorrowCameraMethod
//
/////////////////////////////////////////
crBorrowCameraMethod::crBorrowCameraMethod():
m_timeDelay(1.0f)
{
}

crBorrowCameraMethod::crBorrowCameraMethod(const crBorrowCameraMethod& handle):
crMethod(handle),
m_timeDelay(handle.m_timeDelay)
{
}

void crBorrowCameraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_borrower = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_borrower = (crCamera *)(LOINT64(param64));
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(HIINT64(param64));
		}
		else
		{
			m_borrower = 0;
			m_updateVisitor = 0;
		}
		break;
	}
}

void crBorrowCameraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_timeDelay = atof(str.c_str());
		break;
	}
}

void crBorrowCameraMethod::operator()(crHandle &handle)
{
	crViewer *viewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(m_this && viewer && viewer->isInited() && m_borrower.valid() && m_borrower->getAttachedNode() && m_updateVisitor.valid())
	{
		float borrowTime = crFrameStamp::getInstance()->getReferenceTime();
		crNode *borrowerNode = m_borrower->getAttachedNode();
		float borrowInterval = -1;
		if(dynamic_cast<crMatrixTransform *>(borrowerNode))
		{
			crMatrixTransform *matrixNode = dynamic_cast<crMatrixTransform *>(borrowerNode);
			crAnimationPathCallback *animationPathCallback = dynamic_cast<crAnimationPathCallback *>(matrixNode->getUpdateCallback("AnimationPath"));
			if(animationPathCallback)
			{
				borrowInterval = animationPathCallback->getAnimationPath()->getPeriod();
				animationPathCallback->reset();
				animationPathCallback->setPause(false);
			}
		}
		else if(dynamic_cast<crDOFTransform *>(borrowerNode))
		{
			crDOFTransform *dofNode = dynamic_cast<crDOFTransform *>(borrowerNode);
            borrowInterval = dofNode->getLifeTime();
			dofNode->reset();
			dofNode->setAnimationOn(true);
		}

		if(borrowInterval>0) borrowInterval += m_timeDelay;
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_CameraBorrowTime,&borrowTime);
		data->inputParam(WCHDATA_CameraBorrowInterval,&borrowInterval);
		viewer->setViewCameraNode(m_borrower.get());
		borrowerNode->doEvent(WCH_BorrowCamera);
		//crVector3 nullpos;
		//float speed = 0.0f;
		//m_this->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));//停止移动
		//void *param;
		//data->getParam(WCHDATA_Item,param);
		//if(param)
		//{
		//	crInstanceItem *item = (crInstanceItem *)param;
		//	item->recordItemState();
		//	unsigned char itemstate = IS_Stop;
		//	item->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
		//	//crData *itemData = item->getDataClass();
		//	//itemData->getParam(WCHDATA_ItemState,param);
		//	//unsigned char itemstate = *(unsigned char *)param;
		//	//if(itemstate != IS_Stop)
		//	//{
		//	//	itemstate = IS_Stop;
		//	//	item->getDataClass()->inputParam(WCHDATA_ItemState,&itemstate);
		//	//	//send itemstate to server
		//	//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		//	//	if(netConductor)
		//	//	{
		//	//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		//	//		stream->createBuf(1);
		//	//		stream->_writeUChar(itemstate);//1
		//	//		crPlayerEventPacket packet;
		//	//		crPlayerEventPacket::buildRequestPacket(packet,item->getRoleID(),WCH_RecvItemState,stream.get());
		//	//		netConductor->getNetManager()->sendPacket("all",packet);
		//	//	}
		//	//}
		//}

		ref_ptr<crCanvasNode>lenCanvas = crFilterRenderManager::getInstance()->findCanvas("LenCanvas");
		if(lenCanvas.valid() && !lenCanvas->getVisiable())
		{
			crVector4 color(0.0f,0.0f,0.0f,1.0f);
			lenCanvas->doEvent(WCH_LenFadeInit,MAKEINT64(&color,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crCameraBorrowUpdateMethod
//
/////////////////////////////////////////
crCameraBorrowUpdateMethod::crCameraBorrowUpdateMethod(){}
crCameraBorrowUpdateMethod::crCameraBorrowUpdateMethod(const crCameraBorrowUpdateMethod& handle):
crMethod(handle)
{
}
void crCameraBorrowUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(LOINT64(param64));
		}
		else
		{
			m_updateVisitor = NULL;
		}
		break;
	}
}

void crCameraBorrowUpdateMethod::addParam(int i, const std::string& str)
{
}

void crCameraBorrowUpdateMethod::operator()(crHandle &handle)
{
	if(m_this && m_updateVisitor.valid())
	{
		crCamera *camera = crCameraManager::getInstance()->getCurrentCamera();
		crCamera *mainCamera = crCameraManager::getInstance()->getMainCamera();
		if(camera!=mainCamera)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_CameraBorrowTime,param);
			float cameraBorrowTime = *(float*)param;
			data->getParam(WCHDATA_CameraBorrowInterval,param);
			float cameraBorrowInterval = *(float*)param;

			float time = crFrameStamp::getInstance()->getReferenceTime();
			if(cameraBorrowTime>0.0f && cameraBorrowInterval>=0.0f && time - cameraBorrowTime > cameraBorrowInterval)
			{//cameraBorrowInterval = -1表示无限
				m_this->doEvent(WCH_ReturnCamera);
				//crCanvasNode *lenCanvas = crFilterRenderManager::getInstance()->findCanvas("LenCanvas");
				//if(lenCanvas && !lenCanvas->getVisiable())
				//{
				//	crFilterRenderManager::getInstance()->showCanvas(lenCanvas,true);
				//	lenCanvas->doEvent(WCH_LenFadeInit,MAKEINT64(MAKERGBA(0,0,0,255),m_updateVisitor.get()));
				//	short speed = 200;
				//	short timeDelay = 500;
				//	lenCanvas->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_LenFade,MAKEINT32(speed,timeDelay)));
				//}
				//cameraBorrowTime = 0.0f;
				//cameraBorrowInterval = 0.0f;
				//data->inputParam(WCHDATA_CameraBorrowTime,&cameraBorrowTime);
				//data->inputParam(WCHDATA_CameraBorrowInterval,&cameraBorrowInterval);
			}
		}
	}
}
/////////////////////////////////////////
//
//crReturnCameraMethod
//
/////////////////////////////////////////
crReturnCameraMethod::crReturnCameraMethod(){}
crReturnCameraMethod::crReturnCameraMethod(const crReturnCameraMethod& handle):
crMethod(handle)
{
}
void crReturnCameraMethod::inputParam(int i, void *param)
{
}

void crReturnCameraMethod::addParam(int i, const std::string& str)
{
}

void crReturnCameraMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	crCamera *camera = crCameraManager::getInstance()->getCurrentCamera();
	crCamera *mainCamera = crCameraManager::getInstance()->getMainCamera();
	if(camera!=mainCamera)
	{
		crNode *borrowerNode = camera->getAttachedNode();
		if(dynamic_cast<crMatrixTransform *>(borrowerNode))
		{
			crMatrixTransform *matrixNode = dynamic_cast<crMatrixTransform *>(borrowerNode);
			crAnimationPathCallback *animationPathCallback = dynamic_cast<crAnimationPathCallback *>(matrixNode->getUpdateCallback("AnimationPath"));
			if(animationPathCallback)
			{
				animationPathCallback->setPause(true);
			}
		}
		else if(dynamic_cast<crDOFTransform *>(borrowerNode))
		{
			crDOFTransform *dofNode = dynamic_cast<crDOFTransform *>(borrowerNode);
			dofNode->setAnimationOn(false);
		}

		crViewer *viewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
		viewer->setViewCameraNode(mainCamera);

		ref_ptr<crCanvasNode>lenCanvas = crFilterRenderManager::getInstance()->findCanvas("LenCanvas");
		if(lenCanvas.valid() && !lenCanvas->getVisiable())
		{
			//crFilterRenderManager::getInstance()->showCanvas(lenCanvas,true);
			//lenCanvas->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_LenFadeInit,MAKERGBA(0,0,0,255)));
			//short speed = 200;
			//short timeDelay = 500;
			//lenCanvas->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_LenFade,MAKEINT32(speed,timeDelay)));
			crVector4 color(0.0f,0.0f,0.0f,1.0f);
			lenCanvas->doEvent(WCH_LenFadeInit,MAKEINT64(&color,NULL));
		}

		float cameraBorrowTime = 0.0f;
		float cameraBorrowInterval = 0.0f;
		crNode *cameraNode = mainCamera->getAttachedNode();
		crData *data = cameraNode->getDataClass();
		data->inputParam(WCHDATA_CameraBorrowTime,&cameraBorrowTime);
		data->inputParam(WCHDATA_CameraBorrowInterval,&cameraBorrowInterval);
		camera->getAttachedNode()->doEvent(WCH_ReturnCamera);
		cancelTask = false;
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crExecuteActionMethod
//
/////////////////////////////////////////
crExecuteActionMethod::crExecuteActionMethod():
m_itemid(0){}
crExecuteActionMethod::crExecuteActionMethod(const crExecuteActionMethod& handle):
crMethod(handle),
m_itemid(handle.m_itemid),
m_anim(handle.m_anim)
{
}
void crExecuteActionMethod::inputParam(int i, void *param)
{
}

void crExecuteActionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	case 1:
		m_anim = str;
		break;
	}
}

void crExecuteActionMethod::operator()(crHandle &handle)
{
	crMyPlayerData::ItemNodePair itemNodePair;
	if(crMyPlayerData::getInstance()->findInRangeItem(m_itemid,itemNodePair))
	{
		crNode *node = itemNodePair.second.get();
		if(node)
		{
			//find CreBodyNode
			CRCore::crSearchNodeBYClassNameVisitor searchByClassNameVisitor;
			searchByClassNameVisitor.setTraversalMode(crNodeVisitor::TRAVERSE_ALL_CHILDREN);
			searchByClassNameVisitor.insertClassNameId("CreBodyNode");
			node->accept(searchByClassNameVisitor);
			CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(searchByClassNameVisitor.getResult());
			if(bodyNode)
			{
				ActionRequest* action = bodyNode->getBody()->getActionPrototype( m_anim );
				if (action) 
				{
					action->setPrioritized(false);
					bodyNode->getBody()->executeAction(action, false);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crBotTurnToTargetMethod
//
/////////////////////////////////////////
crBotTurnToTargetMethod::crBotTurnToTargetMethod(){}
crBotTurnToTargetMethod::crBotTurnToTargetMethod(const crBotTurnToTargetMethod& handle):
crMethod(handle)
{
}
void crBotTurnToTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crViewMatterObject*)param;
		break;
	}
}

void crBotTurnToTargetMethod::addParam(int i, const std::string& str)
{
}

void crBotTurnToTargetMethod::operator()(crHandle &handle)
{
    if(m_this)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Item,param);
		crInstanceItem *item = (crInstanceItem *)param;
		if(!item || !item->getDataClass()) return;
		crData *itemData = item->getDataClass();
		itemData->getParam(WCHDATA_TargetPos,param);
		crVector3 targetPosition = *(crVector3*)param;
		crVector3 myPos = m_this->getTrans();
		crVector3 targetDir = targetPosition - myPos;
		targetDir[2] = 0.0f;
		targetDir.normalize();
		item->setTargetDir(targetDir);
		//float speed = 0.0f;
		//crVector3 nullpos;
		//m_this->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));//停止移动
		unsigned char itemstate = IS_Stop;
		itemData->inputParam(WCHDATA_ItemState,&itemstate);
		item->doEvent(WCH_ItemCoordToNode,MAKEINT64(m_this,crMatterObject::MD_RotMatrix));//转向拾取点
	}
}
/////////////////////////////////////////
//
//crItemTurnToMeMethod
//
/////////////////////////////////////////
crItemTurnToMeMethod::crItemTurnToMeMethod():
m_itemid(0){}
crItemTurnToMeMethod::crItemTurnToMeMethod(const crItemTurnToMeMethod& handle):
crMethod(handle),
m_itemid(handle.m_itemid)
{
}
void crItemTurnToMeMethod::inputParam(int i, void *param)
{
}

void crItemTurnToMeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}

void crItemTurnToMeMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	crMyPlayerData::ItemNodePair itemNodePair;
	if(role && crMyPlayerData::getInstance()->findInRangeItem(m_itemid,itemNodePair))
	{
		crMatrixTransform *node = dynamic_cast<crMatrixTransform *>(itemNodePair.second.get());
		if(node)
		{
			crInstanceItem *item = itemNodePair.first.get();
			crVector3 myPos(role->getPosx(),role->getPosy(),role->getPosz());
			myPos *= crGlobalHandle::gData()->gUnitScale();
			crVector3 nodePos = node->getTrans();
			crVector3 dir = myPos - nodePos;
			dir[2] = 0.0f;
			dir.normalize();
			item->setTargetDir(dir);
			item->doEvent(WCH_ItemCoordToNode,MAKEINT64(node,crMatterObject::MD_RotMatrix));
		}
	}
}
/////////////////////////////////////////
//
//crHideItemMethod
//
/////////////////////////////////////////
crHideItemMethod::crHideItemMethod():
m_itemid(0){}
crHideItemMethod::crHideItemMethod(const crHideItemMethod& handle):
crMethod(handle),
m_itemid(handle.m_itemid)
{
}
void crHideItemMethod::inputParam(int i, void *param)
{
}

void crHideItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}

void crHideItemMethod::operator()(crHandle &handle)
{
	crMyPlayerData::ItemNodePair itemNodePair;
	if(crMyPlayerData::getInstance()->findInRangeItem(m_itemid,itemNodePair))
	{
		crNode *relNode = itemNodePair.second.get();
		if(relNode)
		{
			relNode->setVisiable(false);
			relNode->setEnableIntersect(false);
			//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeOutRange,crGlobalHandle::gData()->gItemVisiableDelay()));
		}
	}
}
/////////////////////////////////////////
//
//crAdvanceSlotProgressMethod
//
/////////////////////////////////////////
crAdvanceSlotProgressMethod::crAdvanceSlotProgressMethod(){}
crAdvanceSlotProgressMethod::crAdvanceSlotProgressMethod(const crAdvanceSlotProgressMethod& handle):
crMethod(handle)
{
}
void crAdvanceSlotProgressMethod::inputParam(int i, void *param)
{
}

void crAdvanceSlotProgressMethod::addParam(int i, const std::string& str)
{
}

void crAdvanceSlotProgressMethod::operator()(crHandle &handle)
{
	crSlotProgressLogic::advance();
}
/////////////////////////////////////////
//
//crAutoPreviewImageMethod
//
/////////////////////////////////////////
crAutoPreviewImageMethod::crAutoPreviewImageMethod():
m_interval(3.0f),
m_timer(0.0f),
m_currentImage(0){}
crAutoPreviewImageMethod::crAutoPreviewImageMethod(const crAutoPreviewImageMethod& handle):
crMethod(handle),
m_interval(handle.m_interval),
m_imageFileVec(handle.m_imageFileVec),
m_timer(0.0f),
m_currentImage(0)
{
}
void crAutoPreviewImageMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_imageBoxElement = (CRGUI::crImageBoxElement*)param;
	else if(i == -3)
        m_timer += *(float*)param;
}

void crAutoPreviewImageMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	default:
		m_imageFileVec.push_back(str);
	}
}

void crAutoPreviewImageMethod::operator()(crHandle &handle)
{
	if(m_imageBoxElement.valid() && !m_imageFileVec.empty())
	{
		if(m_timer>m_interval)
		{
			m_timer = 0.0f;
			m_currentImage++;
			if(m_currentImage<m_imageFileVec.size())
			{
				const CRCore::crVector4i &rect = m_imageBoxElement->getRect();
				m_imageBoxElement->setElementImage(m_imageFileVec[m_currentImage],crVector2i(rect[2],rect[3]),crVector2i(0,0));
				m_imageBoxElement->getParentStage()->setNeedReDraw();
			}
		}
	}
}
/////////////////////////////////////////
//
//crNodeSetVisiableMethod
//
/////////////////////////////////////////
crNodeSetVisiableMethod::crNodeSetVisiableMethod():
m_nodeType(ALLNODE),
m_visiable(true),
m_node(NULL){}
crNodeSetVisiableMethod::crNodeSetVisiableMethod(const crNodeSetVisiableMethod& handle):
crMethod(handle),
m_nodeName(handle.m_nodeName),
m_nodeType(handle.m_nodeType),
m_visiable(handle.m_visiable),
m_node(NULL)
{
}
void crNodeSetVisiableMethod::inputParam(int i, void *param)
{
}

void crNodeSetVisiableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nodeName = str;
		break;
	case 1:
		m_nodeType = (unsigned char)atoi(str.c_str());
		break;
	case 2:
		m_visiable = (bool)atoi(str.c_str());
		break;
	}
}

void crNodeSetVisiableMethod::operator()(crHandle &handle)
{
	if(!m_node)
	{
		CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
		searchByNameVisitor.setNameId(m_nodeName);
		searchByNameVisitor.setSearchNodeType((SearchNodeType)m_nodeType);
		CRCore::crBrain::getInstance()->accept(searchByNameVisitor);
		m_node = searchByNameVisitor.getResult();
	}
	if(m_node)
	{
		m_node->setVisiable(m_visiable);
	}
}
/////////////////////////////////////////
//
//crMatrixNodeSetPositionMethod
//
/////////////////////////////////////////
crMatrixNodeSetPositionMethod::crMatrixNodeSetPositionMethod():
m_node(NULL){}
crMatrixNodeSetPositionMethod::crMatrixNodeSetPositionMethod(const crMatrixNodeSetPositionMethod& handle):
crMethod(handle),
m_nodeName(handle.m_nodeName),
m_position(handle.m_position),
m_node(NULL)
{
}
void crMatrixNodeSetPositionMethod::inputParam(int i, void *param)
{
}

void crMatrixNodeSetPositionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nodeName = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_position);
		break;
	}
}

void crMatrixNodeSetPositionMethod::operator()(crHandle &handle)
{
	if(!m_node)
	{
		CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
		searchByNameVisitor.setNameId(m_nodeName);
		searchByNameVisitor.setSearchNodeType(MATRIXTRANSFORM);
		CRCore::crBrain::getInstance()->accept(searchByNameVisitor);
		m_node = dynamic_cast<crMatrixTransform *>(searchByNameVisitor.getResult());
	}
	if(m_node)
	{
		m_node->setPosition(m_position);
	}
}
/////////////////////////////////////////
//
//crSetViewOffsetRangeMethod
//
/////////////////////////////////////////
crSetViewOffsetRangeMethod::crSetViewOffsetRangeMethod(){}
crSetViewOffsetRangeMethod::crSetViewOffsetRangeMethod(const crSetViewOffsetRangeMethod& handle):
crMethod(handle),
m_range(handle.m_range)
{
}
void crSetViewOffsetRangeMethod::inputParam(int i, void *param)
{
}

void crSetViewOffsetRangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_range);
		break;
	}
}

void crSetViewOffsetRangeMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	if(role)
	{
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(role->getRelNode());
		if(bot) bot->setViewOffsetRange(m_range);
	}
}
/////////////////////////////////////////
//
//crStopSoundMethod
//
/////////////////////////////////////////
crStopSoundMethod::crStopSoundMethod(){}
crStopSoundMethod::crStopSoundMethod(const crStopSoundMethod& handle):
crMethod(handle)
{
}
void crStopSoundMethod::inputParam(int i, void *param)
{
}

void crStopSoundMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_soundName = str;
		break;
	}
}

void crStopSoundMethod::operator()(crHandle &handle)
{
	crSound *sound = CRSound::crSoundSystem::getInstance()->findSound(m_soundName);
    if(sound && sound->getChannel())
	{
		sound->getChannel()->setPaused(true);
	}
}
/////////////////////////////////////////
//
//crSetNodeMaterialMethod
//
/////////////////////////////////////////
crSetNodeMaterialMethod::crSetNodeMaterialMethod():
m_init(false){}
crSetNodeMaterialMethod::crSetNodeMaterialMethod(const crSetNodeMaterialMethod& handle):
crNodeMethod(handle),
m_init(false),
m_diffuse(handle.m_diffuse),
m_emissive(handle.m_emissive)
{
}
void crSetNodeMaterialMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}

void crSetNodeMaterialMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_diffuse);
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_emissive);
		break;
	}
}

void crSetNodeMaterialMethod::operator()(crHandle &handle)
{
	if(!m_init)
	{
		m_material = new CRCore::crMaterial;
		m_material->setDiffuse(crMaterial::FRONT_AND_BACK,m_diffuse);
		m_material->setEmission(crMaterial::FRONT_AND_BACK,m_emissive);
		//m_material->setSpecular(crMaterial::FRONT_AND_BACK,crVector4(0.5,0.5,0.5,1.0));
		//m_material->setShininess(crMaterial::FRONT_AND_BACK,32.0);
		m_stateset = new CRCore::crStateSet;
		m_stateset->setAttribute(m_material.get(),crStateAttribute::OVERRIDE|crStateAttribute::ON);

		m_init = true;
	}
	if(m_this)
	    m_this->setStateSet(m_stateset.get());
}
void crSetNodeMaterialMethod::releaseObjects(crState* state)
{
    m_stateset = NULL;
	m_material = NULL;
	m_init = false;
}

/////////////////////////////////////////
//
//crRemoveNodeMaterialMethod
//
/////////////////////////////////////////
crRemoveNodeMaterialMethod::crRemoveNodeMaterialMethod(){}
crRemoveNodeMaterialMethod::crRemoveNodeMaterialMethod(const crRemoveNodeMaterialMethod& handle):
crMethod(handle)
{
}
void crRemoveNodeMaterialMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}

void crRemoveNodeMaterialMethod::addParam(int i, const std::string& str)
{
}

void crRemoveNodeMaterialMethod::operator()(crHandle &handle)
{
	m_this->setStateSet(NULL);
}
/////////////////////////////////////////
//
//crRunFrequencyControlMethod
//
/////////////////////////////////////////
crRunFrequencyControlMethod::crRunFrequencyControlMethod():
m_interval(0.0f),
m_time(0.0f),
m_dt(NULL){}
crRunFrequencyControlMethod::crRunFrequencyControlMethod(const crRunFrequencyControlMethod& handle):
crMethod(handle),
m_interval(handle.m_interval),
m_time(0.0f),
m_dt(NULL)
{
}
void crRunFrequencyControlMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crRunFrequencyControlMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}

void crRunFrequencyControlMethod::operator()(crHandle &handle)
{
	bool taskCanceled = true;
	float dt = m_dt?*m_dt:crFrameStamp::getInstance()->getFrameInterval();
	if(m_time + dt > m_interval)
	{
		if(m_dt) *m_dt += m_time;
		m_time = 0.0f;
        taskCanceled = false;
	}
	else
	{
		m_time += dt;
	}
	handle.outputParam(0,&taskCanceled);
}
/////////////////////////////////////////
//
//crMouseFrequencyControlMethod
//
/////////////////////////////////////////
crMouseFrequencyControlMethod::crMouseFrequencyControlMethod():
	m_interval(0.0f),
	m_lastupdtime(0.0f),
	m_time(0.0f){}
crMouseFrequencyControlMethod::crMouseFrequencyControlMethod(const crMouseFrequencyControlMethod& handle):
	crMethod(handle),
	m_interval(handle.m_interval),
	m_lastupdtime(0.0f),
	m_time(0.0f)
{
}
void crMouseFrequencyControlMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			crGUIEventAdapter *ea = (crGUIEventAdapter *)(LOINT64(param64));
			m_time = ea->time();
		}
		else
		{
			m_time = 0.0f;
		}
		break;
	}
}

void crMouseFrequencyControlMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}

void crMouseFrequencyControlMethod::operator()(crHandle &handle)
{
	if(m_time-m_lastupdtime<m_interval)
	{
		bool taskCanceled = true;
		handle.outputParam(0,&taskCanceled);
	}
	else
		m_lastupdtime = m_time;
}
/////////////////////////////////////////
//
//crSetNodeColorMethod
//
/////////////////////////////////////////
crSetNodeColorMethod::crSetNodeColorMethod(){}
crSetNodeColorMethod::crSetNodeColorMethod(const crSetNodeColorMethod& handle):
crMethod(handle),
m_color(handle.m_color)
{
}
void crSetNodeColorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}

void crSetNodeColorMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_color);
		m_setColorVisitor.setColor(m_color);
		break;
	}
}

void crSetNodeColorMethod::operator()(crHandle &handle)
{
    if(m_this)
	{
		m_this->accept(m_setColorVisitor);
	}
}
/////////////////////////////////////////
//
//crServerReadPathMethod
//
/////////////////////////////////////////
crServerReadPathMethod::crServerReadPathMethod():
m_dt(0.0f){}
crServerReadPathMethod::crServerReadPathMethod(const crServerReadPathMethod& handle):
crMethod(handle),
m_dt(handle.m_dt)
{
}
void crServerReadPathMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crServerReadPathMethod::addParam(int i, const std::string& str)
{
}

void crServerReadPathMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_RTHP,param);
		float rthp = *(float *)param;
		if(rthp>0.0f)
		{//!=IS_Dead
			data->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *((unsigned char*)param);
			if(itemstate >= IS_Move)
			{
				unsigned char stats = m_this->getOrCreatePathFinder()->getPathStatus();
				if(stats==crInstanceItem::crPathFinder::Found||stats==crInstanceItem::crPathFinder::ReFound)
				{
					float speed = 0;
					m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
					float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
					if(scene)
					{
						float distance = relspeed * m_dt;//(m_dt+delay);
						float dt = m_dt;
						do
						{
							if(m_this->getOrCreatePathFinder()->readPath(m_this,scene,distance,dt))
							{
								dt = 0.0f;
							}
							else
							{
								break;
							}
						}while(distance>0.0f);
					}
				}
				else if(stats!=crInstanceItem::crPathFinder::NotStarted && itemstate != IS_MoveToUseSkill && itemstate != IS_CloseTargetUseSkill)
				{
					itemstate = IS_Stop;
					data->inputParam(WCHDATA_ItemState,&itemstate);
					m_this->getOrCreatePathFinder()->setPathStatus(crInstanceItem::crPathFinder::NotStarted);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crClientReadPathMethod
//
/////////////////////////////////////////
crClientReadPathMethod::crClientReadPathMethod():
m_dt(0.0f){}
crClientReadPathMethod::crClientReadPathMethod(const crClientReadPathMethod& handle):
crMethod(handle),
m_dt(0.0f)
{
}
void crClientReadPathMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crClientReadPathMethod::addParam(int i, const std::string& str)
{
}

void crClientReadPathMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f)
	{
		//if(!m_characterUpdateMethod.valid())
		//{
		//	m_characterUpdateMethod = dynamic_cast<crRpgGameCharacterUpdateMethod *>(m_this->getHandle(WCH_UPDATEVISITOR,"RpgGameCharacterUpdate"));
		//}
		//crRpgGameCharacterUpdateMethod::Move movestate = crRpgGameCharacterUpdateMethod::StopMove;
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_RTHP,param);
		float rthp = *(float *)param;
		if(rthp>0.0f)
		{
			data->getParam(WCHDATA_CurActState,param);
			unsigned short act = *(unsigned short *)param;
			data->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *((unsigned char*)param);
			if(act != ACT_Skill && itemstate >= IS_Move && itemstate<IS_Defend)
			{
				unsigned char stats = m_this->getOrCreatePathFinder()->getPathStatus();
				if(stats==crInstanceItem::crPathFinder::Found||stats==crInstanceItem::crPathFinder::ReFound)
				{
					float speed = 0;
					m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
					float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
					CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
					float distance = relspeed * m_dt;//(m_dt+reduce);
					bool moveAct = false;
					float dt = m_dt;
					do
					{
						if(m_this->getOrCreatePathFinder()->readPath(m_this,scene,distance,dt))
						{
							moveAct = true;
							dt = 0.0f;
						}
						else
						{
							break;
						}
					}while(distance>0.0f);
					if(moveAct)
					{
						float duration = -1.0f;
						m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Move,&duration));
					}
				}
				else if(stats!=crInstanceItem::crPathFinder::NotStarted && itemstate != IS_MoveToUseSkill && itemstate != IS_CloseTargetUseSkill)
				{
					itemstate = IS_Stop;
					data->inputParam(WCHDATA_ItemState,&itemstate);
					m_this->getOrCreatePathFinder()->setPathStatus(crInstanceItem::crPathFinder::NotStarted);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crCloseToSyncPositionMethod
//
/////////////////////////////////////////
crCloseToSyncPositionMethod::crCloseToSyncPositionMethod():
	m_dt(0.0f){}
crCloseToSyncPositionMethod::crCloseToSyncPositionMethod(const crCloseToSyncPositionMethod& handle):
	crMethod(handle),
	m_dt(0.0f)
{
}
void crCloseToSyncPositionMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crCloseToSyncPositionMethod::addParam(int i, const std::string& str)
{
}

void crCloseToSyncPositionMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_dt>0.0f && m_this->hasSyncPos())
	{
		CRNetApp::crScene *scene = NULL;
		if(crGlobalHandle::isClient())
		{
			scene = crMyPlayerData::getInstance()->getScene();
		}
		else
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			scene = netCallback->findScene(m_this->getSceneID());
		}
		if(scene)
		{
			float speed = 0;
			crData *data = m_this->getDataClass();
			//data->excHandle(MAKEINT64(WCH_LockData,1));//防止阻塞
			m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
			//data->excHandle(MAKEINT64(WCH_LockData,0));//防止阻塞
			float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
			float distance = relspeed * m_dt;
			m_this->closeToSyncPos(scene,distance);
			if(crGlobalHandle::isClient())
			{
				float duration = -1.0f;
				m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Move,&duration));
			}
		}
	}
}
////////////////////////////////
//
//crItemCutTalkMethod
//
///////////////////////////////////
crItemCutTalkMethod::crItemCutTalkMethod():
m_talkid(0)
{}

crItemCutTalkMethod::crItemCutTalkMethod(const crItemCutTalkMethod& handle):
crMethod(handle),
m_talkid(handle.m_talkid)
{
}

void crItemCutTalkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crItemCutTalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_talkid = (unsigned short)(atoi(str.c_str()));
		break;
	}
}

void crItemCutTalkMethod::operator()(crHandle &handle)
{
	crNode *bot = m_this->getRelNode();
	if(bot)
		bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(MAKEINT32(WCH_CutTalk,m_talkid),MAKEINT32(0,0)));
}
////////////////////////////////
//
//crItemCutSceneMethod
//
///////////////////////////////////
crItemCutSceneMethod::crItemCutSceneMethod():
m_id(0)
{}

crItemCutSceneMethod::crItemCutSceneMethod(const crItemCutSceneMethod& handle):
crMethod(handle),
m_id(handle.m_id)
{
}

void crItemCutSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crItemCutSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = (unsigned short)(atoi(str.c_str()));
		break;
	}
}

void crItemCutSceneMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		crNode *bot = m_this->getRelNode();
		if(bot)
			bot->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(MAKEINT32(WCH_CutScene,m_id),MAKEINT32(0,0)));
	}
	//这里不需要同步给客户端，这是消息触发的结果，其他客户端收到相应消息也会触发
	//if(m_this == crMyPlayerData::getInstance()->getRole())
	//{
	//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	//	if(netConductor)
	//	{
	//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
	//		stream->createBuf(2);
	//		stream->_writeUShort(m_id);
	//		crPlayerEventPacket packet;
	//		crPlayerEventPacket::buildRequestPacket(packet,WCH_RecvPlayerCutScene,stream.get());
	//		netConductor->getNetManager()->sendPacket("all",packet);
	//	}
	//}
}
/////////////////////////////////////////
//
//crCutShowNodeMethod
//
/////////////////////////////////////////
crCutShowNodeMethod::crCutShowNodeMethod():m_visiable(false),m_intersectable(false){}
crCutShowNodeMethod::crCutShowNodeMethod(const crCutShowNodeMethod& handle):
crMethod(handle),
m_visiable(false),m_intersectable(false)
{
}
void crCutShowNodeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}
void crCutShowNodeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_visiable = (bool)(atoi(str.c_str()));
		break;
	case 1:
		m_intersectable = (bool)(atoi(str.c_str()));
		break;
	}
}
void crCutShowNodeMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		m_this->setVisiable(m_visiable);
		m_this->setEnableIntersect(m_intersectable);
	}
}
/////////////////////////////////////////
//
//crItemSetActStateMethod
//
/////////////////////////////////////////
crItemSetActStateMethod::crItemSetActStateMethod():
m_specActState(0),
m_actDuration(0.0f){}
crItemSetActStateMethod::crItemSetActStateMethod(const crItemSetActStateMethod& handle):
crMethod(handle),
m_specActState(handle.m_specActState),
m_actDuration(handle.m_actDuration)
{
}
void crItemSetActStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crNode*)param;
		break;
	}
}

void crItemSetActStateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_specActState = (unsigned short)(atoi(str.c_str()));
		break;
	case 1:
		m_actDuration = atof(str.c_str());
		break;
	}
}

void crItemSetActStateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_Item,param);
	crInstanceItem *item = ((crInstanceItem*)param);
	if(item && item->getDataClass())
	{
		crData *itemData = item->getDataClass();
		itemData->inputParam(WCHDATA_CurActState,&m_specActState);
		itemData->inputParam(WCHDATA_CurActDuration,&m_actDuration);
	}
}
/////////////////////////////////////////
//
//crChangeActStateMethod
//
/////////////////////////////////////////
crChangeActStateMethod::crChangeActStateMethod():
	m_actState(0),
	m_actDuration(2.0f){}
crChangeActStateMethod::crChangeActStateMethod(const crChangeActStateMethod& handle):
	crMethod(handle),
	m_actState(handle.m_actState),
	m_actDuration(handle.m_actDuration)
{
}
void crChangeActStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_actState = LOINT32(LOINT64(param64));
			m_actDuration = *(float *)(HIINT64(param64));
		}
		break;
	}
}

void crChangeActStateMethod::addParam(int i, const std::string& str)
{
}

void crChangeActStateMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_CurActState,param);
	unsigned short* act = (unsigned short *)param;
	do 
	{
		if(*act == m_actState)
			break;
		if(m_actState != ACT_Dead/* && m_actState != ACT_Skill*/)
		{//死亡动作和施法动作优先
			if(*act == ACT_Dead)
			{
				data->getParam(WCHDATA_RTHP,param);
				float *rthp = (float *)param;
				if(rthp && *rthp>0.0f)
				{//已经复活
					data->inputParam(WCHDATA_CurActState,&m_actState);
					data->inputParam(WCHDATA_CurActDuration,&m_actDuration);
				}
				//else if(m_actState == ACT_None)
				//{
				//	data->inputParam(WCHDATA_CurActState,&m_actState);
				//	data->inputParam(WCHDATA_CurActDuration,&m_actDuration);
				//}
				break;
			}
			else if(*act == ACT_Skill)
			{//施法动作不被打断
				//if(*act != ACT_Move)
				break;
			}
			if(m_actState!=ACT_Skill)
			{//施法动作优先
				if(*act == ACT_Attack || *act == ACT_CritAttack || *act == ACT_NearAttack)
				{//攻击动作不被打断
					//if(m_actState == ACT_Hurt || m_actState == ACT_Parry || m_actState == ACT_Dodge || m_actState == ACT_Move)
					//{
					//	break;
					//}
					break;
				}
				else if(*act == ACT_Parry || *act == ACT_Dodge)
				{
					if(m_actState == ACT_Hurt)
					{//受击动作不打断格挡和闪避动作
						break;
					}
				}
			}
		}
		data->getParam(WCHDATA_ActStateMap,param);
		ActStateMap *actStateMap = (ActStateMap *)param;
		if(actStateMap->find(m_actState) != actStateMap->end())
		{
			data->inputParam(WCHDATA_CurActState,&m_actState);
			data->inputParam(WCHDATA_CurActDuration,&m_actDuration);
		}
	} while (0);
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
////////////////////////////////
//
//crItemControllerMethod
//
///////////////////////////////////
crItemControllerMethod::crItemControllerMethod():
m_control(CF_Stop)
{}

crItemControllerMethod::crItemControllerMethod(const crItemControllerMethod& handle):
crMethod(handle),
m_control(handle.m_control)
{
}

void crItemControllerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crItemControllerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_control = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crItemControllerMethod::operator()(crHandle &handle)
{
	if(!m_this) return;
	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_ControllerFlg,param);
	unsigned char flg = *(unsigned char*)param;
	if(flg != m_control)
	{
		if(m_control == CF_Stop)
		{
			unsigned char itemstate = IS_Stop;
			data->inputParam(WCHDATA_ItemState,&itemstate);
		}
		else
		{
			crVector3 currentPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
			currentPos *= crGlobalHandle::gData()->gUnitScale();
			data->inputParam(WCHDATA_TargetPos,&currentPos);
			unsigned char targetType = Target_Coord;
			data->inputParam(WCHDATA_TargetType,&targetType);
		}
		data->inputParam(WCHDATA_ControllerFlg,&m_control);
	}
}
/////////////////////////////////////////
//
//crDoItemControllerAndSendMethod
//
/////////////////////////////////////////
crDoItemControllerAndSendMethod::crDoItemControllerAndSendMethod():
m_dt(0.0f),
m_length(10.0f){}
crDoItemControllerAndSendMethod::crDoItemControllerAndSendMethod(const crDoItemControllerAndSendMethod& handle):
crMethod(handle),
m_dt(0.0f),
m_length(handle.m_length)
{
}
void crDoItemControllerAndSendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}
void crDoItemControllerAndSendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_length = atof(str.c_str());
		break;
	}
}
void crDoItemControllerAndSendMethod::operator()(crHandle &handle)
{
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview && bindview->isInited() && crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_ControllerFlg,param);
		unsigned char control = *(unsigned char*)param;
		if(control > CF_Stop)
		{
			unsigned char itemstate = IS_Move;
			data->inputParam(WCHDATA_ItemState,&itemstate);

			data->getParam(WCHDATA_TargetPos,param);
			crVector3 targetPos = *(crVector3 *)param;
			crVector3 currentPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
			currentPos *= crGlobalHandle::gData()->gUnitScale();
			if((targetPos - currentPos).length() < m_length * 0.2f)
			{
				crVector3 newTargetPos;
				crVector3 trans;
				switch(control)
				{
				case CF_Up:
					trans.set(0,0,-1);
					break;
				case CF_Down:
					trans.set(0,0,1);
					break;
				case CF_Left:
					trans.set(-1,0,0);
					break;
				case CF_Right:
					trans.set(1,0,0);
					break;
				}
				crMatrix viewMat = bindview->getViewMatrix();
				viewMat.setTrans(0.0f,0.0f,0.0f);
				trans = viewMat * trans;
				trans[2] = 0.0f;
				newTargetPos = currentPos + trans * m_length;
				newTargetPos[2] = 0.0f;
				
				data->inputParam(WCHDATA_TargetPos,&newTargetPos);
				crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
				//send to net
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(14);
				stream->_writeUChar(Target_Coord);//1
				stream->_writeVec3(newTargetPos);//12
				stream->_writeUChar(itemstate);//1

				//stream->_writeInt(m_this->getPosx());//4
				//stream->_writeInt(m_this->getPosy());//4
				//stream->_writeInt(m_this->getPosz());//4
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_NetControl,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crPlayerFindPathToMethod
//
/////////////////////////////////////////
crPlayerFindPathToMethod::crPlayerFindPathToMethod(){}
crPlayerFindPathToMethod::crPlayerFindPathToMethod(const crPlayerFindPathToMethod& handle):
crMethod(handle),
m_waypoints(handle.m_waypoints)
{
}
void crPlayerFindPathToMethod::inputParam(int i, void *param)
{
}
void crPlayerFindPathToMethod::addParam(int i, const std::string& str)
{
	if(i%4 == 0)
	{
		crVector2i scene;
		crArgumentParser::appAtoVec(str,scene);
		m_loadpoint.m_sceneid = scene[0];
		m_loadpoint.m_layerid = scene[1];
		m_loadpoint.m_msg = NULL;
		m_loadpoint.m_param = NULL;
	}
	if(i%4 == 1)
	{
		crVector2 point;
		crArgumentParser::appAtoVec(str,point);
		m_loadpoint.m_coord.set(point[0],point[1],0.0f);
	}
	else if(i%4 == 2)
	{
		std::string str1,str2;
		std::string::size_type comma = str.find_first_of(',');
		str1 = std::string(str.begin(),str.begin()+comma);
		str2 = std::string(str.begin()+comma + 1,str.end());
		m_loadpoint.m_msg = MAKEINT64(parseEventMsg(str1),parseEventMsg(str2));
	}
	else if(i%4 == 3)
	{
		crVector2i vec2;
		crArgumentParser::appAtoVec(str,vec2);
		m_loadpoint.m_param = MAKEINT64(vec2[0],vec2[1]);
		m_waypoints.push_back(m_loadpoint);
	}
}
void crPlayerFindPathToMethod::operator()(crHandle &handle)
{
	crRole *player = crMyPlayerData::getInstance()->getCurrentRole();
	if(!m_waypoints.empty() && player)
	{
		crScene *scene = crMyPlayerData::getInstance()->getScene();
		crInstanceItem::crPathFinder *pathfinder = player->getOrCreatePathFinder();
		pathfinder->dirty();
		crInstanceItem::WayPoint waypoint;
		if(player->getSceneID() != m_waypoints[0].m_sceneid || player->getLayerID() != m_waypoints[0].m_layerid)
		{//寻路至传送点
			crSceneLayer *scenelayer = scene->getSceneLayer(player->getLayerID());
			crVector2 transport = scenelayer->getTransportCoord();
			if(transport!=crVector2(0.0f,0.0f))
			{
				waypoint.m_coord.set(transport[0],transport[1],0.0f);
				waypoint.m_sceneid = player->getSceneID();
				waypoint.m_layerid = player->getLayerID();
				waypoint.m_msg = WCH_ITransport;
				waypoint.m_param = MAKEINT64(m_waypoints[0].m_sceneid,m_waypoints[0].m_layerid);
				//pathfinder->clearWaypointDeque();
				pathfinder->addWaypoint(waypoint);
			}
			else
			{//
				//std::string str = "所在场景不支持跨图寻路";
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(26,NULL));
				return;
			}
		}
		else
		{
			waypoint = m_waypoints[0];
			//pathfinder->clearWaypointDeque();
		}

		for(int i = 0; i<m_waypoints.size(); i++)
		{
			pathfinder->addWaypoint(m_waypoints[i]);
		}

		crData *data = player->getDataClass();
		unsigned char itemstate = IS_Move;
		data->inputParam(WCHDATA_ItemState,&itemstate);
		data->inputParam(WCHDATA_TargetPos,&(waypoint.m_coord));
		unsigned char targettype = Target_Coord;
		data->inputParam(WCHDATA_TargetType,&targettype);

		crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addWaypointFindRequest(player);
		//send to net
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(13+m_waypoints.size() * 34);
			stream->_writeInt(player->getPosx());//4
			stream->_writeInt(player->getPosy());//4
			stream->_writeInt(player->getPosz());//4
			stream->_writeUChar(m_waypoints.size());//1
			for(int i = 0; i<m_waypoints.size(); i++)
			{
				stream->_writeInt(m_waypoints[i].m_sceneid);//4
				stream->_writeUShort(m_waypoints[i].m_layerid);//2
				stream->_writeVec3(m_waypoints[i].m_coord);//12
				stream->_writeInt64(m_waypoints[i].m_msg);//8
				stream->_writeInt64(m_waypoints[i].m_param);//8
			}
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,player,WCH_RecvFindPathTo,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvFindPathToMethod
//
/////////////////////////////////////////
crRecvFindPathToMethod::crRecvFindPathToMethod():
m_netType(GameClient_Game){}
crRecvFindPathToMethod::crRecvFindPathToMethod(const crRecvFindPathToMethod& handle):
crMethod(handle)
{
}
void crRecvFindPathToMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvFindPathToMethod::addParam(int i, const std::string& str)
{
}

void crRecvFindPathToMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		crScene *scene=NULL;
		if(m_netType == GameClient_Game)
			scene = crMyPlayerData::getInstance()->getScene();
		else if(m_netType == SceneServer)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			scene = netCallback->findScene(m_this->getSceneID());
		}
		if(scene)
		{
			m_this->setPosxy(m_stream->_readVec2i());
			m_this->setPosz(m_stream->_readInt());
			unsigned char count = m_stream->_readUChar();
			crInstanceItem::crPathFinder *pathfinder = m_this->getOrCreatePathFinder();
			pathfinder->dirty();
			crInstanceItem::WayPoint waypoint,waypoint0;
			waypoint0.m_sceneid = m_stream->_readInt();
			waypoint0.m_layerid = m_stream->_readUShort();
			waypoint0.m_coord = m_stream->_readVec3();
			waypoint0.m_msg = m_stream->_readInt64();
			waypoint0.m_param = m_stream->_readInt64();
			if(m_this->getSceneID() != waypoint0.m_sceneid || m_this->getLayerID() != waypoint0.m_layerid)
			{//寻路至传送点
				crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
				crVector2 transport = scenelayer->getTransportCoord();
				if(transport!=crVector2(0.0f,0.0f))
				{
					waypoint.m_coord.set(transport[0],transport[1],0.0f);
					waypoint.m_sceneid = m_this->getSceneID();
					waypoint.m_layerid = m_this->getLayerID();
					waypoint.m_msg = WCH_ITransport;
					waypoint.m_param = MAKEINT64(waypoint0.m_sceneid,waypoint0.m_layerid);
					//pathfinder->clearWaypointDeque();
					pathfinder->addWaypoint(waypoint);
					pathfinder->addWaypoint(waypoint0);
				}
				else
				{//
					if(m_netType == GameClient_Game)
					{
						//std::string str = "所在场景不支持跨图寻路";
						crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(26,NULL));
					}
					return;
				}
			}
			else
			{
				waypoint = waypoint0;
				//pathfinder->clearWaypointDeque();
				pathfinder->addWaypoint(waypoint0);
			}
			crData *data = m_this->getDataClass();
			unsigned char itemstate = IS_Move;
			data->inputParam(WCHDATA_ItemState,&itemstate);
			data->inputParam(WCHDATA_TargetPos,&(waypoint.m_coord));
			unsigned char targettype = Target_Coord;
			data->inputParam(WCHDATA_TargetType,&targettype);

			for(unsigned char i = 1; i<count; i++)
			{
				waypoint.m_sceneid = m_stream->_readInt();
				waypoint.m_layerid = m_stream->_readUShort();
				waypoint.m_coord = m_stream->_readVec3();
				waypoint.m_msg = m_stream->_readInt64();
				waypoint.m_param = m_stream->_readInt64();

				pathfinder->addWaypoint(waypoint);
			}
			if(m_netType == GameClient_Game)
				crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addWaypointFindRequest(m_this);
			else if(m_netType == SceneServer)
			{
				scene->getPathFindingManager()->addWaypointFindRequest(m_this);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvItemStateMethod
//
/////////////////////////////////////////
crRecvItemStateMethod::crRecvItemStateMethod():
m_netType(GameClient_Game){}
crRecvItemStateMethod::crRecvItemStateMethod(const crRecvItemStateMethod& handle):
crMethod(handle)
{
}
void crRecvItemStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvItemStateMethod::addParam(int i, const std::string& str)
{
}

void crRecvItemStateMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_Dead)
		{
			return;
		}
		unsigned char newitemstate = m_stream->_readUChar();
		//if(!m_stream->eof())
		//{
		//	if(newitemstate == IS_Stop)
		//	{
		//		unsigned char targettype = m_stream->_readUChar();
		//		data->inputParam(WCHDATA_TargetType,&targettype);
		//	}
		//	else if(newitemstate >= IS_CloseTarget && newitemstate <= IS_CloseTargetTouch)
		//	{
		//		float dist = m_stream->_readFloat();
		//		data->inputParam(WCHDATA_FollowDistance,&dist);
		//	}
		//}
		data->inputParam(WCHDATA_ItemState,&newitemstate);
	}
}
/////////////////////////////////////////
//
//crPlayerTransportMethod
//
/////////////////////////////////////////
crPlayerTransportMethod::crPlayerTransportMethod():
m_sceneid(0),
m_layerid(0){}
crPlayerTransportMethod::crPlayerTransportMethod(const crPlayerTransportMethod& handle):
crMethod(handle),
m_sceneid(handle.m_sceneid),
m_layerid(handle.m_layerid),
m_coord(handle.m_coord)
{
}
void crPlayerTransportMethod::inputParam(int i, void *param)
{
}
void crPlayerTransportMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sceneid = atoi(str.c_str());
		break;
	case 1:
		m_layerid = (unsigned short)(atoi(str.c_str()));
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_coord);
		break;
	}
}
void crPlayerTransportMethod::operator()(crHandle &handle)
{
	crRole *player = crMyPlayerData::getInstance()->getCurrentRole();
	crData *data = player->getDataClass();

	//crNode *node = NULL;
	//crGroup *group = dynamic_cast<crGroup *>(player->getNode());
	//if(group)
	//	node = group->getChild(0);
	//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeOutRange,crGlobalHandle::gData()->gItemVisiableDelay()));

	unsigned char itemstate = IS_Stop;
	data->inputParam(WCHDATA_ItemState,&itemstate);

	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(14);
	stream->_writeInt(m_sceneid);//
	stream->_writeUShort(m_layerid);//
	//if(m_sceneid == player->getSceneID())
	stream->_writeVec2(m_coord);//8
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_Transport,player,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvTargetMethod
//
/////////////////////////////////////////
crRecvTargetMethod::crRecvTargetMethod():
m_netType(GameClient_Game){}
crRecvTargetMethod::crRecvTargetMethod(const crRecvTargetMethod& handle):
crMethod(handle)
{
}
void crRecvTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvTargetMethod::addParam(int i, const std::string& str)
{
}

void crRecvTargetMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		crData *thisData = m_this->getDataClass();
		unsigned char targetType = m_stream->_readUChar();
		crVector3 targetPosition;
		if(targetType & Target_Instance || targetType & Target_Self || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
		{
			int targetid = m_stream->_readInt();
			thisData->inputParam(WCHDATA_TargetID,&targetid);
			if(targetType & Target_Role)
			{
				int targetroleid = m_stream->_readInt();
				thisData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
			}
			ref_ptr<crInstanceItem>targetItem;
			if(m_netType == GameClient_Game)
			{
				ref_ptr<crMatrixTransform>targetNode;
				m_this->clientGetTarget(targetItem,targetNode);
				//thisData->inputParam(WCHDATA_TargetNode,targetNode.get());
				if(targetItem.valid())
				{
					targetPosition.set(targetItem->getPosx(),targetItem->getPosy(),targetItem->getPosz());
					targetPosition *= crGlobalHandle::gData()->gUnitScale();
					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
				}
			}
			else if(m_netType == SceneServer)
			{
				targetItem = m_this->serverGetTarget();
				if(targetItem.valid())
				{
					targetPosition.set(targetItem->getPosx(),targetItem->getPosy(),targetItem->getPosz());
					targetPosition *= crGlobalHandle::gData()->gUnitScale();
					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
				}
			}
		}
		else
		{
			targetPosition = m_stream->_readVec3();
			thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
		}
		thisData->inputParam(WCHDATA_TargetType,&targetType);
	}
}
/////////////////////////////////////////
//
//crITouchMethod
//
/////////////////////////////////////////
crITouchMethod::crITouchMethod():
m_targetid(0){}
crITouchMethod::crITouchMethod(const crITouchMethod& handle):
crMethod(handle)
{
}
void crITouchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetid = LOINT64(param64);
			//m_isClient = HIINT32(HIINT64(param64)) == 1;
		}
		break;
	}
}

void crITouchMethod::addParam(int i, const std::string& str)
{
}

void crITouchMethod::operator()(crHandle &handle)
{
	if(crGlobalHandle::isClient() && crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		crMyPlayerData::ItemNodePair itemNodePair;
		if(crMyPlayerData::getInstance()->findInRangeItem(m_targetid,itemNodePair))
		{
			unsigned char targettype = Target_Item;
			crData *thisData = m_this->getDataClass();
			thisData->inputParam(WCHDATA_TargetType,&targettype);
			thisData->inputParam(WCHDATA_TargetID,&m_targetid);
			//thisData->inputParam(WCHDATA_TargetNode,itemNodePair->second.get());
			//crVector3 targetPosition(itemNodePair->first->getPosx(),itemNodePair->first->getPosy(),itemNodePair->first->getPosz());
			crVector3 targetPosition = itemNodePair.first->getPosition();
			thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeUChar(targettype);//1
				stream->_writeInt(m_targetid);//4
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvTarget,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			itemNodePair.first->doEvent(WCH_Touch);
		}
	}
}
///////////////////////////////////////////
////
////crITransportMethod
////
///////////////////////////////////////////
//crITransportMethod::crITransportMethod():
//m_sceneid(0){}
//crITransportMethod::crITransportMethod(const crITransportMethod& handle):
//crMethod(handle)
//{
//}
//void crITransportMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_sceneid = LOINT64(param64);
//			_crInt32 hparam = HIINT64(param64);
//			m_layerid = (unsigned short)(LOINT32(hparam));
//			//m_isClient = HIINT32(hparam) == 1;
//		}
//		break;
//	}
//}
//
//void crITransportMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crITransportMethod::operator()(crHandle &handle)
//{
//	if(crGlobalHandle::isClient() && crMyPlayerData::getInstance()->ifItemIsMe(m_this))
//	{
//		crData *data = m_this->getDataClass();
//
//		unsigned char itemstate = IS_Stop;
//		data->inputParam(WCHDATA_ItemState,&itemstate);
//
//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
//		stream->createBuf(14);
//		stream->_writeInt(m_sceneid);//
//		stream->_writeUShort(m_layerid);//
//		//if(m_sceneid == player->getSceneID())
//		stream->_writeVec2(crVector2(0,0));//8
//		crMyPlayerData::getInstance()->setITransport(true);
//		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//		if(netConductor)
//		{
//			crPlayerServerEventPacket packet;
//			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_Transport,m_this,stream.get());
//			netConductor->getNetManager()->sendPacket("all",packet);
//		}
//	}
//}
/////////////////////////////////////////
//
//crPlayerSetGuiseStateMethod
//
/////////////////////////////////////////
crPlayerSetGuiseStateMethod::crPlayerSetGuiseStateMethod():
m_guiseState(0){}
crPlayerSetGuiseStateMethod::crPlayerSetGuiseStateMethod(const crPlayerSetGuiseStateMethod& handle):
crMethod(handle),
m_guiseState(handle.m_guiseState)
{
}
void crPlayerSetGuiseStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crPlayerSetGuiseStateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_guiseState = (unsigned int)(atoi(str.c_str()));
		break;
	}
}

void crPlayerSetGuiseStateMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		m_this->getDataClass()->inputParam(WCHDATA_GuiseState,&m_guiseState);
		
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeUInt(m_guiseState);//
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvGuiseState,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crRecvGuiseStateMethod
//
/////////////////////////////////////////
crRecvGuiseStateMethod::crRecvGuiseStateMethod():
m_netType(GameClient_Game){}
crRecvGuiseStateMethod::crRecvGuiseStateMethod(const crRecvGuiseStateMethod& handle):
crMethod(handle)
{
}
void crRecvGuiseStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvGuiseStateMethod::addParam(int i, const std::string& str)
{
}

void crRecvGuiseStateMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		unsigned int guiseState = m_stream->_readUInt();
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_GuiseState,param);
		unsigned int lastGuiseState = *(unsigned int *)param;
		if(guiseState != lastGuiseState)
		{
			data->inputParam(WCHDATA_GuiseState,&guiseState);
			if(m_netType == GameClient_Game && m_this->getRelNode())
			{//设置显示变化
				crNode *node = m_this->getRelNode();
				if(guiseState == GS_Normal)
				{
					node->setVisiable(true);
					node->setEnableIntersect(true);
				}
				else if(guiseState & GS_UnVisiable || guiseState & GS_StaticUnVisiable)
				{
					node->setVisiable(false);
					node->setEnableIntersect(false);
					//float dt = 0.1f;
					//m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_None,&dt));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crCheckItemTouchDistanceMethod
//
/////////////////////////////////////////
crCheckItemTouchDistanceMethod::crCheckItemTouchDistanceMethod():
m_itemid(0){}
crCheckItemTouchDistanceMethod::crCheckItemTouchDistanceMethod(const crCheckItemTouchDistanceMethod& handle):
crMethod(handle),
m_itemid(handle.m_itemid)
{
}
void crCheckItemTouchDistanceMethod::inputParam(int i, void *param)
{
}
void crCheckItemTouchDistanceMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}
void crCheckItemTouchDistanceMethod::operator()(crHandle &handle)
{
	bool inDistance = false;

	crInstanceItem *item = NULL;
	crMyPlayerData::ItemNodePair itemNodePair;
	if(crMyPlayerData::getInstance()->findInRangeItem(m_itemid,itemNodePair))
	{
		item = itemNodePair.first.get();
		crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
		void *param;
		crData *itemData = item->getDataClass();
		itemData->getParam(WCHDATA_TouchDistance,param);
		unsigned short touchDistance = *(unsigned short *)param;
		float relDist = (float)touchDistance * crGlobalHandle::gData()->gUnitScale();
		
		crVector3 myPos(role->getPosx(),role->getPosy(),0.0f);
		myPos *= crGlobalHandle::gData()->gUnitScale();
		crVector3 itemPos(item->getPosx(),item->getPosy(),0.0f);
		itemPos *= crGlobalHandle::gData()->gUnitScale();
		crVector3 dir = itemPos - myPos;
		float dist = dir.length();
		inDistance = dist<=relDist;
	}
	handle.outputParam(0,&inDistance);
}
/////////////////////////////////////////
//
//crThisIsMeMethod
//
/////////////////////////////////////////
crThisIsMeMethod::crThisIsMeMethod(){}
crThisIsMeMethod::crThisIsMeMethod(const crThisIsMeMethod& handle):
crMethod(handle)
{
}
void crThisIsMeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crThisIsMeMethod::addParam(int i, const std::string& str)
{
}

void crThisIsMeMethod::operator()(crHandle &handle)
{
	bool if_else = crMyPlayerData::getInstance()->ifItemIsMe(m_this);
	handle.outputParam(0,&if_else);
}
/////////////////////////////////////////
//
//crPlayerMoveToMethod
//
/////////////////////////////////////////
crPlayerMoveToMethod::crPlayerMoveToMethod():
m_this(NULL),
m_inputPos(true){}
crPlayerMoveToMethod::crPlayerMoveToMethod(const crPlayerMoveToMethod& handle):
crMethod(handle),
m_this(NULL),
m_inputPos(handle.m_inputPos),
m_targetPos(handle.m_targetPos)
{
}
void crPlayerMoveToMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(m_inputPos && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetPos = *(crVector3*)(LOINT64(param64));
		}
		break;
	}
}
void crPlayerMoveToMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_targetPos);
		m_inputPos = false;
		break;
	}
}
void crPlayerMoveToMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		crData *data = m_this->getDataClass();
		unsigned char itemstate = IS_Move;
		data->inputParam(WCHDATA_ItemState,&itemstate);
		data->inputParam(WCHDATA_TargetPos,&m_targetPos);
		unsigned char targettype = Target_Coord;
		data->inputParam(WCHDATA_TargetType,&targettype);
		crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
		//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		//if(netConductor)
		//{
		//	ref_ptr<crStreamBuf>stream = new crStreamBuf;
		//	stream->createBuf(14);
		//	stream->_writeUChar(targettype);
		//	stream->_writeUChar(itemstate);
		//	stream->_writeVec3(m_targetPos);
		//	crPlayerEventPacket packet;
		//	crPlayerEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_NetControl2,stream.get());
		//	netConductor->getNetManager()->sendPacket("all",packet);
		//}
	}
}
/////////////////////////////////////////
//
//crGetStorageItemMapMethod
//
/////////////////////////////////////////
crGetStorageItemMapMethod::crGetStorageItemMapMethod(){}
crGetStorageItemMapMethod::crGetStorageItemMapMethod(const crGetStorageItemMapMethod& handle):
crMethod(handle)
{
}
void crGetStorageItemMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crGetStorageItemMapMethod::addParam(int i, const std::string& str)
{
}

void crGetStorageItemMapMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	if(m_this && role)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(8);
		stream->_writeInt(role->getPlayerID());
		stream->_writeInt(role->getRoleID());
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvStorageItemMap,m_this,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvStorageItemMapMethod
//
/////////////////////////////////////////
crRecvStorageItemMapMethod::crRecvStorageItemMapMethod():
m_netType(GameClient_Game){}
crRecvStorageItemMapMethod::crRecvStorageItemMapMethod(const crRecvStorageItemMapMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvStorageItemMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvStorageItemMapMethod::addParam(int i, const std::string& str)
{
}
void crRecvStorageItemMapMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				crRole *player = playerData->getRole(roleid);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1024);
				stream->_writeInt(roleid);
				void *param;
				crData *data = player->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_StorageMap,param);
				StorageMap *storageMap = (StorageMap*)param;
				if(storageMap)
				{
					stream->_writeUChar(storageMap->size());
					for( StorageMap::iterator itr = storageMap->begin();
						itr != storageMap->end();
						++itr )
					{
						stream->_writeInt(itr->first);//abstractid
						stream->_writeInt(itr->second);//itemid
					}
				}
				else
				{
					stream->_writeUChar(0);
				}
				data->getParam(WCHDATA_StorageCountMap,param);
				ItemCountMap *storageCountMap = (ItemCountMap*)param;
				if(storageCountMap)
				{
					stream->_writeUChar(storageCountMap->size());
					for( ItemCountMap::iterator itr = storageCountMap->begin();
						itr != storageCountMap->end();
						++itr )
					{
						stream->_writeInt(itr->first);//abstractid
						stream->_writeUChar(itr->second);//count
					}
				}
				else
				{
					stream->_writeUChar(0);
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));

				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvStorageItemMap,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			crRole *me = crMyPlayerData::getInstance()->getRole(m_stream->_readInt());
			if(me)
			{
				std::set<int> NeedDownloadItem;
				void *param;
				crData *data = me->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				unsigned char size = m_stream->_readUChar();
				data->getParam(WCHDATA_StorageMap,param);
				StorageMap *storageMap = (StorageMap*)param;
				if(!storageMap && size>0)
					storageMap = new StorageMap;
				if(storageMap)
				{
					storageMap->clear();
					int abstractid;
					int itemid;

					for(unsigned char i = 0; i<size; i++)
					{
						abstractid = m_stream->_readInt();
						itemid = m_stream->_readInt();
						if(!me->findChildItem(itemid))
						{//need download itemchild
							NeedDownloadItem.insert(itemid);
						}
						storageMap->insert(std::make_pair(abstractid,itemid));
					}
				}
				size = m_stream->_readUChar();
				data->getParam(WCHDATA_StorageCountMap,param);
				ItemCountMap *storageCountMap = (ItemCountMap*)param;
				if(!storageCountMap && size>0)
					storageCountMap = new ItemCountMap;
				if(storageCountMap)
				{
					storageCountMap->clear();
					int abstractid;
					unsigned char count;

					for(unsigned char i = 0; i<size; i++)
					{
						abstractid = m_stream->_readInt();
						count = m_stream->_readUChar();
						storageCountMap->insert(std::make_pair(abstractid,count));
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				if(!NeedDownloadItem.empty())
				{//
					int playerid = me->getPlayerID();
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(256);
					stream->_writeInt(playerid);
					stream->_writeUChar(NeedDownloadItem.size());
					for( std::set<int>::iterator itr = NeedDownloadItem.begin();
						itr != NeedDownloadItem.end();
						++itr )
					{
						stream->_writeInt(*itr);
					}
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvDownLoadItemChilds,me,stream.get());
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else
					m_this->doEvent(WCH_BuildStorageItemList,NULL);
			}
		}
	}
}
/////////////////////////////////////////
//
//crBuildStorageItemListMethod
//
/////////////////////////////////////////
crBuildStorageItemListMethod::crBuildStorageItemListMethod(){}
crBuildStorageItemListMethod::crBuildStorageItemListMethod(const crBuildStorageItemListMethod& handle):
crMethod(handle),
m_canvasName(handle.m_canvasName),
m_listName(handle.m_listName)
{
}
void crBuildStorageItemListMethod::inputParam(int i, void *param)
{
}
void crBuildStorageItemListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_listName = str;
		break;
	}
}
void crBuildStorageItemListMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode>listControl = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_listName));
		if(listControl.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *myData = me->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_StorageMap,param);
			StorageMap* storageMap = (StorageMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			ref_ptr<crListNode> listNode;
			myData->getParam(WCHDATA_StorageCountMap,param);
			ItemCountMap* itemCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr;
			unsigned char count;
			std::string title,title2;
			std::map<int,int> FindCount;
			std::map<int,int>::iterator FindCountItr;
			int offset;
			listControl->setListNodeCount(storageMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = listControl->getListNodeVec();
			int i = 0;
			for( StorageMap::iterator itr = storageMap->begin();
				itr != storageMap->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second!=0)
				{
					itemchild = me->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						if(!itemData)
							continue;
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;

						title = item->getIName();
						title2.clear();
						if(itr->second<0)
						{
							citr = itemCountMap->find(itr->first);
							if(citr!=itemCountMap->end())
							{
								FindCountItr = FindCount.find(itr->first);
								if(FindCountItr==FindCount.end())
								{
									FindCount[itr->first] = 1;
									count = citr->second;
								}
								else
								{
									offset = FindCountItr->second;
									for(citr++;citr!=itemCountMap->end()&&citr->first==itr->first;citr++)
									{
										offset--;
										if(offset==0)
											break;
									}
									if(offset==0)
									{
										count = citr->second;
										FindCountItr->second++;
									}
									else
									{
										count = 1;
									}
								}
								title2 = crArgumentParser::appItoa((int)count);
							}
							else
								title2 = crArgumentParser::appItoa(1);
						}
						listNodeVec[i]->setTitle(title);
						listNodeVec[i]->setTitle2(title2);
						listNodeVec[i]->setData(item);
						listNodeVec[i]->setImageName(iconfile);
						listNodeVec[i]->setVisiable(true);
					}
				}
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crInsertItemToStorageMethod
//
/////////////////////////////////////////
crInsertItemToStorageMethod::crInsertItemToStorageMethod():
m_output(NULL){}
crInsertItemToStorageMethod::crInsertItemToStorageMethod(const crInsertItemToStorageMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crInsertItemToStorageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_output = (char *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crInsertItemToStorageMethod::addParam(int i, const std::string& str)
{
}
void crInsertItemToStorageMethod::operator()(crHandle &handle)
{//返回-1失败，0覆盖，1插入
	if(m_this && m_item.valid() && m_output)
	{
		*m_output = -1;
		void *param;
		crData *thisData = m_this->getDataClass();
		int abstractid = m_item->getAbstractItemID();
		int itemid = m_item->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_StorageMap,param);
		StorageMap* storageMap = (StorageMap* )param;
		thisData->getParam(WCHDATA_MaxStorage,param);
		unsigned char maxstorage = *(unsigned char *)param;
		if(itemid<0)
		{
			StorageMap::iterator bitr = storageMap->find(abstractid);
			if(bitr == storageMap->end())
			{//没有重复的
				if(storageMap->size()<(int)maxstorage)
				{
					storageMap->insert(std::make_pair(abstractid,itemid));
					*m_output = 1;
				}
			}
			else
			{
				itemid = bitr->second;
				bool lapover = false;
				thisData->getParam(WCHDATA_StorageCountMap,param);
				ItemCountMap* storageCountMap = (ItemCountMap* )param;
				ItemCountMap::iterator citr = storageCountMap->find(abstractid);
				if(citr == storageCountMap->end())
				{
					//BackPackMap::iterator bitr = backPackMap->find(abstractid);
					for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
					{
						if(bitr->second < 0)
						{
							storageCountMap->insert(std::make_pair(abstractid,2));
							lapover = true;
							break;
						}
					}
				}
				else
				{
					int n = 0;
					for(; citr != storageCountMap->end() && citr->first == abstractid; ++citr)
					{
						if(citr->second < crGlobalHandle::gData()->gMaxLapover())
						{
							citr->second++;
							lapover = true;
							break;
						}
						else
						{
							n++;
						}
					}
					if(!lapover)
					{
						StorageMap::iterator bitr = storageMap->find(abstractid);
						for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
						{
							n--;
						}
						if(n<0)
						{
							storageCountMap->insert(std::make_pair(abstractid,2));
							lapover = true;
						}
					}
				}
				if(!lapover)
				{
					if(storageMap->size()<(int)maxstorage)
					{
						storageMap->insert(std::make_pair(abstractid,itemid));
						*m_output = 0;
					}
				}
				else
				{
					*m_output = 0;
				}
			}
		}
		else if(itemid>0)
		{
			if(storageMap->size()<(int)maxstorage)
			{
				storageMap->insert(std::make_pair(abstractid,itemid));
				*m_output = 1;
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		////////////////
	}
}
/////////////////////////////////////////
//
//crRemoveItemFromStorageMethod
//
/////////////////////////////////////////
crRemoveItemFromStorageMethod::crRemoveItemFromStorageMethod():
m_output(NULL){}
crRemoveItemFromStorageMethod::crRemoveItemFromStorageMethod(const crRemoveItemFromStorageMethod& handle):
crMethod(handle),
m_output(NULL)
{
}
void crRemoveItemFromStorageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_item = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
			m_output = (char *)(HIINT64(param64));
		}
		else
		{
			m_item = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crRemoveItemFromStorageMethod::addParam(int i, const std::string& str)
{
}
void crRemoveItemFromStorageMethod::operator()(crHandle &handle)
{//返回-1失败，0减数量，1删除
	if(m_this && m_item.valid() && m_output)
	{
		*m_output = -1;
		void *param;
		crData *thisData = m_this->getDataClass();
		int abstractid = m_item->getAbstractItemID();
		int itemid = m_item->getInstanceItemID();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_StorageMap,param);
		StorageMap* storageMap = (StorageMap* )param;
		if(itemid>0)
		{
			StorageMap::iterator bitr = storageMap->find(abstractid);
			for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
			{
				if(bitr->second == itemid)
				{
					storageMap->erase(bitr);
					*m_output = 1;
					break;
				}
			} 
		}
		else if(itemid<0)
		{
			thisData->getParam(WCHDATA_StorageCountMap,param);
			ItemCountMap* storageCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr = storageCountMap->find(abstractid);
			if(citr == storageCountMap->end())
			{
				StorageMap::iterator bitr = storageMap->find(abstractid);
				for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
				{
					if(bitr->second == itemid)
					{
						storageMap->erase(bitr);
						*m_output = 1;
						break;
					}
				} 
			}
			else
			{
				int count1 = 0;
				int count2 = 0;
				StorageMap::iterator bitr = storageMap->find(abstractid);
				for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
				{
					if(bitr->second<0)
						count1++;
				}
				for(; citr != storageCountMap->end() && citr->first == abstractid; ++citr)
				{
					count2++;
				}
				if(count1>count2)
				{
					bitr--;
					storageMap->erase(bitr);
				}
				else/* if(count1 == count2)*/
				{
					citr--;
					citr->second--;
					if(citr->second == 1)
						storageCountMap->erase(citr);
				}
				*m_output = 0;
			}
		}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crRecvDepositItemMethod
//
/////////////////////////////////////////
crRecvDepositItemMethod::crRecvDepositItemMethod():
m_netType(GameClient_Game){}
crRecvDepositItemMethod::crRecvDepositItemMethod(const crRecvDepositItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvDepositItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvDepositItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvDepositItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			int itemid = m_stream->_readInt();
			int count = 1;
			if(itemid<0 && m_stream->getRemainSize() == 1)
				count = (int)(m_stream->_readUChar());
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(itemid!=0 && playerData.valid())
			{
				crRole *player = playerData->getRole(roleid);
				void *param;
				crData *thisData = player->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_BackPackMap,param);
				BackPackMap* backPackMap = (BackPackMap* )param;
				std::vector<char>InsertItems;
				InsertItems.reserve(count);
				ref_ptr<crItemChild> itemchild = player->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					char removeItem;
					char insertItem;
					int abstractid = item->getAbstractItemID();
					bool foundInBackPack;
					for( int i=0; i<count; i++)
					{
						insertItem = -1;
						foundInBackPack = false;
						BackPackMap::iterator bitr = backPackMap->find(abstractid);
						for(; bitr != backPackMap->end() && bitr->first == abstractid; ++bitr)
						{
							if(bitr->second == itemid)
							{
								foundInBackPack = true;
								break;
							}
						}
						if(foundInBackPack)
						{
							player->doEvent(WCH_InsertItemToStorage,MAKEINT64(item,&insertItem));
							if(insertItem>=0)
							{
								player->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
							}
						}
						InsertItems.push_back(insertItem);
					}
				}
				int count = InsertItems.size();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(13+count);
				stream->_writeInt(roleid);
				stream->_writeInt(itemid);
				stream->_writeUChar(count);
				for(int i = 0; i<count; i++)
				{
					stream->_writeChar(InsertItems[i]);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvDepositItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			int roleid = m_stream->_readInt();
			crRole *me = crMyPlayerData::getInstance()->getRole(roleid);
			if(me)
			{
				int itemid = m_stream->_readInt();
				int count = m_stream->_readUChar();
				std::vector<char>InsertItems;
				InsertItems.reserve(count);
				for(int i=0; i<count; i++)
				{
					InsertItems.push_back(m_stream->_readChar());
				}
				crData *data = me->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				ref_ptr<crItemChild> itemchild = me->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					char insertItem;
					char removeItem;
					for(int i= 0; i<count; i++)
					{
						insertItem = InsertItems[i];
						if(insertItem>=0)
						{
							me->doEvent(WCH_InsertItemToStorage,MAKEINT64(item,&insertItem));
							me->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(item,&removeItem));
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));

				m_this->doEvent(WCH_BuildStorageItemList);
				me->doEvent(WCH_BuildBackPackList);
			}
			char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr - ptr2);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crRecvTakeoutItemMethod
//
/////////////////////////////////////////
crRecvTakeoutItemMethod::crRecvTakeoutItemMethod():
m_netType(GameClient_Game){}
crRecvTakeoutItemMethod::crRecvTakeoutItemMethod(const crRecvTakeoutItemMethod& handle):
crMethod(handle),
m_netType(GameClient_Game)
{
}
void crRecvTakeoutItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRecvTakeoutItemMethod::addParam(int i, const std::string& str)
{
}
void crRecvTakeoutItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_stream->_readInt();
			int roleid = m_stream->_readInt();
			int itemid = m_stream->_readInt();
			int count = 1;
			if(itemid<0 && m_stream->getRemainSize() == 1)
				count = (int)(m_stream->_readUChar());
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(itemid!=0 && playerData.valid())
			{
				crRole *player = playerData->getRole(roleid);
				void *param;
				crData *thisData = player->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_StorageMap,param);
				StorageMap* storageMap = (StorageMap* )param;
				std::vector<char>InsertItems;
				InsertItems.reserve(count);
				ref_ptr<crItemChild> itemchild = player->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					char removeItem;
					char insertItem;
					int abstractid = item->getAbstractItemID();
					bool foundInStorage;
					for( int i=0; i<count; i++)
					{
						insertItem = -1;
						foundInStorage = false;
						StorageMap::iterator bitr = storageMap->find(abstractid);
						for(; bitr != storageMap->end() && bitr->first == abstractid; ++bitr)
						{
							if(bitr->second == itemid)
							{
								foundInStorage = true;
								break;
							}
						}
						if(foundInStorage)
						{
							player->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item,&insertItem));
							if(insertItem>=0)
							{
								player->doEvent(WCH_RemoveItemFromStorage,MAKEINT64(item,&removeItem));
							}
						}
						InsertItems.push_back(insertItem);
					}
				}
				count = InsertItems.size();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(13+count);
				stream->_writeInt(roleid);
				stream->_writeInt(itemid);
				stream->_writeUChar(count);
				for(int i = 0; i<count; i++)
				{
					stream->_writeChar(InsertItems[i]);
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvTakeoutItem,stream.get());
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char *ptr = m_stream->getPtr();
			int roleid = m_stream->_readInt();
			crRole *me = crMyPlayerData::getInstance()->getRole(roleid);
			if(me)
			{
				int itemid = m_stream->_readInt();
				int count = m_stream->_readUChar();
				std::vector<char>InsertItems;
				InsertItems.reserve(count);
				for(int i=0; i<count; i++)
				{
					InsertItems.push_back(m_stream->_readChar());
				}
				crData *data = me->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				ref_ptr<crItemChild> itemchild = me->findChildItem(itemid);
				if(itemchild.valid() && itemchild->isLoaded())
				{
					crInstanceItem *item = itemchild->getInstanceItem();
					char insertItem;
					char removeItem;
					for(int i= 0; i<count; i++)
					{
						insertItem = InsertItems[i];
						if(insertItem>=0)
						{
							me->doEvent(WCH_InsertItemToBackPack,MAKEINT64(item,&insertItem));
							me->doEvent(WCH_RemoveItemFromStorage,MAKEINT64(item,&removeItem));
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				me->doEvent(WCH_BuildStorageItemList);
				me->doEvent(WCH_BuildBackPackList);
			}
			char *ptr2 = m_stream->getPtr();
			m_stream->seek(ptr - ptr2);
			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
		}
	}
}
/////////////////////////////////////////
//
//crUIDepositItemMethod
//
/////////////////////////////////////////
crUIDepositItemMethod::crUIDepositItemMethod()
{
}
crUIDepositItemMethod::crUIDepositItemMethod(const crUIDepositItemMethod& handle):
crMethod(handle)
{
}
void crUIDepositItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUIDepositItemMethod::addParam(int i, const std::string& str)
{
}
void crUIDepositItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	if(m_this && me)
	{
		crListControlNode *listNode = m_this->getSelectNode();
		if(listNode && listNode->getVisiable())
		{
			ref_ptr<crInstanceItem>targetItem;
			ref_ptr<crMatrixTransform>targetNode;
			me->clientGetTarget(targetItem,targetNode);
			if(targetItem.valid())
			{
				crInstanceItem *item = (crInstanceItem*)(listNode->getData());
				int itemid = item->getInstanceItemID();
				const std::string &countStr = listNode->getTitle2();
				int count = atoi(countStr.c_str());
				//if(itemid>0)
				//{///应该弹出确认窗口避免玩家误卖

				//}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(13);
				stream->_writeInt(me->getPlayerID());
				stream->_writeInt(me->getRoleID());
				stream->_writeInt(itemid);
				if(itemid<0)
					stream->_writeUChar(count);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crWaitNetReturnStreamLogic::getLock();
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvDepositItem,targetItem.get(),stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
					canceleTask = false;
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crUIGetStorageItemMapMethod
//
/////////////////////////////////////////
crUIGetStorageItemMapMethod::crUIGetStorageItemMapMethod(){}
crUIGetStorageItemMapMethod::crUIGetStorageItemMapMethod(const crUIGetStorageItemMapMethod& handle):
crMethod(handle)
{
}
void crUIGetStorageItemMapMethod::inputParam(int i, void *param)
{
}

void crUIGetStorageItemMapMethod::addParam(int i, const std::string& str)
{
}

void crUIGetStorageItemMapMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	ref_ptr<crInstanceItem> targetItem;
	ref_ptr<crMatrixTransform> targetNode;
	me->clientGetTarget(targetItem,targetNode);
	if(targetItem.valid())
	{
		targetItem->doEvent(WCH_GetStorageItemMap);
	}
}
/////////////////////////////////////////
//
//crUITakeoutItemMethod
//
/////////////////////////////////////////
crUITakeoutItemMethod::crUITakeoutItemMethod()
{
}
crUITakeoutItemMethod::crUITakeoutItemMethod(const crUITakeoutItemMethod& handle):
crMethod(handle)
{
}
void crUITakeoutItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crUITakeoutItemMethod::addParam(int i, const std::string& str)
{
}
void crUITakeoutItemMethod::operator()(crHandle &handle)
{
	bool canceleTask = true;
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	if(m_this && me)
	{
		crListControlNode *listNode = m_this->getSelectNode();
		if(listNode && listNode->getVisiable())
		{
			ref_ptr<crInstanceItem>targetItem;
			ref_ptr<crMatrixTransform>targetNode;
			me->clientGetTarget(targetItem,targetNode);
			if(targetItem.valid())
			{
				crInstanceItem *item = (crInstanceItem*)(listNode->getData());
				int itemid = item->getInstanceItemID();
				const std::string &countStr = listNode->getTitle2();
				int count = atoi(countStr.c_str());
				//if(itemid>0)
				//{///应该弹出确认窗口避免玩家误卖

				//}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(13);
				stream->_writeInt(me->getPlayerID());
				stream->_writeInt(me->getRoleID());
				stream->_writeInt(itemid);
				if(itemid<0)
					stream->_writeUChar(count);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crWaitNetReturnStreamLogic::getLock();
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvTakeoutItem,targetItem.get(),stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
					canceleTask = false;
				}
			}
		}
	}
	handle.outputParam(0,&canceleTask);
}
/////////////////////////////////////////
//
//crLoginReturnMethod
//
/////////////////////////////////////////
crLoginReturnMethod::crLoginReturnMethod():
m_loginCode(0)
{
}
crLoginReturnMethod::crLoginReturnMethod(const crLoginReturnMethod& handle):
crMethod(handle),
m_loginCode(0)
{
}
void crLoginReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_loginCode = LOINT64(param64);
		}
		break;
	}
}
void crLoginReturnMethod::addParam(int i, const std::string& str)
{
}
void crLoginReturnMethod::operator()(crHandle &handle)
{
	//bool loginSucess = m_loginCode>0;
	//CRNet::crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Login);
	handle.outputParam(0,&m_loginCode);
}
/////////////////////////////////////////
//
//crDisconnectLoginMethod
//
/////////////////////////////////////////
crDisconnectLoginMethod::crDisconnectLoginMethod()
{
}
crDisconnectLoginMethod::crDisconnectLoginMethod(const crDisconnectLoginMethod& handle):
	crMethod(handle)
{
}
void crDisconnectLoginMethod::inputParam(int i, void *param)
{
}
void crDisconnectLoginMethod::addParam(int i, const std::string& str)
{
}
void crDisconnectLoginMethod::operator()(crHandle &handle)
{
	CRNet::crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Login);
}
/////////////////////////////////////////
//
//crRegisterAccountReturnMethod
//
/////////////////////////////////////////
crRegisterAccountReturnMethod::crRegisterAccountReturnMethod()
{
}
crRegisterAccountReturnMethod::crRegisterAccountReturnMethod(const crRegisterAccountReturnMethod& handle):
crMethod(handle)
{
}
void crRegisterAccountReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crRegisterAccountReturnMethod::addParam(int i, const std::string& str)
{
}
void crRegisterAccountReturnMethod::operator()(crHandle &handle)
{
	char ret = m_stream->_readChar();
	CRNet::crNetContainer::getInstance()->removeDynamicNetConductor(GameClient_Login);
	bool success = false;
	switch(ret)
	{
	case 0:
		success = true;
		break;
	case -1://帐号名格式不正确
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(33,NULL));
		break;
	case -2://帐号名字符数量超限
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(34,NULL));
		break;
	case -3://密码不正确
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(35,NULL));
		break;
	case -4://邮箱地址字符数量超限
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(36,NULL));
		break;
	case -5://昵称字符数量超限
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(37,NULL));
		break;
	case -6://真实名字字符数量超限
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(38,NULL));
		break;
	case -7://激活码输入错误
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(39,NULL));
		break;
	case -8://该激活码已经失效
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(40,NULL));
		break;
	case -9://帐号冲突
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(41,NULL));
		break;
	case -10://激活码不能为空
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(42,NULL));
		break;
	case -11://激活码有效期未到
		{
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			int texid = 45;
			std::string validdata = m_stream->_readString();
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
			noticeHandle->inputParam(WCHDATA_NoticeParam1,&validdata);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
		}
		break;
	default://注册失败
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(10,NULL));
		break;
	}
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crLoginDownloadReturnMethod
//
/////////////////////////////////////////
crLoginDownloadReturnMethod::crLoginDownloadReturnMethod():
m_loginCode(0)
{
}
crLoginDownloadReturnMethod::crLoginDownloadReturnMethod(const crLoginDownloadReturnMethod& handle):
crMethod(handle),
m_loginCode(0)
{
}
void crLoginDownloadReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_loginCode = LOINT64(param64);
		}
		break;
	}
}
void crLoginDownloadReturnMethod::addParam(int i, const std::string& str)
{
}
void crLoginDownloadReturnMethod::operator()(crHandle &handle)
{
	bool loginSucess = m_loginCode>0;
	handle.outputParam(0,&loginSucess);
}
/////////////////////////////////////////
//
//crLoginDownloadCaseMethod
//
/////////////////////////////////////////
crLoginDownloadCaseMethod::crLoginDownloadCaseMethod():
	m_case(0)
{
}
crLoginDownloadCaseMethod::crLoginDownloadCaseMethod(const crLoginDownloadCaseMethod& handle):
	crMethod(handle),
	m_case(handle.m_case)
{
}
void crLoginDownloadCaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_case = LOINT64(param64);
		}
		break;
	}
}
void crLoginDownloadCaseMethod::addParam(int i, const std::string& str)
{
}
void crLoginDownloadCaseMethod::operator()(crHandle &handle)
{
	handle.outputParam(0,&m_case);
}
/////////////////////////////////////////
//
//crIsRuningMethod
//
/////////////////////////////////////////
crIsRuningMethod::crIsRuningMethod(){}
crIsRuningMethod::crIsRuningMethod(const crIsRuningMethod& handle):
crMethod(handle)
{
}
void crIsRuningMethod::inputParam(int i, void *param)
{
}
void crIsRuningMethod::addParam(int i, const std::string& str)
{
}
void crIsRuningMethod::operator()(crHandle &handle)
{
	bool m_true = crRunGameHandle::getInstance()->isRunning();
	handle.outputParam(0,&m_true);
}
/////////////////////////////////////////
//
//crGetRunCodeMethod
//
/////////////////////////////////////////
crGetRunCodeMethod::crGetRunCodeMethod(){}
crGetRunCodeMethod::crGetRunCodeMethod(const crGetRunCodeMethod& handle):
crMethod(handle)
{
}
void crGetRunCodeMethod::inputParam(int i, void *param)
{
}
void crGetRunCodeMethod::addParam(int i, const std::string& str)
{
}
void crGetRunCodeMethod::operator()(crHandle &handle)
{
	int runcode = crRunGameHandle::getInstance()->getRunCode();
	handle.outputParam(0,&runcode);
}
/////////////////////////////////////////
//
//crSetRunCodeMethod
//
/////////////////////////////////////////
crSetRunCodeMethod::crSetRunCodeMethod():
m_runcode(0){}
crSetRunCodeMethod::crSetRunCodeMethod(const crSetRunCodeMethod& handle):
crMethod(handle),
m_runcode(handle.m_runcode)
{
}
void crSetRunCodeMethod::inputParam(int i, void *param)
{
}
void crSetRunCodeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_runcode = atoi(str.c_str());
		break;
	}
}
void crSetRunCodeMethod::operator()(crHandle &handle)
{
	crRunGameHandle::getInstance()->setRunCode(m_runcode);
}
/////////////////////////////////////////
//
//crSetRunningMethod
//
/////////////////////////////////////////
crSetRunningMethod::crSetRunningMethod():
m_running(false){}
crSetRunningMethod::crSetRunningMethod(const crSetRunningMethod& handle):
crMethod(handle),
m_running(handle.m_running)
{
}
void crSetRunningMethod::inputParam(int i, void *param)
{
}
void crSetRunningMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_running = (bool)(atoi(str.c_str()));
		break;
	}
}
void crSetRunningMethod::operator()(crHandle &handle)
{
	crRunGameHandle::getInstance()->setRunning(m_running);
	if(!m_running)
	{
		crStartHandler::getInstance()->setEndCode(1);
	}
}
////////////////////////////////
//
//crTankControllerMethod
//
///////////////////////////////////
crTankControllerMethod::crTankControllerMethod():
m_control(CF_Stop)
{}

crTankControllerMethod::crTankControllerMethod(const crTankControllerMethod& handle):
crMethod(handle),
m_control(handle.m_control)
{
}

void crTankControllerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crTankControllerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_control = (char)(atoi(str.c_str()));
		break;
	}
}

void crTankControllerMethod::operator()(crHandle &handle)
{
	if(!m_this) return;
	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_ControllerFlg,param);
	unsigned char control = *(unsigned char*)param;
	switch(m_control)
	{
	case CF_Up:
		control &= ~CF_Down;
		control |= m_control;
		break;
	case CF_Down:
		control &= ~CF_Up;
		control |= m_control;
		break;
	case CF_Left:
		control &= ~CF_Right;
		control |= m_control;
		break;
	case CF_Right:
		control &= ~CF_Left;
		control |= m_control;
		break;
	case -CF_Up:
		control &= ~CF_Up;
		break;
	case -CF_Down:
		control &= ~CF_Down;
		break;
	case -CF_Left:
		control &= ~CF_Left;
		break;
	case -CF_Right:
		control &= ~CF_Right;
		break;
	}
	data->inputParam(WCHDATA_ControllerFlg,&control);
}
/////////////////////////////////////////
//
//crDoTankControllerAndSendMethod
//
/////////////////////////////////////////
crDoTankControllerAndSendMethod::crDoTankControllerAndSendMethod():
m_interval(0.03f),
m_time(0.0f){}
crDoTankControllerAndSendMethod::crDoTankControllerAndSendMethod(const crDoTankControllerAndSendMethod& handle):
crMethod(handle),
m_interval(handle.m_interval),
m_time(0.0f)
{
}
void crDoTankControllerAndSendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crDoTankControllerAndSendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crDoTankControllerAndSendMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		m_time += crFrameStamp::getInstance()->getFrameInterval();
		if(m_time > m_interval)
		{
			m_time = 0.0f;
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_ControllerFlg,param);
			unsigned char control = *(unsigned char*)param;
			//send to net
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(33);
			stream->_writeUChar(control);

			stream->_writeInt(m_this->getPosx());//4
			stream->_writeInt(m_this->getPosy());//4
			stream->_writeInt(m_this->getPosz());//4
			stream->_writeFloat(m_this->getDirx());//4
			stream->_writeFloat(m_this->getDiry());//4
			stream->_writeFloat(m_this->getDirz());//4

			crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
			float roll = bot->getViewRoll();
			float pitch = bot->getViewPitch();
			stream->_writeFloat(roll);//4
			stream->_writeFloat(pitch);//4
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_NetControlTank,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crNetControlTankMethod
//
/////////////////////////////////////////
crNetControlTankMethod::crNetControlTankMethod():
m_netType(GameClient_Game){}
crNetControlTankMethod::crNetControlTankMethod(const crNetControlTankMethod& handle):
crMethod(handle)
{
}
void crNetControlTankMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crNetControlTankMethod::addParam(int i, const std::string& str)
{
}

void crNetControlTankMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_Dead)
		{
			return;
		}

		unsigned char control = m_stream->_readUChar();
		int posx = m_stream->_readInt();
		int posy = m_stream->_readInt();
		int posz = m_stream->_readInt();
		crVector3 dir;
		dir[0] = m_stream->_readFloat();
		dir[1] = m_stream->_readFloat();
		dir[2] = m_stream->_readFloat();

		thisData->inputParam(WCHDATA_ControllerFlg,&control);
		if(control != CF_Stop)
		{
			float controllerTime = crGlobalHandle::gData()->gControllerTime();
			thisData->inputParam(WCHDATA_ControllerTime,&controllerTime);
		}
		m_this->setDir(dir);
		if(m_netType == GameClient_Game)
		{
			crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
			float roll = m_stream->_readFloat();
			float pitch = m_stream->_readFloat();
			bot->setViewRoll(roll);
			bot->setViewPitch(pitch);
			crVector3 curPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
			crVector3 newPos(posx,posy,posz);
			if((curPos - newPos).length()<10.0f)
			{//过滤细小的位置变化
				return;
			}
		}
		m_this->setPosxy(posx,posy);
		m_this->setPosz(posz);

	}
}
/////////////////////////////////////////
//
//crCarMoveMethod
//
/////////////////////////////////////////
crCarMoveMethod::crCarMoveMethod():
m_dt(0.0f),
m_k(0.2f){}
crCarMoveMethod::crCarMoveMethod(const crCarMoveMethod& handle):
crMethod(handle),
m_dt(0.0f),
m_k(handle.m_k)
{
}
void crCarMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crCarMoveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		//m_isClient = (bool)(atoi(str.c_str()));
		break;
	case 1:
		m_k = atof(str.c_str());
		break;
	}
}

void crCarMoveMethod::operator()(crHandle &handle)
{//汽车类交互
	if(m_this && m_dt>0.0f)
	{
		void *param;
		crData *data = m_this->getDataClass();
		if(!crGlobalHandle::isClient() || !crMyPlayerData::getInstance()->ifItemIsMe(m_this))
		{
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_ControllerTime,param);
			float *controllerTime = (float *)param;
			if(*controllerTime > 0.0f)
			{
				*controllerTime -= m_dt;
				if(*controllerTime < 0.0f)
				{
					data->inputParam(WCHDATA_ControllerFlg,NULL);
					*controllerTime = 0.0f;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		data->getParam(WCHDATA_RTHP,param);
		float rthp = *(float *)param;
		if(rthp>0)
		{
			data->getParam(WCHDATA_CurrentSpeed,param);
			short currentSpeed = *(short*)param;
			float fcurrentSpeed = (float)currentSpeed * crGlobalHandle::gData()->gUnitScale();
			data->getParam(WCHDATA_CurrentAngular,param);
			float currentAngular = *(float*)param;
			crVector3 dir(m_this->getDirx(),m_this->getDiry(),m_this->getDirz());
			bool lostpower = true;
			bool lostAngular = true;
			data->getParam(WCHDATA_ControllerFlg,param);
			unsigned char control = *(unsigned char*)param;
			if(control & CF_Down || control & CF_Up)
			{
				data->getParam(WCHDATA_Acceleration,param);
				short acc = *(short*)param;
				float facc = (float)acc * crGlobalHandle::gData()->gUnitScale();
				float a = control & CF_Up?facc:-facc;
				float fspeed = fcurrentSpeed + a * m_dt;
				float speed = 0;
				m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
				speed *= crGlobalHandle::gData()->gUnitScale();
				if(fabs(fspeed)>speed)
				{
					fspeed = (fspeed / fabs(fspeed)) * speed;
				}
				fcurrentSpeed = fspeed;
				currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
				data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
				lostpower = false;
			}
			if(control & CF_Left || control & CF_Right)
			{
				data->getParam(WCHDATA_AngularAccel,param);
				short angAcc = *(short*)param;
				float fangAcc = CRCore::DegreesToRadians((float)angAcc);
				float a = control & CF_Left?fangAcc:-fangAcc;
				currentAngular = currentAngular + a * m_dt;
				data->getParam(WCHDATA_MaxAngular,param);
				short maxAngular = *(short *)param;
				float fmaxAngular = CRCore::DegreesToRadians((float)maxAngular);
				if(fabs(currentAngular)>fmaxAngular)
				{
					currentAngular = (currentAngular / fabs(currentAngular)) * fmaxAngular;
				}
				data->inputParam(WCHDATA_CurrentAngular,&currentAngular);
				lostAngular = false;
			}
			if(currentSpeed!=0 && lostpower)
			{
				data->getParam(WCHDATA_Damp,param);
				short damp = *(short*)param;
				float fdamp = (float)damp * crGlobalHandle::gData()->gUnitScale();
				float fspeed = fcurrentSpeed * (1.0f - fdamp * m_dt);
				if(fspeed * fcurrentSpeed <= 0.0f)
				{
					fspeed = 0.0f;
				}
				fcurrentSpeed = fspeed;
				currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
				data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
			}
			if(currentAngular != 0.0f && lostAngular)
			{
				data->getParam(WCHDATA_AngularDamp,param);
				short angDamp = *(short*)param;
				float fangDamp = CRCore::DegreesToRadians((float)angDamp);
				float fangular = currentAngular*(1.0f - fangDamp * m_dt);
				if(fangular * currentAngular <= 0.0f)
				{
					fangular = 0.0f;
				}
				currentAngular = fangular;
				data->inputParam(WCHDATA_CurrentAngular,&currentAngular);
			}
			if(currentSpeed!=0)
			{
				float distance = fcurrentSpeed * m_dt;
				crVector3 current(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
				current *= crGlobalHandle::gData()->gUnitScale();
				crVector3 newPos = current + dir * distance;
				//data->getParam(WCHDATA_TargetPos,param);
				//crVector3 targetPos = *(crVector3 *)(param);
				//crVector3 targetDir = targetPos - newPos;
				//if(targetDir.length2()<0.1f * 0.1f)
				//{
				//	newPos = targetPos;
				//	//itemstate = IS_Stop;
				//	//data->inputParam(WCHDATA_ItemState,&itemstate);
				//}
				CRNetApp::crScene *scene = NULL;
				if(crGlobalHandle::isClient())
				{
					scene = crMyPlayerData::getInstance()->getScene();
				}
				else
				{
					crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
					crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
					scene = netCallback->findScene(m_this->getSceneID());
				}
				crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
				crVector2s pos = scenelayer->getCoord(newPos[0],newPos[1]);
				crVector2 info = scenelayer->getCollideInfo(pos[0], pos[1]);
				if(scenelayer->walkability(info[0]))
				{
					float z = info[1];
					newPos/=crGlobalHandle::gData()->gUnitScale();
					z /= crGlobalHandle::gData()->gUnitScale();
					z += m_this->getZoffset();
					m_this->setPosxy(newPos[0],newPos[1]);
					m_this->setPosz(z);
					float zslope = z*crGlobalHandle::gData()->gUnitScale() - current[2];
					float k = zslope/distance;
					float g1 = k*m_k*m_dt*100.0f;
					if(fabs(g1)>2.0f)
					{
						g1 = (g1 / fabs(g1)) * 2.0f;
					}
					fcurrentSpeed = fcurrentSpeed*(1.0f+(fcurrentSpeed>0?-g1:g1));
					currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
					data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);

					if(currentAngular != 0.0f)
					{
						crMatrix rotStep = CRCore::crMatrix::rotate(currentAngular* fcurrentSpeed * m_dt, CRCore::Z_AXIS);
						//if(k != 0.0f)
						//	rotStep.postMult(CRCore::crMatrix::rotate(-atan(k), CRCore::X_AXIS));
						dir = (dir * rotStep).normalize();
						m_this->setDir(dir);
					}
					if(crGlobalHandle::isClient())
					{
						crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
						if(bot)
						{
							m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
						}
					}
				}
				else
				{
					currentSpeed = -currentSpeed*0.5f;
					data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
				}
			}
			//if(crGlobalHandle::isClient()&& m_this == crMyPlayerData::getInstance()->getCurrentRole())
			//{
			//	//test
			//	CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
			//	if(noticeText)
			//	{
			//		noticeText->setText(crArgumentParser::appFtoa(currentAngular)+":speed:"+crArgumentParser::appFtoa(currentSpeed));
			//		noticeText->setVisiable(true);
			//	}
			//}
		}
	}
}
/////////////////////////////////////////
//
//crTankMoveMethod
//
/////////////////////////////////////////
crTankMoveMethod::crTankMoveMethod():
m_dt(0.0f),
m_k(0.2f),
m_interval(0.0f),
m_time(0.0f){ m_viewOffsetParams.set(5.0f,0.2f,2.0f,2.0f); }
crTankMoveMethod::crTankMoveMethod(const crTankMoveMethod& handle):
crMethod(handle),
m_dt(0.0f),
m_k(handle.m_k),
m_viewOffsetParams(handle.m_viewOffsetParams),
m_interval(handle.m_interval),
m_time(0.0f)
{
}
void crTankMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crTankMoveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		//m_isClient = (bool)(atoi(str.c_str()));
		break;
	case 1:
		m_k = atof(str.c_str());
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_viewOffsetParams);
		break;
	case 3:
		m_interval = atof(str.c_str());
		break;
	}
}

void crTankMoveMethod::operator()(crHandle &handle)
{//汽车类交互
	if(m_this && m_dt>0.0f)
	{
		m_time += m_dt;
		if(m_time > m_interval)
		{
			void *param;
			crData *data = m_this->getDataClass();
			if(!crGlobalHandle::isClient() || !crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_ControllerTime,param);
				float *controllerTime = (float *)param;
				if(*controllerTime > 0.0f)
				{
					*controllerTime -= m_time;
					if(*controllerTime < 0.0f)
					{
						data->inputParam(WCHDATA_ControllerFlg,NULL);
						*controllerTime = 0.0f;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
			data->getParam(WCHDATA_RTHP,param);
			float rthp = *(float *)param;
			if(rthp>0)
			{
				crViewMatterObject *bot = NULL;
				if(crGlobalHandle::isClient())
				{
					bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
				}
				data->getParam(WCHDATA_CurrentSpeed,param);
				short currentSpeed = *(short*)param;
				float fcurrentSpeed = (float)currentSpeed * crGlobalHandle::gData()->gUnitScale();
				data->getParam(WCHDATA_CurrentAngular,param);
				float currentAngular = *(float*)param;
				data->getParam(WCHDATA_MaxAngular,param);
				short maxAngular = *(short *)param;
				float fmaxAngular = CRCore::DegreesToRadians((float)maxAngular);

				crVector3 dir(m_this->getDirx(),m_this->getDiry(),m_this->getDirz());
				bool lostpower = true;
				bool lostAngular = true;
				data->getParam(WCHDATA_ControllerFlg,param);
				unsigned char control = *(unsigned char*)param;
				if(control & CF_Down || control & CF_Up)
				{
					data->getParam(WCHDATA_Acceleration,param);
					short acc = *(short*)param;
					float facc = (float)acc * crGlobalHandle::gData()->gUnitScale();
					float a = control & CF_Up?facc:-facc;
					float fspeed = fcurrentSpeed + a * m_time;
					float speed = 0;
					m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
					speed *= crGlobalHandle::gData()->gUnitScale();
					if(fabs(fspeed)>speed)
					{
						fspeed = (fspeed / fabs(fspeed)) * speed;
					}
					fcurrentSpeed = fspeed;
					currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
					data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
					lostpower = false;
					if(crGlobalHandle::isClient())
					{
						float offset = m_viewOffsetParams[0] + CRCore::clampTo(a * m_viewOffsetParams[1],-m_viewOffsetParams[3],m_viewOffsetParams[3]);
						bot->setTargetViewOffset2(offset,m_viewOffsetParams[2]);
					}
				}
				if(control & CF_Left || control & CF_Right)
				{
					data->getParam(WCHDATA_AngularAccel,param);
					short angAcc = *(short*)param;
					float fangAcc = CRCore::DegreesToRadians((float)angAcc);
					float a = control & CF_Left?fangAcc:-fangAcc;
					currentAngular = currentAngular + a * m_time;

					if(fabs(currentAngular)>fmaxAngular)
					{
						currentAngular = (currentAngular / fabs(currentAngular)) * fmaxAngular;
					}
					data->inputParam(WCHDATA_CurrentAngular,&currentAngular);
					lostAngular = false;
				}
				if(currentSpeed!=0.0f && lostpower)
				{
					data->getParam(WCHDATA_Damp,param);
					short damp = *(short*)param;
					float fdamp = (float)damp * crGlobalHandle::gData()->gUnitScale();
					float fspeed = fcurrentSpeed * (1.0f - fdamp * m_time);
					if(fspeed * fcurrentSpeed <= 0.0f)
					{
						fspeed = 0.0f;
					}
					fcurrentSpeed = fspeed;
					currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
					data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
					if(crGlobalHandle::isClient())
					{
						bot->setTargetViewOffset2(m_viewOffsetParams[0],m_viewOffsetParams[2]);
					}
				}
				//if(currentAngular != 0.0f && lostAngular)
				//{
				//	data->getParam(WCHDATA_AngularDamp,param);
				//	short angDamp = *(short*)param;
				//	float fangDamp = CRCore::DegreesToRadians((float)angDamp);
				//	float fangular = currentAngular*(1.0f - fangDamp * m_dt);
				//	if(fangular * currentAngular <= 0.0f)
				//	{
				//		fangular = 0.0f;
				//	}
				//	currentAngular = fangular;
				//	data->inputParam(WCHDATA_CurrentAngular,&currentAngular);
				//}
				if(lostAngular && crGlobalHandle::isClient())
				{//恢复到相机角度
					float roll = bot->getViewRoll();
					crMatrix rollMatrix = CRCore::crMatrix::rotate(roll, Z_AXIS);
					crVector3 rollDir = (CRCore::Y_AXIS * rollMatrix).normalize();

					crVector3 cross = rollDir^dir;
					currentAngular = fmaxAngular * cross[2];
					data->inputParam(WCHDATA_CurrentAngular,&currentAngular);
				}
				if(currentSpeed!=0.0f || currentAngular!=0.0f)
				{
					CRNetApp::crScene *scene = NULL;
					if(crGlobalHandle::isClient())
					{
						scene = crMyPlayerData::getInstance()->getScene();
					}
					else
					{
						crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
						crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
						crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
						scene = netCallback->findScene(m_this->getSceneID());
					}
					if(currentAngular != 0.0f)
					{
						crMatrix rotStep = CRCore::crMatrix::rotate(currentAngular/** fcurrentSpeed*/ * m_time, CRCore::Z_AXIS);
						dir = (dir * rotStep).normalize();
					}
					crVector3 current(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
					current *= crGlobalHandle::gData()->gUnitScale();
					if(currentSpeed!=0.0f)
					{
						float distance = fcurrentSpeed * m_time;
						crVector3 newPos = current + dir * distance;

						float height = 0.0f;
						//crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
						//crVector2s pos = scenelayer->getCoord(newPos[0],newPos[1]);
						//crVector2 info = scenelayer->getCollideInfo(pos[0], pos[1]);
						if(m_this->testNewPos(scene,crVector2(newPos[0],newPos[1]),dir,height))
						{
							float z = height;
							newPos/=crGlobalHandle::gData()->gUnitScale();
							z /= crGlobalHandle::gData()->gUnitScale();
							z += m_this->getZoffset();
							m_this->setPosxy(newPos[0],newPos[1]);
							m_this->setPosz(z);
							float zslope = z*crGlobalHandle::gData()->gUnitScale() - current[2];
							float k = zslope/distance;
							float g1 = k*m_k*m_time*100.0f;
							if(fabs(g1)>2.0f)
							{
								g1 = (g1 / fabs(g1)) * 2.0f;
							}
							fcurrentSpeed = fcurrentSpeed*(1.0f+(fcurrentSpeed>0?-g1:g1));
							currentSpeed = fcurrentSpeed / crGlobalHandle::gData()->gUnitScale();
							data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);

							m_this->setDir(dir);
							if(crGlobalHandle::isClient())
							{
								m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
							}
						}
						else
						{
							currentSpeed = -currentSpeed*0.5f;
							data->inputParam(WCHDATA_CurrentSpeed,&currentSpeed);
						}
					}
					else/* if(currentAngular != 0.0f)*/
					{
						float height = 0.0f;
						if(m_this->testNewPos(scene,crVector2(current[0],current[1]),dir,height))
						{
							float z = height;
							z /= crGlobalHandle::gData()->gUnitScale();
							z += m_this->getZoffset();
							m_this->setPosz(z);

							m_this->setDir(dir);
							if(crGlobalHandle::isClient())
							{
								m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
							}
						}
					}
				}
				//if(crGlobalHandle::isClient() && m_this == crMyPlayerData::getInstance()->getCurrentRole())
				//{
				//	//test
				//	CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
				//	if(noticeText)
				//	{
				//		noticeText->setText(crArgumentParser::appFtoa(currentAngular)+":speed:"+crArgumentParser::appFtoa(currentSpeed));
				//		noticeText->setVisiable(true);
				//	}
				//}
			}
			m_time = 0.0f;
		}
	}
}
/////////////////////////////////////////
//
//crRotateEmplacementLogic
//
/////////////////////////////////////////
crRotateEmplacementLogic::crRotateEmplacementLogic():
m_dt(0.0f),
m_lastroll(0.0f),
m_lastpitch(0.0f){m_rollRange.set(-CRCore::PI,CRCore::PI);}
crRotateEmplacementLogic::crRotateEmplacementLogic(const crRotateEmplacementLogic& handle):
crLogic(handle),
m_dt(0.0f),
m_lastroll(0.0f),
m_lastpitch(0.0f),
m_boneName(handle.m_boneName),
m_pitchRange(handle.m_pitchRange),
m_rollRange(handle.m_rollRange)
{
	if(handle.m_increaseAim.valid())
		m_increaseAim = handle.m_increaseAim->clone();
}
void crRotateEmplacementLogic::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crRotateEmplacementLogic::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_boneName = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_pitchRange);
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_rollRange);
		break;
	}
}
void crRotateEmplacementLogic::inputHandle(int i, void *param)
{
	switch (i)
	{
	case 0:
		m_increaseAim = (CRCore::crHandle *)param;
		break;
	}
}
void crRotateEmplacementLogic::outputParam(int i, void *param)
{
}
void crRotateEmplacementLogic::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	if(m_this && m_dt>0.0f)
	{
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		if(bot)
		{
			CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(bot->getBodyChild());
			float roll = bot->getViewRoll();
			float pitch = bot->getViewPitch();
			roll = CRCore::clampTo(roll,m_rollRange[0],m_rollRange[1]);
			pitch = CRCore::clampTo(pitch,m_pitchRange[0],m_pitchRange[1]);

			crMatrix mat;
			if(pitch != 0.0f) mat = CRCore::crMatrix::rotate(pitch, CRCore::Z_AXIS);
			if(roll != 0.0f)
			{
				if(bot->getFreeCamera())
				{
					crVector3 dir(m_this->getDirx(),m_this->getDiry(),m_this->getDirz());
					dir = -dir;
					//crVector3 dir = bot->getDirection();
					float a = acos(dir * CRCore::Y_AXIS);
					if(dir[0]>0) a = -a;
					mat.preMult(CRCore::crMatrix::rotate(roll - a, CRCore::Y_AXIS));//heading
				}
				else
					mat.preMult(CRCore::crMatrix::rotate(roll, CRCore::Y_AXIS));//heading
			}
			bodyNode->rotateBoneMatrix(m_boneName,mat.getRotate());

			bool changed = false;
			if(!CRCore::equivalent(m_lastroll,roll,0.0003f))
			{
				m_lastroll = roll;
				changed = true;
			}
			if(!CRCore::equivalent(m_lastpitch,pitch,0.0003f))
			{
				m_lastpitch = pitch;
				changed = true;
			}
			if(changed)
			{
				m_increaseAim->inputParam(1,m_this);
				(*m_increaseAim)(*this);
				m_increaseAim->inputParam(1,NULL);
			}
		}
	}
}
/////////////////////////////////////////
//
//crSwitchCursorMethod
//
/////////////////////////////////////////
crSwitchCursorMethod::crSwitchCursorMethod():
m_currentCursor(0)
{
}

crSwitchCursorMethod::crSwitchCursorMethod(const crSwitchCursorMethod& handle):
crMethod(handle),
m_currentCursor(0),
m_cursorVec(handle.m_cursorVec)
{
}

void crSwitchCursorMethod::inputParam(int i, void *param)
{
}

void crSwitchCursorMethod::addParam(int i, const std::string& str)
{
	m_cursorVec.push_back(str);
}

void crSwitchCursorMethod::operator()(crHandle &handle)
{
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview && bindview->isInited())
	{
		m_currentCursor++;
		if(m_currentCursor>=m_cursorVec.size())
			m_currentCursor = 0;
		bindview->showCursor(m_cursorVec[m_currentCursor]);
	}
}
/////////////////////////////////////////
//
//crAttackMethod
//
/////////////////////////////////////////
crAttackMethod::crAttackMethod():
m_backspeed(0),
m_aimScale(0.01f)
{
}

crAttackMethod::crAttackMethod(const crAttackMethod& handle):
crMethod(handle),
m_backspeed(handle.m_backspeed),
m_aimScale(handle.m_aimScale)
{
}

void crAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}

void crAttackMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_backspeed = (short)(atoi(str.c_str()));
		break;
	case 1:
		m_aimScale = atof(str.c_str());
		break;
	}
}

void crAttackMethod::operator()(crHandle &handle)
{
	//检查普通攻击
	void *param;
	crData *thisData = m_this->getDataClass();
	thisData->getParam(WCHDATA_ItemState,param);
	unsigned char itemstate = *(unsigned char*)param;
	if(itemstate == IS_ItemLoad || itemstate == IS_Dead)
	{
		return;
	}
	thisData->getParam(WCHDATA_AboutToUseItemID,param);
	int itemid = *((int*)param);
	if(itemid == 0)
	{
		thisData->getParam(WCHDATA_CurrentAttackID,param);
		itemid = *((int*)param);
	}
	if(itemid!=0)
	{
		crItemChild *itemChild = m_this->findChildItem(itemid);
		if(itemChild && itemChild->isLoaded())
		{
			crInstanceItem *item = itemChild->getInstanceItem();
			if(item->getNode() == NULL)
			{//正常情况下模型应当已经加载过了，如果执行到这里，可能会有问题
				item->clientLoadItemChildNode(m_this);
			}
			//UseItemPair useItemPair;
			//useItemPair.first = m_this;
			//useItemPair.second = NULL;

			UseItemParam useItemParam;
			useItemParam.m_user = m_this;
			useItemParam.m_target = NULL;
			crData *itemData = item->getDataClass();
			itemData->getParam(WCHDATA_AttackAim,param);
			float aim = *(float *)(param);
			aim *= m_aimScale;
			CRCore::rangef aimrnd(-aim,aim);
			crVector3 dirOffset(aimrnd.get_random(),aimrnd.get_random(),aimrnd.get_random());
			useItemParam.m_dirOffset = dirOffset;
			unsigned short useResult = UR_None;
			item->doEvent(MAKEINT64(WCH_UseItem,UT_Client),MAKEINT64(&useItemParam,&useResult));
			if(useResult == UR_Succeed)
			{
				//send to net
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(17);
					stream->_writeInt(itemid);
					bool hasdir = dirOffset != crVector3(0.0f,0.0f,0.0f);
					stream->_writeBool(hasdir);
					if(hasdir) stream->_writeVec3(dirOffset);
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvAttack,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				thisData->inputParam(WCHDATA_CurrentSpeed,&m_backspeed);
			}
		}
		else
		{
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_QuickList,param);
			QuickList *quickList = (QuickList *)param;
			bool found = false;
			for( QuickList::iterator itr = quickList->begin();
				 itr != quickList->end();
				 ++itr )
			{
				if(itr->second == itemid)
				{
					found = true;
					break;
				}
			}
			if(!found)
			{
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(0);
					//int id = m_this->getID();
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvAboutToUseItemID,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				thisData->inputParam(WCHDATA_AboutToUseItemID,NULL);
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crRecvAttackMethod
//
/////////////////////////////////////////
crRecvAttackMethod::crRecvAttackMethod():
m_netType(GameClient_Game){}
crRecvAttackMethod::crRecvAttackMethod(const crRecvAttackMethod& handle):
crMethod(handle)
{
}
void crRecvAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvAttackMethod::addParam(int i, const std::string& str)
{
}

void crRecvAttackMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		int itemid = m_stream->_readInt();

		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate == IS_ItemLoad || itemstate == IS_Dead)
		{
			return;
		}
		crItemChild *itemChild = m_this->findChildItem(itemid);
		if(itemChild && itemChild->isLoaded())
		{
			crInstanceItem *item = itemChild->getInstanceItem();
			UseItemParam useItemParam;
			bool hasDir = m_stream->_readBool();
			if(hasDir)
				useItemParam.m_dirOffset = m_stream->_readVec3();
			if(m_netType == GameClient_Game)
			{
				if(item->getNode() == NULL)
				{
					item->clientLoadItemChildNode(m_this);
				}
				useItemParam.m_user = m_this;
				useItemParam.m_target = NULL;
				item->doEvent(MAKEINT64(WCH_UseItem,UT_NetClient),MAKEINT64(&useItemParam,NULL));
			}
			else if(m_netType == SceneServer)
			{
				useItemParam.m_user = m_this;
				useItemParam.m_target = NULL;
				unsigned short useResult = UR_None;
				item->doEvent(MAKEINT64(WCH_UseItem,UT_NetServer),MAKEINT64(&useItemParam,&useResult));
			}
		}
	}
}
/////////////////////////////////////////
//
//crTankChangeCameraMethod
//
/////////////////////////////////////////
char crTankChangeCameraMethod::m_type = 0;
crTankChangeCameraMethod::crTankChangeCameraMethod()
{
}

crTankChangeCameraMethod::crTankChangeCameraMethod(const crTankChangeCameraMethod& handle):
crMethod(handle),
m_rollPitchSpeed(handle.m_rollPitchSpeed),
m_heightOffsetSpeed(handle.m_heightOffsetSpeed),
m_heightOffset(handle.m_heightOffset)
{
}

void crTankChangeCameraMethod::inputParam(int i, void *param)
{
}

void crTankChangeCameraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = (char)(atoi(str.c_str()));
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_rollPitchSpeed);
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_heightOffsetSpeed);
		break;
	case 3:
		crArgumentParser::appAtoVec(str,m_heightOffset);
		break;
	}
}

void crTankChangeCameraMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getCurrentRole();
	crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(role->getRelNode());
	//void *param;
	if(m_type == 0)
	{
		bot->setFreeCamera(false);
		//bot->setLockViewOffset(false);
		bot->setLockViewRoll(true);
		bot->setLockViewPitch(true);
		bot->setTargetViewRoll(0.0f,m_rollPitchSpeed[0]);
		bot->setTargetViewPitch(0.0f,m_rollPitchSpeed[1]);

		bot->setLockViewOffset(true);
		bot->setTargetViewHeight(m_heightOffset[0],m_heightOffsetSpeed[0]);
		bot->setTargetViewOffset(m_heightOffset[1],m_heightOffsetSpeed[1]);

		//crData *thisData = role->getDataClass();
		//thisData->getParam(WCHDATA_CurrentAttackID,param);
		//int itemid = *((int*)param);
		//if(itemid>0)
		//{
		//	crItemChild *itemChild = role->findChildItem(itemid);
		//	crInstanceItem *item = itemChild->getInstanceItem();
		//	crData *itemData = item->getDataClass();
		//	itemData->getParam(WCHDATA_AimID,param);
		//	short aimid = *(short *)(param);
		//	crFilterRenderManager::getInstance()->showCanvas(aimui,false);
		//}
		m_type++;
	}
	else if(m_type == 1)
	{
		bot->setFreeCamera(true);
		bot->setLockViewRoll(false);
		bot->setLockViewPitch(false);
		crVector3 dir = bot->getDirection();
		float a = acos(dir * CRCore::Y_AXIS);
		if(dir[0]>0) a = -a;
		bot->setViewRoll(a);
		m_type++;
	}
	else if(m_type == 2)
	{
		//bot->setFreeCamera(false);
		bot->setTargetViewHeight(m_heightOffset[2],m_heightOffsetSpeed[0]);
		bot->setTargetViewOffset(m_heightOffset[3],m_heightOffsetSpeed[1]);
		//bot->setLockViewRoll(false);
		//bot->setLockViewPitch(false);
		
		//crData *thisData = role->getDataClass();
		//thisData->getParam(WCHDATA_CurrentAttackID,param);
		//int itemid = *((int*)param);
		//if(itemid>0)
		//{
		//	crItemChild *itemChild = role->findChildItem(itemid);
		//	crInstanceItem *item = itemChild->getInstanceItem();
		//	crData *itemData = item->getDataClass();
		//	itemData->getParam(WCHDATA_AimID,param);
		//	short aimid = *(short *)(param);
		//	crFilterRenderManager::getInstance()->showCanvas(aimui,true);
		//}
		m_type = 0;
	}
}
/////////////////////////////////////////
//
//crIncreaseAimMethod
//
/////////////////////////////////////////
crIncreaseAimMethod::crIncreaseAimMethod():
m_speed(0.0f)
{
}

crIncreaseAimMethod::crIncreaseAimMethod(const crIncreaseAimMethod& handle):
crMethod(handle),
m_speed(handle.m_speed)
{
}

void crIncreaseAimMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crIncreaseAimMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_speed = atof(str.c_str());
		break;
	}
}
void crIncreaseAimMethod::operator()(crHandle &handle)
{
	if(m_this && m_this == crMyPlayerData::getInstance()->getCurrentRole())
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		float speed = m_speed;
		if(speed<0.0f)
		{
			thisData->getParam(WCHDATA_ControllerFlg,param);
			unsigned char control = *(unsigned char*)param;
			if(control != CF_Stop)
				speed = -speed;
		}
		thisData->getParam(WCHDATA_AboutToUseItemID,param);
		int itemid = *((int*)param);
		if(itemid == 0)
		{
			thisData->getParam(WCHDATA_CurrentAttackID,param);
			itemid = *((int*)param);
		}
		if(itemid!=0)
		{
			crItemChild *itemChild = m_this->findChildItem(itemid);
			if(itemChild && itemChild->isLoaded())
			{
				crInstanceItem *item = itemChild->getInstanceItem();
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_AttackAim,param);
				float aim = *(float *)(param);
				itemData->getParam(WCHDATA_UIAimRange,param);
				crVector2 aimRange = *(crVector2 *)(param);
				aim += speed * crFrameStamp::getInstance()->getFrameInterval();
				aim = CRCore::clampTo(aim,aimRange[0],aimRange[1]);
				itemData->inputParam(WCHDATA_AttackAim,&aim);
			}
		}
	}
}
/////////////////////////////////////////
//
//crSetAimUIMethod
//
/////////////////////////////////////////
crSetAimUIMethod::crSetAimUIMethod():
m_aimScale(1.0f),
m_aimui("ui_aim")
{
}

crSetAimUIMethod::crSetAimUIMethod(const crSetAimUIMethod& handle):
crMethod(handle),
m_aimScale(handle.m_aimScale),
m_aimTrans(handle.m_aimTrans),
m_aimui(handle.m_aimui)
{
}

void crSetAimUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crSetAimUIMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_aimScale = atof(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_aimTrans);
		break;
	case 2:
		m_aimui = str;
		break;
	}
}

void crSetAimUIMethod::operator()(crHandle &handle)
{
	if(m_this && m_this == crMyPlayerData::getInstance()->getCurrentRole())
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_AboutToUseItemID,param);
		int itemid = *((int*)param);
		if(itemid == 0)
		{
			thisData->getParam(WCHDATA_CurrentAttackID,param);
			itemid = *((int*)param);
		}
		if(itemid!=0)
		{
			crItemChild *itemChild = m_this->findChildItem(itemid);
			if(itemChild && itemChild->isLoaded())
			{
				crInstanceItem *item = itemChild->getInstanceItem();
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_AimID,param);
				short aimid = *(short *)(param);
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_aimui);
				if(canvas.valid() && canvas->getVisiable())
				{
					ref_ptr<crDOFTransform>dof = dynamic_cast<crDOFTransform *>(canvas->getChild(0));
					if(dof.valid())
					{
						crMultiSwitch *aimsw = dynamic_cast<crMultiSwitch *>(dof->getChild(0));
						aimsw->setActiveSwitchSet(aimid);
						itemData->getParam(WCHDATA_AttackAim,param);
						float aim = *(float *)(param);
						dof->setCurrentTranslate(crVector3(m_aimTrans[0],m_aimTrans[1],0.0f));
						aim *= m_aimScale;
						dof->setCurrentScale(crVector3(aim,aim,1.0f));
						dof->setAnimationOn(false);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvCreateRoleMethod
//
/////////////////////////////////////////
crRecvCreateRoleMethod::crRecvCreateRoleMethod():
m_sucess(false)
{
}

crRecvCreateRoleMethod::crRecvCreateRoleMethod(const crRecvCreateRoleMethod& handle):
crMethod(handle),
m_sucess(false)
{
}

void crRecvCreateRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_sucess = LOINT64(param64) != 0;
		}
		break;
	}
}

void crRecvCreateRoleMethod::addParam(int i, const std::string& str)
{
}

void crRecvCreateRoleMethod::operator()(crHandle &handle)
{
	if(m_sucess)
	{
		//crRunGameHandle::getInstance()->setRunCode(1);
		//crMyPlayerData::getInstance()->setExitCode(EC_SwitchScene);
		////crMyPlayerData::getInstance()->clear();
		//CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
		//if(bindview) bindview->setDone(true);//退出
		//crRunGameHandle::getInstance()->end();
	}
	else
	{
		//std::string str = "创建角色失败";
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(24,NULL));
	}
}
/////////////////////////////////////////
//
//crCheckGameRoleCountMethod
//
/////////////////////////////////////////
crCheckGameRoleCountMethod::crCheckGameRoleCountMethod():
m_maxrole(4)
{
}

crCheckGameRoleCountMethod::crCheckGameRoleCountMethod(const crCheckGameRoleCountMethod& handle):
crMethod(handle),
m_maxrole(handle.m_maxrole)
{
}

void crCheckGameRoleCountMethod::inputParam(int i, void *param)
{
}

void crCheckGameRoleCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_maxrole = atoi(str.c_str());
		break;
	}
}

void crCheckGameRoleCountMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->getGameRoleCount()>=m_maxrole)
	{
		//std::string str = "坦克数量已经满了";
		//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
		bool cancelTask = true;
		handle.outputParam(0,&cancelTask);
	}
}
/////////////////////////////////////////
//
//crCarSlopeAdaptMethod
//
/////////////////////////////////////////
crCarSlopeAdaptMethod::crCarSlopeAdaptMethod(){}
crCarSlopeAdaptMethod::crCarSlopeAdaptMethod(const crCarSlopeAdaptMethod& handle):
crMethod(handle)
{
}
void crCarSlopeAdaptMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crCarSlopeAdaptMethod::addParam(int i, const std::string& str)
{
}

void crCarSlopeAdaptMethod::operator()(crHandle &handle)
{//汽车类交互
	if(m_this)
	{
		crVector2 dir(m_this->getDirx(),m_this->getDiry());
		crVector3 current(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
		current *= crGlobalHandle::gData()->gUnitScale();

		CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
		crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
		crVector2s coord = scenelayer->getCoord(current[0],current[1]);
		crVector2s newCoord = coord;
		crVector2s newCoord2 = coord;
		if(dir[0] == 0.0f)
		{
			newCoord[1] += dir[1]>0.0f?1:-1;
			newCoord2[0] -= dir[1]>0.0f?1:-1;
		}
		else if(dir[1] == 0.0f)
		{
			newCoord[0] += dir[0]>0.0f?1:-1;
			newCoord2[1] += dir[0]>0.0f?1:-1;
		}
		else
		{
			float angle = atanf(dir[1]/dir[0]);
			float pi_8 = CRCore::PI * 0.125;
			float pi38 = CRCore::PI_2 - pi_8; 
			if(angle>-pi_8 && angle<pi_8)
			{
				newCoord[0] += dir[0]>0.0f?1:-1;
				newCoord2[1] += dir[0]>0.0f?1:-1;
			}
			else if(angle>pi38 || angle<-pi38)
			{
				newCoord[1] += dir[1]>0.0f?1:-1;
				newCoord2[0] -= dir[1]>0.0f?1:-1;
			}
			else
			{
				newCoord[0] += dir[0]>0.0f?1:-1;
				newCoord[1] += dir[1]>0.0f?1:-1;
				newCoord2[1] += dir[0]>0.0f?1:-1;
				newCoord2[0] -= dir[1]>0.0f?1:-1;
			}
		}
		//crVector2 currentPos(current[0],current[1]);
		crVector2 info = scenelayer->getCollideInfo(newCoord[0], newCoord[1]);
		float z,distance,zslope,k;
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		if(scenelayer->walkability(info[0]))
		{
			z = info[1] / crGlobalHandle::gData()->gUnitScale() + m_this->getZoffset();
			distance = (newCoord - coord).length() * scenelayer->getXInterval();
			zslope = z*crGlobalHandle::gData()->gUnitScale() - current[2];
			k = zslope/distance;
			if(fabs(k)<1.0f)
			{
				bot->setSlopeX(-atan(k));
			}
		}
		info = scenelayer->getCollideInfo(newCoord2[0], newCoord2[1]);
		if(scenelayer->walkability(info[0]))
		{
			z = info[1] / crGlobalHandle::gData()->gUnitScale() + m_this->getZoffset();
			distance = (newCoord2 - coord).length() * scenelayer->getXInterval();
			zslope = z*crGlobalHandle::gData()->gUnitScale() - current[2];
			k = zslope/distance;
			if(fabs(k)<1.0f)
			{
				bot->setSlopeY(-atan(k));
			}
		}
	}
}
/////////////////////////////////////////
//
//crWheelAndTrackSpeedMethod
//
/////////////////////////////////////////
crWheelAndTrackSpeedMethod::crWheelAndTrackSpeedMethod():
m_wheelActSpeedScale(1.0f),
m_trackSpeedScale(1.0f){}
crWheelAndTrackSpeedMethod::crWheelAndTrackSpeedMethod(const crWheelAndTrackSpeedMethod& handle):
crMethod(handle),
m_wheelActName(handle.m_wheelActName),
m_wheelActSpeedScale(handle.m_wheelActSpeedScale),
m_trackObjName(handle.m_trackObjName),
m_trackSpeedScale(handle.m_trackSpeedScale)
{
}
void crWheelAndTrackSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crWheelAndTrackSpeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_wheelActName = str;
		break;
	case 1:
		m_wheelActSpeedScale = atof(str.c_str());
		break;
	case 2:
		m_trackObjName = str;
		break;
	case 3:
		m_trackSpeedScale = atof(str.c_str());
		break;
	}
}

void crWheelAndTrackSpeedMethod::operator()(crHandle &handle)
{//汽车类交互
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_CurrentSpeed,param);
		short currentSpeed = *(short*)param;
		float fcurrentSpeed = (float)currentSpeed * crGlobalHandle::gData()->gUnitScale();
		//data->getParam(WCHDATA_CurrentAngular,param);
		//float currentAngular = *(float*)param;

		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(bot->getBodyChild());
		if(bodyNode)
		{
			ActionRequest *action = bodyNode->getBody()->getActionPrototype( m_wheelActName );
			if(action)
			{
				bodyNode->setAnimPlaySpeed(fcurrentSpeed * m_wheelActSpeedScale);
				bodyNode->getBody()->executeAction(action, false);
			}

			if(!m_trackObj.valid())
			{
				CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
				searchByNameVisitor.setNameId(m_trackObjName);
				searchByNameVisitor.setSearchNodeType(OBJECT);
				bodyNode->accept(searchByNameVisitor);
				m_trackObj = dynamic_cast<crObject *>(searchByNameVisitor.getResult());
				if(m_trackObj.valid())
				{
					crDofUniformTexMatCallback *dofcallback = dynamic_cast<crDofUniformTexMatCallback *>(m_trackObj->getCullCallback("DofUniformTexMat"));
					if(dofcallback)
					{
						crDOFTransform *dof = dofcallback->getDofTransform();
						m_stepTrans = dof->getIncrementTranslate();
					}
				}
				else
				{
					CRCore::notify(CRCore::NOTICE)<<"crWheelAndTrackSpeedMethod(): "<<m_trackObjName<<" 没有找到"<<std::endl;
				}
			}
			if(m_trackObj.valid())
			{
				CRCore::crVector3 stepTrans;
				crDofUniformTexMatCallback *dofcallback = dynamic_cast<crDofUniformTexMatCallback *>(m_trackObj->getCullCallback("DofUniformTexMat"));
				crDOFTransform *dof;
				while(dofcallback)
				{
					dof = dofcallback->getDofTransform();
					if(fcurrentSpeed == 0.0f)
					{
						dof->setAnimationOn(false);
					}
					else
					{
						dof->setAnimationOn(true);
						dof->setIncrementTranslate(m_stepTrans * (fcurrentSpeed*m_trackSpeedScale));
					}
					dofcallback = dynamic_cast<crDofUniformTexMatCallback *>(dofcallback->getNestedCallback("DofUniformTexMat"));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crViewPitchWobbleMethod
//
/////////////////////////////////////////
crViewPitchWobbleMethod::crViewPitchWobbleMethod():
m_wobble(-0.02f),
m_comebackTime(1.0f){}
crViewPitchWobbleMethod::crViewPitchWobbleMethod(const crViewPitchWobbleMethod& handle):
crMethod(handle),
m_wobble(handle.m_wobble),
m_comebackTime(handle.m_comebackTime)
{
}
void crViewPitchWobbleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crViewPitchWobbleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_wobble = atof(str.c_str());
		break;
	case 1:
		m_comebackTime = atof(str.c_str());
		break;
	}
}

void crViewPitchWobbleMethod::operator()(crHandle &handle)
{//汽车类交互
	if(m_this)
	{
		crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		float viewPitch = bot->getViewPitch();
		bot->setViewPitch(viewPitch+m_wobble);
		bot->setTargetViewPitch(viewPitch,m_comebackTime);
	}
}
///////////////////////////////////////////
////
////crCreateTankAimMethod
////
///////////////////////////////////////////
//crCreateTankAimMethod::crCreateTankAimMethod():
//m_r(0.5f),
//m_step(360){}
//crCreateTankAimMethod::crCreateTankAimMethod(const crCreateTankAimMethod& handle):
//crMethod(handle),
//m_r(handle.m_r),
//m_step(handle.m_step)
//{
//}
//void crCreateTankAimMethod::inputParam(int i, void *param)
//{
//}
//
//void crCreateTankAimMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_r = atof(str.c_str());
//		break;
//	case 1:
//		m_step = atoi(str.c_str());
//		break;
//	}
//}
//
//void crCreateTankAimMethod::operator()(crHandle &handle)
//{//
//	crObject* object = new crObject;
//	crGeometry* geom = new crGeometry;
//	crStateSet *stateset = geom->getOrCreateStateSet(); 
//	crLineWidth *lineWidth = new crLineWidth(2.0f);
//	stateset->setAttributeAndModes(lineWidth,crStateAttribute::ON);
//	
//	float viewWidth = crDisplaySettings::instance()->getViewWidth();
//	float viewHeight = crDisplaySettings::instance()->getViewHeight();
//	float widthRatio = crDisplaySettings::instance()->getWidthScale();
//	float heightRatio = viewWidth/viewHeight;//crDisplaySettings::instance()->getStandardWinRatio();
//	crMatrix scaleMat = crMatrix::scale(widthRatio,heightRatio * widthRatio,1.0f);
//
//	Vec3Array* coords = new Vec3Array(360);
//	float D2R = PI*2.0f/(float)(m_step);
//	crVector3 coord(0,0,1);
//	for ( int i=0; i<m_step+1; i++ ) 
//	{ 
//		float DegInRad = i*D2R; 
//
//		coord[0] = m_r * cos(DegInRad); 
//		coord[1] = m_r * sin(DegInRad); 
//
//		(*coords)[i] = coord * scaleMat;
//	} 
//	geom->setVertexArray(coords);
//	geom->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
//	geom->setColorBinding(crGeometry::BIND_OVERALL);
//
//	geom->setNormalBinding(crGeometry::BIND_OFF);
//	geom->addPrimitive(new DrawArrays(crPrimitive::PT_LINE_LOOP,0,m_step+1));
//
//	object->addDrawable(geom);
//	object->setName("AimCircle");
//	crLoadManager::getInstance()->requestAddNode(crFilterRenderManager::getInstance()->getMainCanvas(),object,true);
//	////object->setEnableIntersect(false);
//	//crMatrixTransform *matrixTransform = new crMatrixTransform;
//	//matrixTransform->addChild(object);
//	//matrixTransform->setName("EditorAxis");
//}
/////////////////////////////////////////
//
//crRemoveRoleMethod
//
/////////////////////////////////////////
crRemoveRoleMethod::crRemoveRoleMethod()
{
}

crRemoveRoleMethod::crRemoveRoleMethod(const crRemoveRoleMethod& handle):
crMethod(handle)
{
}

void crRemoveRoleMethod::inputParam(int i, void *param)
{
}

void crRemoveRoleMethod::addParam(int i, const std::string& str)
{
}

void crRemoveRoleMethod::operator()(crHandle &handle)
{
	crRole *role = crMyPlayerData::getInstance()->getSelectedGameRole();
	if(role)
	{
		std::string code = "CreRemoveRole";
		crRemoveRolePacket packet;
		crRemoveRolePacket::buildRequestPacket(packet,role->getRoleID(),code);
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvRemoveRoleMethod
//
/////////////////////////////////////////
crRecvRemoveRoleMethod::crRecvRemoveRoleMethod():
m_roleid(0),
m_sucess(false)
{
}

crRecvRemoveRoleMethod::crRecvRemoveRoleMethod(const crRecvRemoveRoleMethod& handle):
crMethod(handle),
m_roleid(0),
m_sucess(false)
{
}

void crRecvRemoveRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_roleid = LOINT64(param64);
			m_sucess = HIINT64(param64) != 0;
		}
		break;
	}
}

void crRecvRemoveRoleMethod::addParam(int i, const std::string& str)
{
}

void crRecvRemoveRoleMethod::operator()(crHandle &handle)
{
	if(m_sucess)
	{
		crMyPlayerData::getInstance()->removeGameRole(m_roleid);
	}
	else
	{
		//std::string str = "删除角色失败";
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(25,NULL));
	}
}
/////////////////////////////////////////
//
//crCheckGameRolesIsLoadedMethod
//
/////////////////////////////////////////
crCheckGameRolesIsLoadedMethod::crCheckGameRolesIsLoadedMethod(){}
crCheckGameRolesIsLoadedMethod::crCheckGameRolesIsLoadedMethod(const crCheckGameRolesIsLoadedMethod& handle):
crMethod(handle)
{
}
void crCheckGameRolesIsLoadedMethod::inputParam(int i, void *param)
{
}
void crCheckGameRolesIsLoadedMethod::addParam(int i, const std::string& str)
{
}
void crCheckGameRolesIsLoadedMethod::operator()(crHandle &handle)
{
	bool loaded = true;
	crMyPlayerData::getInstance()->lockGameRoleMap();
	GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
	crRole *role;
	for( GameRoleMap::iterator itr = gameRoleMap.begin();
		itr != gameRoleMap.end();
		++itr )
	{
		role = itr->second.get();
		if(!role->getNode())
		{
			loaded = false;
			break;
		}
	}
	crMyPlayerData::getInstance()->unlockGameRoleMap();
	handle.outputParam(0,&loaded);
}
/////////////////////////////////////////
//
//crSetSelectedRoomMethod
//
/////////////////////////////////////////
crSetSelectedRoomMethod::crSetSelectedRoomMethod(){}
crSetSelectedRoomMethod::crSetSelectedRoomMethod(const crSetSelectedRoomMethod& handle):
	crMethod(handle)
{
}
void crSetSelectedRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crTableWidgetNode*)param;
		break;
	}
}

void crSetSelectedRoomMethod::addParam(int i, const std::string& str)
{
}

void crSetSelectedRoomMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int i = m_this->getSelect();
		if(i>=0)
		{
			unsigned int currentSelect = m_this->getSelect();
			crMyPlayerData::getInstance()->lockRoomMap();
			RoomMap &roomMap = crMyPlayerData::getInstance()->getRoomMap();
			for( RoomMap::iterator itr = roomMap.begin();
				itr != roomMap.end();
				++itr,--currentSelect)
			{
				if(currentSelect == 0)
				{
					crMyPlayerData::getInstance()->setSelectedRoom(itr->second.get());
					break;
				}
			}
			crMyPlayerData::getInstance()->unlockRoomMap();
		}
	}
}
/////////////////////////////////////////
//
//crEnterSceneRoomMethod
//
/////////////////////////////////////////
crEnterSceneRoomMethod::crEnterSceneRoomMethod(){}
crEnterSceneRoomMethod::crEnterSceneRoomMethod(const crEnterSceneRoomMethod& handle):
crMethod(handle)
{
}
void crEnterSceneRoomMethod::inputParam(int i, void *param)
{
}

void crEnterSceneRoomMethod::addParam(int i, const std::string& str)
{
}

void crEnterSceneRoomMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(room)
	{
		crEnterSceneRoomPacket packet;
		crEnterSceneRoomPacket::buildRequestPacket(packet,room->getRoomID());
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvAboutToUseItemMethod
//
/////////////////////////////////////////
crRecvAboutToUseItemMethod::crRecvAboutToUseItemMethod():
m_netType(GameClient_Game){}
crRecvAboutToUseItemMethod::crRecvAboutToUseItemMethod(const crRecvAboutToUseItemMethod& handle):
crMethod(handle)
{
}
void crRecvAboutToUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvAboutToUseItemMethod::addParam(int i, const std::string& str)
{
}

void crRecvAboutToUseItemMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		int itemid = m_stream->_readInt();
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_AboutToUseItemID,&itemid);
	}
}
///////////////////////////////////////////
////
////crItemUpdateTravelMethod
////
///////////////////////////////////////////
//crItemUpdateTravelMethod::crItemUpdateTravelMethod():
//m_dt(0.0f){}
//crItemUpdateTravelMethod::crItemUpdateTravelMethod(const crItemUpdateTravelMethod& handle):
//crMethod(handle),
//m_dt(0.0f)
//{
//}
//void crItemUpdateTravelMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((float*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0.0f;
//		}
//		break;
//	}
//}
//
//void crItemUpdateTravelMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crItemUpdateTravelMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_dt>0.0f)
//	{
//		m_this->update(m_dt);
//	}
//}
/////////////////////////////////////////
//
//crCheckPlayerGameNameMethod
//
/////////////////////////////////////////
crCheckPlayerGameNameMethod::crCheckPlayerGameNameMethod(){}
crCheckPlayerGameNameMethod::crCheckPlayerGameNameMethod(const crCheckPlayerGameNameMethod& handle):
crMethod(handle),
m_nameWidget(handle.m_nameWidget)
{
}
void crCheckPlayerGameNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crCheckPlayerGameNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameWidget = str;
		break;
	}
}

void crCheckPlayerGameNameMethod::operator()(crHandle &handle)
{
	//bool cancelTask = true;
	//if(m_this)
	//{
	crCanvasNode *canvas = m_this->getParentCanvas();
	crEditWidgetNode *nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_nameWidget));
	if(nameWidget)
	{
		std::string name = crArgumentParser::trim(const_cast<char *>(nameWidget->getUTF8String().c_str()));
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!name.empty() && netConductor)
		{
			//crWaitNetReturnStreamLogic::getLock();
			crCheckPlayerGameNamePacket packet;
			crCheckPlayerGameNamePacket::buildRequestPacket(packet,name);
			netConductor->getNetManager()->sendPacket("all",packet);
			//cancelTask = false;
		}
	}
	//}
	//handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crNetReturnStreamMethod
//
/////////////////////////////////////////
crNetReturnStreamMethod::crNetReturnStreamMethod(){}
crNetReturnStreamMethod::crNetReturnStreamMethod(const crNetReturnStreamMethod& handle):
	crMethod(handle)
{
}
void crNetReturnStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		break;
	}
}

void crNetReturnStreamMethod::addParam(int i, const std::string& str)
{
}

void crNetReturnStreamMethod::operator()(crHandle &handle)
{
	crWaitNetReturnStreamLogic::netReturn(m_stream.get());
}
/////////////////////////////////////////
//
//crChangeWidgetTextColorMethod
//
/////////////////////////////////////////
crChangeWidgetTextColorMethod::crChangeWidgetTextColorMethod(){}
crChangeWidgetTextColorMethod::crChangeWidgetTextColorMethod(const crChangeWidgetTextColorMethod& handle):
	crMethod(handle),
	m_nameWidget(handle.m_nameWidget),
	m_color(handle.m_color)
{
}
void crChangeWidgetTextColorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crChangeWidgetTextColorMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameWidget = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}

void crChangeWidgetTextColorMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		ref_ptr<crTextAttrWidgetNode> texWidget = dynamic_cast<crTextAttrWidgetNode *>(canvas->getWidget(m_nameWidget));
		if(texWidget.valid())
		{
			texWidget->setColor(m_color);
		}
	}
}
/////////////////////////////////////////
//
//crChangeWidgetTextColor2Method
//
/////////////////////////////////////////
crChangeWidgetTextColor2Method::crChangeWidgetTextColor2Method(){}
crChangeWidgetTextColor2Method::crChangeWidgetTextColor2Method(const crChangeWidgetTextColor2Method& handle):
	crMethod(handle),
	m_color(handle.m_color)
{
}
void crChangeWidgetTextColor2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crTextAttrWidgetNode*)param;
		break;
	}
}

void crChangeWidgetTextColor2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}

void crChangeWidgetTextColor2Method::operator()(crHandle &handle)
{
	if(m_this)
	{
		m_this->setColor(m_color);
	}
}
/////////////////////////////////////////
//
//crChangeWidgetTextColor3Method
//
/////////////////////////////////////////
crChangeWidgetTextColor3Method::crChangeWidgetTextColor3Method(){}
crChangeWidgetTextColor3Method::crChangeWidgetTextColor3Method(const crChangeWidgetTextColor3Method& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_nameWidget(handle.m_nameWidget),
	m_color(handle.m_color)
{
}
void crChangeWidgetTextColor3Method::inputParam(int i, void *param)
{
}
void crChangeWidgetTextColor3Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_nameWidget = str;
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}
void crChangeWidgetTextColor3Method::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvas.valid())
	{
		ref_ptr<crTextAttrWidgetNode>texWidget = dynamic_cast<crTextAttrWidgetNode *>(canvas->getWidget(m_nameWidget));
		if(texWidget.valid())
		{
			texWidget->setColor(m_color);
		}
	}
}
/////////////////////////////////////////
//
//crEditWidgetInputSizeCheckMethod
//
/////////////////////////////////////////
crEditWidgetInputSizeCheckMethod::crEditWidgetInputSizeCheckMethod(){}
crEditWidgetInputSizeCheckMethod::crEditWidgetInputSizeCheckMethod(const crEditWidgetInputSizeCheckMethod& handle):
	crMethod(handle),
	m_maxsize(handle.m_maxsize)
{
}
void crEditWidgetInputSizeCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode*)param;
		break;
	}
}

void crEditWidgetInputSizeCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_maxsize = atoi(str.c_str());
		break;
	}
}

void crEditWidgetInputSizeCheckMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		std::string str = m_this->getUTF8String();
		if(str.size()>m_maxsize)
		{
			str = str.substr(0,m_maxsize);
			m_this->setString(str);
		}
	}
}
/////////////////////////////////////////
//
//crCreatePlayerGameDataMethod
//
/////////////////////////////////////////
crCreatePlayerGameDataMethod::crCreatePlayerGameDataMethod(){}
crCreatePlayerGameDataMethod::crCreatePlayerGameDataMethod(const crCreatePlayerGameDataMethod& handle):
	crMethod(handle)
{
}
void crCreatePlayerGameDataMethod::inputParam(int i, void *param)
{
}
void crCreatePlayerGameDataMethod::addParam(int i, const std::string& str)
{
}
void crCreatePlayerGameDataMethod::operator()(crHandle &handle)
{
	//crWaitNetReturnStreamLogic::getLock();
	crCreatePlayerGameDataPacket packet;
	crCreatePlayerGameDataPacket::buildRequestPacket(packet);
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crPlayerDataCreateStreamMethod
//
/////////////////////////////////////////
crPlayerDataCreateStreamMethod::crPlayerDataCreateStreamMethod(){}
crPlayerDataCreateStreamMethod::crPlayerDataCreateStreamMethod(const crPlayerDataCreateStreamMethod& handle):
	crMethod(handle)
{
}
void crPlayerDataCreateStreamMethod::inputParam(int i, void *param)
{
}
void crPlayerDataCreateStreamMethod::addParam(int i, const std::string& str)
{
}
void crPlayerDataCreateStreamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		crData *data = playerData->getDataClass();
		//void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		data->excHandle(MAKEINT64(WCH_BuildCreateStream,stream.get()));
		//data->getParam(WCHDATA_DataStream,param);
		//if(param)
		//{
			//ref_ptr<crStreamBuf> stream = *((ref_ptr<crStreamBuf>*)param);
			crPlayerDataCreateStreamPacket packet;
			crPlayerDataCreateStreamPacket::buildRequestPacket(packet,stream.get());
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);
		//}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crLoadLocalSceneMethod
//
/////////////////////////////////////////
crLoadLocalSceneMethod::crLoadLocalSceneMethod(){}
crLoadLocalSceneMethod::crLoadLocalSceneMethod(const crLoadLocalSceneMethod& handle):
	crMethod(handle)
{
}
void crLoadLocalSceneMethod::inputParam(int i, void *param)
{
}
void crLoadLocalSceneMethod::addParam(int i, const std::string& str)
{
}
void crLoadLocalSceneMethod::operator()(crHandle &handle)
{
	do 
	{
		//const std::string &gameName = crMyPlayerData::getInstance()->getSelectedGame()->getGameName();
		//std::string tabfile = gameName + "/sceneitem.tab";
		//ref_ptr<crTableIO> sceneItemTab = new crTableIO;
		//if(!sceneItemTab->openFile(tabfile))
		//	break;
		//tabfile = gameName + "/abstractitem.tab";
		//ref_ptr<crTableIO> abstractItemTab = new crTableIO;
		//if(!abstractItemTab->openFile(tabfile))
		//	break;
		//tabfile = gameName + "/res.tab";
		//ref_ptr<crTableIO> resTab = new crTableIO;
		//if(!resTab->openFile(tabfile))
		//	break;
		//tabfile = gameName + "/scene.tab";
		//ref_ptr<crTableIO> sceneTable = new crTableIO;
		//if(!sceneTable->openFile(tabfile))
		//	break;
		ref_ptr<crTableIO>sceneItemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_InstranceItemTab);
		ref_ptr<crTableIO>abstractItemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_AbstractItemTab);
		ref_ptr<crTableIO>resTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_ResTab);
		ref_ptr<crTableIO>sceneTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
		crData *data = crRunGameHandle::getInstance()->getDataClass();
		void *param;
		data->getParam(WCHDATA_SceneID,param);
		short sceneid = *(short *)param;
		crTableIO::StrVec record;
		if(sceneTable.valid() && sceneTable->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
		{
			//int row = sceneTable->getRowByID(sceneid);
			std::string sceneName = record[1];//sceneTable->getData(row,3);
			std::string sceneFile = record[2];//sceneTable->getData(row,1);
			std::string collideFile = record[4];
			std::string brainfile = record[5];
			crMyPlayerData::getInstance()->createScene(sceneid,sceneName,sceneFile,collideFile,brainfile);
			crScene *scene = crMyPlayerData::getInstance()->getScene();

			crTableIO::DataVec records;
			sceneItemTab->queryRecords(sceneItemTab->getTitleIndex("sceneid"),crArgumentParser::appItoa(sceneid),records);
			ref_ptr<crInstanceItem> item;
			ref_ptr<crAbstractItem> aitem;
			int abstractid,resid;
			crVector3 dir;
			float zoffset,posx,posy,posz;
			float unitScale = crGlobalHandle::getInstance()->gData()->gUnitScale();
			//char gbuf[256];
			for( crTableIO::DataVec::iterator itr = records.begin();
				 itr != records.end();
				 ++itr )
			{
				item = new crInstanceItem;
				item->setInstanceItemID(atoi((*itr)[0].c_str()));
				abstractid = atoi((*itr)[1].c_str());
				item->setAbstractItemID(abstractid);
				item->setItemtype(atoi((*itr)[2].c_str()));
				item->setIName((*itr)[3]);
				item->setSceneID(atoi((*itr)[4].c_str()));
				item->setLayerID(atoi((*itr)[5].c_str()));
				//crArgumentParser::appAtoVec((*itr)[6],posxy);
				//posxy /= unitScale;
				//item->setPosxy(posxy[0],posxy[1]);
				posx = atof((*itr)[6].c_str())/unitScale;
				posy = atof((*itr)[7].c_str())/unitScale;
				item->setPosxy(posx,posy);
				zoffset = atof((*itr)[8].c_str())/unitScale;
				item->setZoffset(zoffset);
				posz = scene->getPosZ(item->getLayerID(),item->getPosx() * unitScale,item->getPosy() * unitScale, item->getZoffset() * unitScale);
				item->setPosz(posz / unitScale);
				dir[0] = atof((*itr)[9].c_str());
				dir[1] = atof((*itr)[10].c_str());
				dir[2] = atof((*itr)[11].c_str());
				//crArgumentParser::appAtoVec((*itr)[9],dir);
				item->setDir(dir);

				abstractItemTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record);
				aitem = item->getAbstractItem();
				aitem->setAbstractItemID(abstractid);
				resid = atoi(record[1].c_str());
				aitem->setName(record[2]);
				aitem->setScript(record[3]);
				resTab->queryOneRecord(0,crArgumentParser::appItoa(resid),record);
				aitem->setResID(resid);
				aitem->setFileName(record[1]);
				//aitem->setUpdatecfg(record[2]);
				aitem->setResScript(record[2]);
				//item->loadItemData(SaveStream);
				//scene->insertSceneItem(item.get());
				//sprintf(gbuf,"LoadLocalSceneItem %s,%d\n\0",item->getIName().c_str(),(int)(item->getItemtype()));
				//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
				if(item->getAbstractItem())
					crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
				else
					crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
			}
		}
	} while (0);
}
/////////////////////////////////////////
//
//crRecordMousePosMethod
//
/////////////////////////////////////////
crRecordMousePosMethod::crRecordMousePosMethod()
{
}

crRecordMousePosMethod::crRecordMousePosMethod(const crRecordMousePosMethod& handle):
	crMethod(handle)
{
}

void crRecordMousePosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(m_param));
		}
		else
		{
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	}
}
void crRecordMousePosMethod::addParam(int i, const std::string& str)
{
}
void crRecordMousePosMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		crVector3 mousepos(m_ea->getXnormalized(),m_ea->getYnormalized(),0.0f);
		crVector3 winpos = crFilterRenderManager::getInstance()->getWindowPosition(mousepos);
		crVector3i mouse(winpos[0],winpos[1],1);
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_MousePosRec,&mouse);
	}
}
/////////////////////////////////////////
//
//crInvalidMousePosMethod
//
/////////////////////////////////////////
crInvalidMousePosMethod::crInvalidMousePosMethod()
{
}

crInvalidMousePosMethod::crInvalidMousePosMethod(const crInvalidMousePosMethod& handle):
	crMethod(handle)
{
}

void crInvalidMousePosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(m_param));
		}
		else
		{
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	}
}

void crInvalidMousePosMethod::addParam(int i, const std::string& str)
{
}

void crInvalidMousePosMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_MousePosRec,NULL);
		crDrawable *rectGeo = crFilterRenderManager::getInstance()->getDrawable("#DrawDragRect");
		if(rectGeo)
			rectGeo->setVisiable(false);
	}
}
/////////////////////////////////////////
//
//crDrawDragRectMethod
//
/////////////////////////////////////////
crDrawDragRectMethod::crDrawDragRectMethod():
	m_init(false),
	m_coords(NULL),
	m_coords_buf(NULL)
{
}

crDrawDragRectMethod::crDrawDragRectMethod(const crDrawDragRectMethod& handle):
	crNodeMethod(handle),
	m_init(false),
	m_lineColor(handle.m_lineColor),
	m_coords(NULL),
	m_coords_buf(NULL)
{
}

void crDrawDragRectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(m_param));
		}
		else
		{
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	}
}

void crDrawDragRectMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_lineColor);
		m_lineColor /= 255.0f;
		break;
	}
}
void crDrawDragRectMethod::init()
{
	m_rectGeo = new crGeometry;
	m_rectGeo->setName("#DrawDragRect");
	crStateSet *stateset = m_rectGeo->getOrCreateStateSet(); 
	crLineWidth *lineWidth = new crLineWidth(2.0f);
	stateset->setAttributeAndModes(lineWidth,crStateAttribute::ON);
	m_rectGeo->setNormalBinding(crGeometry::BIND_OFF);
	m_rectGeo->addPrimitive(new DrawArrays(crPrimitive::PT_LINE_LOOP,0,4));
	m_rectGeo->setUseVertexBufferObjects(false);
	m_rectGeo->setUseDisplayList(false);
	m_rectGeo->setColor(m_lineColor);
	m_coords = new CRCore::Vec3Array(4);
	m_coords_buf = new CRCore::Vec3Array(4);
	m_rectGeo->setVisiable(false);
	m_rectGeo->setVertexArray(m_coords_buf);
	m_rectGeo->setBoundBox(crVector3(0,0,0),crVector3(crDisplaySettings::instance()->getViewWidth()*0.5f,crDisplaySettings::instance()->getViewHeight()*0.5f,0));
	crFilterRenderManager::getInstance()->addDrawable(m_rectGeo.get(),true);
	m_init = true;
}
void crDrawDragRectMethod::operator()(crHandle &handle)
{
	if(!m_init)
		init();
	crVector3 mousepos(m_ea->getXnormalized(),m_ea->getYnormalized(),0.0f);
	crVector3 winpos = crFilterRenderManager::getInstance()->getWindowPosition(mousepos);
	crVector3i mouse2(winpos[0],winpos[1],1);

	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_MousePosRec,param);
	crVector3i mouse1 = *(crVector3i *)param;
	if(mouse1[2] == 0)
	{
		data->inputParam(WCHDATA_MousePosRec,&mouse2);
	}
	else
	{//绘线
		(*m_coords)[0] = crVector3(mouse1[0],mouse1[1],0.0f);
		(*m_coords)[1] = crVector3(mouse2[0],mouse1[1],0.0f);
		(*m_coords)[2] = crVector3(mouse2[0],mouse2[1],0.0f);
		(*m_coords)[3] = crVector3(mouse1[0],mouse2[1],0.0f);
		m_rectGeo->setVisiable(true);
	}
}
void crDrawDragRectMethod::releaseObjects(crState* statte)
{
	if(m_rectGeo.valid())
	{
		crFilterRenderManager::getInstance()->removeDrawable(m_rectGeo.get());
		m_rectGeo->releaseObjects(statte);
	}
	m_init = false;
}
void crDrawDragRectMethod::swapBuffers(int frameNumber)
{
	if(m_init)
	{
		*m_coords_buf = *m_coords;
	}
}
/////////////////////////////////////////
//
//crRectSelectItemMethod
//
/////////////////////////////////////////
crRectSelectItemMethod::crRectSelectItemMethod():
	m_timer(0L)
{
}
crRectSelectItemMethod::crRectSelectItemMethod(const crRectSelectItemMethod& handle):
	crMethod(handle),
	m_timer(0L)
{
}
void crRectSelectItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(m_param));
		}
		else
		{
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	}
}
void crRectSelectItemMethod::addParam(int i, const std::string& str)
{
}
void crRectSelectItemMethod::operator()(crHandle &handle)
{
	CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
	float dt = CRCore::Timer::instance()->delta_s( m_timer, t1 );
	if(dt>0.05f)
	{
		m_timer = t1;
		crVector3 mousepos(m_ea->getXnormalized(),m_ea->getYnormalized(),0.0f);
		crVector3 winpos = crFilterRenderManager::getInstance()->getWindowPosition(mousepos);
		crVector3i mouse2(winpos[0],winpos[1],1);

		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_MousePosRec,param);
		crVector3i mouse1 = *(crVector3i *)param;
		if(mouse1[2] == 0)
		{
			data->inputParam(WCHDATA_MousePosRec,&mouse2);
		}
		else
		{//
			crVector4i rect(mouse1[0],mouse1[1],mouse2[0],mouse2[1]);
			std::vector<crInstanceItem *>ItemVec;
			crMyPlayerData::getInstance()->rectSelectItem(rect,ItemVec);
			if(!ItemVec.empty())
			{
				if(!(m_ea->getModKeyMask() & crGUIEventAdapter::MODKEY_SHIFT))
				{//清除之前选中的自己人
					void *param;
					crData *cameraData = m_this->getDataClass();
					cameraData->excHandle(MAKEINT64(WCH_LockData,1));
					cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
					crNode *fxNode;
					crDecalUpdateCallback *callback;
					//crSelectNodeVisitor selectNode(false);
					SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
					for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
						itr != selectMyRoles->end();
						++itr )
					{
						//bot = (*itr)->getRelNode();
						//bot->accept(selectNode);
						fxNode = (*itr)->findSceneFxNode("$SelectDecal");
						if(fxNode)
						{
							callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
							if(callback)
							{
								callback->setVisiable(false);
							}
						}
					}
					selectMyRoles->resize(0);
					cameraData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				for( std::vector<crInstanceItem *>::iterator itr = ItemVec.begin();
					itr != ItemVec.end();
					++itr )
				{
					(*itr)->doEvent(WCH_Touch,MAKEINT64(m_ea,m_this));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRectSelectNodeMethod
//
/////////////////////////////////////////
crRectSelectNodeMethod::crRectSelectNodeMethod():
	m_timer(0L)
{
}
crRectSelectNodeMethod::crRectSelectNodeMethod(const crRectSelectNodeMethod& handle):
	crMethod(handle),
	m_timer(0L)
{
}
void crRectSelectNodeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(m_param));
		}
		else
		{
			m_ea = NULL;
			m_param = NULL;
		}
		break;
	}
}
void crRectSelectNodeMethod::addParam(int i, const std::string& str)
{
}
void crRectSelectNodeMethod::operator()(crHandle &handle)
{
	CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
	float dt = CRCore::Timer::instance()->delta_s( m_timer, t1 );
	if(dt>0.05f)
	{
		m_timer = t1;
		crVector3 mousepos(m_ea->getXnormalized(),m_ea->getYnormalized(),0.0f);
		crVector3 winpos = crFilterRenderManager::getInstance()->getWindowPosition(mousepos);
		crVector3i mouse2(winpos[0],winpos[1],1);

		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_MousePosRec,param);
		crVector3i mouse1 = *(crVector3i *)param;
		if(mouse1[2] == 0)
		{
			data->inputParam(WCHDATA_MousePosRec,&mouse2);
		}
		else
		{//
			crVector4i rect(mouse1[0],mouse1[1],mouse2[0],mouse2[1]);
			std::vector<crNode *>ItemVec;
			crViewMatterObject *body = crSceneManager::getInstance()->getPlayer();
			crGameBodyInfo *bodyInfo = body->getGameBodyInfo();
			crData *infoData = bodyInfo->getDataClass();
			void *param;
			infoData->getParam(EDP_SelectType,param);
			int selectType = *((int*)param);
			if(selectType>=0)
			{
				bodyInfo->unSelectAll();
				crRectSelectNodeVisitor selecter;
				selecter.setSelectType(selectType);
				infoData->getParam(EDP_SelectClassName,param);
				std::string classname = *(std::string *)param;
				selecter.setSelectClassName(classname);
				selecter.setRect(rect);
				//crSceneManager::getInstance()->getStaticRoot()->accept(selecter);
				crBrain::getInstance()->accept(selecter);
				crRectSelectNodeVisitor::SelectNodeVec &selectNodeVec = selecter.getResult();
				ref_ptr<crData> data;
				for( crRectSelectNodeVisitor::SelectNodeVec::iterator itr = selectNodeVec.begin();
					 itr != selectNodeVec.end();
					 ++itr )
				{
					if(!bodyInfo->isNodeSelected(itr->get()))
					{
						data = (*itr)->getDataClass();
						if(!data.valid())
						{
							data = crDataManager::getInstance()->getData("Event");
							(*itr)->setDataClass(data.get());
						}
						if(!data->getHandle(MAKEINT64(WCH_SELECTNODE,NULL)))
						{
							crHandle *driver = crHandleManager::getInstance()->getHandle("OneSlot");
							driver->inputHandle(0,crHandleManager::getInstance()->getHandle("SelectNodeMaterial"));
							data->insertHandle(MAKEINT64(WCH_SELECTNODE,NULL),driver);
							data->insertHandle(MAKEINT64(WCH_UNSELECTNODE,NULL),driver);
						}
						bodyInfo->selectNode(itr->get());
					}
				}
			}
		//	crMyPlayerData::getInstance()->rectSelectItem(rect,ItemVec);
		}
	}
}
/////////////////////////////////////////
//
//crWaypointLinkMethod
//
/////////////////////////////////////////
crWaypointLinkMethod::crWaypointLinkMethod():
	m_connect(true)
{
}
crWaypointLinkMethod::crWaypointLinkMethod(const crWaypointLinkMethod& handle):
	crMethod(handle),
	m_connect(handle.m_connect)
{
}
void crWaypointLinkMethod::inputParam(int i, void *param)
{
}
void crWaypointLinkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_connect = (bool)(atoi(str.c_str()));
		break;
	}
}
void crWaypointLinkMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	crCamera *camera = crCameraManager::getInstance()->getMainCamera();
	if(layer && camera)
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		if(cameraData)
		{
			void *param;
			cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			cameraData->getParam(WCHDATA_WaypointNodeMap,param);
			WaypointNodeMap *waypointNodeMap = (WaypointNodeMap *)param;
			if(waypointNodeMap)
			{
				//cameraData->getParam(WCHDATA_WaypointRoot,param);
				crWaypoint *waypointRoot = layer->getWaypointRoot();
				crScene *scene = crMyPlayerData::getInstance()->getScene();
				crViewMatterObject *body = crSceneManager::getInstance()->getPlayer();
				crGameBodyInfo *bodyInfo = body->getGameBodyInfo();
				crData *infoData = bodyInfo->getDataClass();
				std::set<crWaypoint *>SelectWayPoints;
				ref_ptr<crMatrixTransform> matnode;
				
				crVector3 pos;
				crVector2s coord;
				crGameBodyInfo::SelectNodeVec& selectNodeVec = bodyInfo->getSelectNodeVec();
				for( crGameBodyInfo::SelectNodeVec::iterator itr = selectNodeVec.begin();
					 itr != selectNodeVec.end();
					 ++itr )
				{
					matnode = dynamic_cast<crMatrixTransform *>(itr->get());
					if(matnode.valid() && matnode->getName().compare("#Waypoint") == 0)
					{
						pos = matnode->getTrans();
						pos[2] = scene->getPosZ(0,pos[0],pos[1],0.0f);
						matnode->setPosition(pos);
						ref_ptr<crWaypoint>&waypoint = (*waypointNodeMap)[matnode];
						if(!waypoint.valid())
						{
							waypoint = new crWaypoint;
							if(!waypointRoot)
							{
								waypointRoot = waypoint.get();
								layer->setWaypointRoot(waypointRoot);
								//cameraData->inputParam(WCHDATA_WaypointRoot,waypointRoot);
							}
						}
						waypoint->setPoint(layer->getCoord(pos[0],pos[1]));
						SelectWayPoints.insert(waypoint.get());
					}
				}
				std::set<crWaypoint *>::iterator itr1,itr2;
				crWaypoint *wp1,*wp2;
				for( itr1 = SelectWayPoints.begin();
					 itr1 != SelectWayPoints.end();
					 ++itr1 )
				{
					wp1 = *itr1;
					itr2 = itr1;
					for( ++itr2; itr2 != SelectWayPoints.end();	++itr2 )
					{
						wp2 = *itr2;
						if(m_connect)
							wp1->connectWaypoint(wp2);
						else
							wp1->disconnectWaypoint(wp2);
					}
				}
			}
			cameraData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crWaypointSaveMethod
//
/////////////////////////////////////////
crWaypointSaveMethod::crWaypointSaveMethod(){}
crWaypointSaveMethod::crWaypointSaveMethod(const crWaypointSaveMethod& handle):
	crMethod(handle),
	m_filePath(handle.m_filePath)
{
}
void crWaypointSaveMethod::inputParam(int i, void *param)
{
}
void crWaypointSaveMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_filePath = str;
		break;
	}
}

void crWaypointSaveMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	if(layer)
	{
		CREncapsulation::crScene *scene = crSceneManager::getInstance()->getCurrentScene();
		std::string fileName = scene->getSceneFileName();
		if(fileName.find("NewScene")==std::string::npos)
		{
			std::string file = m_filePath + fileName;
			file = crArgumentParser::getFileNameEliminateExt(file) + ".crp";
			//save
			crCamera *camera = crCameraManager::getInstance()->getMainCamera();
			if(camera)
			{
				crData *cameraData = camera->getAttachedNode()->getDataClass();
				if(cameraData)
				{
					//void *param;
					//cameraData->getParam(WCHDATA_WaypointRoot,param);
					crWaypoint *waypointRoot = layer->getWaypointRoot();
					if(waypointRoot)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(1024);
						waypointRoot->write(stream.get());
						waypointRoot->endtravel();
						stream->seekBegin();
						stream->saveToFile2(file);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crWaypointAutoSaveMethod
//
/////////////////////////////////////////
crWaypointAutoSaveMethod::crWaypointAutoSaveMethod(){}
crWaypointAutoSaveMethod::crWaypointAutoSaveMethod(const crWaypointAutoSaveMethod& handle):
	crMethod(handle),
	m_fileName(handle.m_fileName)
{
}
void crWaypointAutoSaveMethod::inputParam(int i, void *param)
{
}
void crWaypointAutoSaveMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_fileName = str;
		break;
	}
}

void crWaypointAutoSaveMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	if(layer)
	{
		//save
		crCamera *camera = crCameraManager::getInstance()->getMainCamera();
		if(camera)
		{
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			if(cameraData)
			{
				//void *param;
				//cameraData->getParam(WCHDATA_WaypointRoot,param);
				crWaypoint *waypointRoot = layer->getWaypointRoot();
				if(waypointRoot)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1024);
					waypointRoot->write(stream.get());
					waypointRoot->endtravel();
					stream->seekBegin();
					stream->saveToFile2(m_fileName);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crWaypointLoadMethod
//
/////////////////////////////////////////
crWaypointLoadMethod::crWaypointLoadMethod()
{
}
crWaypointLoadMethod::crWaypointLoadMethod(const crWaypointLoadMethod& handle):
	crMethod(handle),
	m_filePath(handle.m_filePath)
{
}
void crWaypointLoadMethod::inputParam(int i, void *param)
{
}
void crWaypointLoadMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_filePath = str;
		break;
	}
}
void crWaypointLoadMethod::operator()(crHandle &handle)
{
	CREncapsulation::crScene *scene = crSceneManager::getInstance()->getCurrentScene();
	std::string fileName = scene->getSceneFileName();
	std::string scenefile = m_filePath + fileName;
	//std::string wpfile = crArgumentParser::getFileNameEliminateExt(scenefile) + ".crp";
	//crCamera *camera = crCameraManager::getInstance()->getMainCamera();
	//crData *cameraData = NULL;
	//ref_ptr<crWaypoint> waypointRoot;
	//if(camera)
	//{
	//	cameraData = camera->getAttachedNode()->getDataClass();
	//	if(cameraData)
	//	{
	//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
	//		if(stream->loadFromFile2(wpfile))
	//		{
	//			waypointRoot = crWaypoint::beginread(stream.get());
	//			waypointRoot->read(stream.get());
	//			waypointRoot->endread();
	//			cameraData->inputParam(WCHDATA_WaypointRoot,waypointRoot.get());
	//		}
	//	}
	//}
	std::string collidefile = crArgumentParser::getFileNameEliminateExt(scenefile) + "collide.cfg";
	crMyPlayerData::getInstance()->createScene(0,"EditorScene",m_filePath + fileName,collidefile,"EditorBrain.cfg");
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	if(layer)
	{
		ref_ptr<crTexture2D>tex2d = new crTexture2D;
		tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
		tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
		tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP);
		tex2d->setImage(0,layer->getCollideMap());
		crShaderManager::getInstance()->setHeightMapTexture(tex2d.get());
		const crVector3i &worldSize = crBrain::getInstance()->getWorldSize();
		crShaderManager::getInstance()->setGIParam(crVector4(worldSize[0]*0.5f,worldSize[1]*0.5f,1.0f/float(worldSize[0]),1.0f/float(worldSize[1])));

		ref_ptr<crWaypoint> waypointRoot = layer->getWaypointRoot();
		crCamera *camera = crCameraManager::getInstance()->getMainCamera();
		if(waypointRoot.valid() && camera && camera->getAttachedNode()->getDataClass())
		{
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			void *param;
			cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			cameraData->getParam(WCHDATA_WaypointNodeMap,param);
			WaypointNodeMap *waypointNodeMap = (WaypointNodeMap *)param;
			if(waypointNodeMap)
			{
				crWaypoint::WaypointSet waypointSet;
				crScene *scene = crMyPlayerData::getInstance()->getScene();
				ref_ptr<crWaypoint> waypoint;
				ref_ptr<crMatrixTransform> matnode;
				crVector3 pos;
				crVector2s coord;
				CRCore::crCollectNodeBYNameVisitor collector(CRCore::MATRIXTRANSFORM);
				collector.insertNodeNameId("#Waypoint");
				crBrain::getInstance()->accept(collector);
				NodeArray &nodeArray = collector.getResult();
				for( NodeArray::iterator itr = nodeArray.begin();
					itr != nodeArray.end();
					++itr )
				{
					matnode = dynamic_cast<crMatrixTransform *>(itr->get());
					if(matnode.valid() && matnode->getName().compare("#Waypoint") == 0)
					{
						pos = matnode->getTrans();
						pos[2] = scene->getPosZ(0,pos[0],pos[1],0.0f);
						matnode->setPosition(pos);
						coord = layer->getCoord(pos[0],pos[1]);
						waypoint = waypointRoot->findWaypoint(coord);
						waypointRoot->endtravel();
						if(waypoint.valid())
						{
							if(waypointSet.find(waypoint)!=waypointSet.end())
							{
								waypoint = new crWaypoint;
								waypoint->setPoint(coord);
							}
						}
						else
						{
							waypoint = new crWaypoint;
							waypoint->setPoint(coord);
						}
						(*waypointNodeMap)[matnode] = waypoint;
						waypointSet.insert(waypoint);
					}
				}
				////移除多出的waypoint
				waypointRoot->removeRedundantWaypoint(waypointSet);
				waypointRoot->endtravel();
				if(waypointSet.find(waypointRoot) == waypointSet.end())
				{
					if(waypointSet.empty())
					{
						//cameraData->inputParam(WCHDATA_WaypointRoot,NULL);
						layer->setWaypointRoot(NULL);
					}
					else
					{
						waypointRoot = *(waypointSet.begin());
						//cameraData->inputParam(WCHDATA_WaypointRoot,waypointRoot.get());
						layer->setWaypointRoot(waypointRoot.get());
					}
				}
			}
			cameraData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crWaypointLinkDrawMethod
//
/////////////////////////////////////////
crWaypointLinkDrawMethod::crWaypointLinkDrawMethod():
	m_init(false),
	m_coords(NULL),
	m_coords_buf(NULL),
	m_zoffset(1.0f)
{
}

crWaypointLinkDrawMethod::crWaypointLinkDrawMethod(const crWaypointLinkDrawMethod& handle):
	crNodeMethod(handle),
	m_init(false),
	m_lineColor(handle.m_lineColor),
	m_coords(NULL),
	m_coords_buf(NULL),
	m_zoffset(handle.m_zoffset)
{
}

void crWaypointLinkDrawMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crWaypointLinkDrawMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_zoffset = atof(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_lineColor);
		m_lineColor /= 255.0f;
		break;
	}
}
void crWaypointLinkDrawMethod::init()
{
	m_rectGeo = new crGeometry;
	m_rectGeo->setName("#WaypointLink");
	crStateSet *stateset = m_rectGeo->getOrCreateStateSet(); 
	crLineWidth *lineWidth = new crLineWidth(2.0f);
	stateset->setAttributeAndModes(lineWidth,crStateAttribute::ON);
	m_rectGeo->setNormalBinding(crGeometry::BIND_OFF);
	m_drawArrays = new DrawArrays(crPrimitive::PT_LINES);
	m_rectGeo->addPrimitive(m_drawArrays.get());
	m_rectGeo->setUseVertexBufferObjects(false);
	m_rectGeo->setUseDisplayList(false);
	m_rectGeo->setColor(m_lineColor);
	m_coords = new CRCore::Vec3Array;
	m_coords_buf = new CRCore::Vec3Array;
	//m_rectGeo->setVisiable(false);
	m_rectGeo->setVertexArray(m_coords_buf);
	//m_rectGeo->setBoundBox(crVector3(0,0,0),crVector3(crDisplaySettings::instance()->getViewWidth()*0.5f,crDisplaySettings::instance()->getViewHeight()*0.5f,0));
	crObject* object = new crObject;
	object->addDrawable(m_rectGeo.get());
	object->setCollideMode(crNode::CollideNone);
	object->setName("WaypointLink");
	object->setEditorIntersectable(false);
	//object->setCullingActive(false);
	if(crDisplaySettings::instance()->getRunMode() == crDisplaySettings::Editor)
		crLoadManager::getInstance()->requestAddNode(crSceneManager::getInstance()->getEditorRoot(),object,true);
	else
		crLoadManager::getInstance()->requestAddNode(crSceneManager::getInstance()->getStaticRoot(),object,true);
	m_init = true;
}
void crWaypointLinkDrawMethod::operator()(crHandle &handle)
{
	if(!m_init)
	{
		init();
	}
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	if(layer)
	{
		crWaypoint *waypointRoot = layer->getWaypointRoot();
		if(waypointRoot)
		{
			m_coords->resize(0);
			crVector2f pos = layer->getPosXY(waypointRoot->getPoint());
			crScene *scene = crMyPlayerData::getInstance()->getScene();
			float z = scene->getPosZ(0,pos[0],pos[1],m_zoffset);
			crVector3 thispos = crVector3(pos[0],pos[1],z);
			crVector3 rootUpPos = thispos;
			rootUpPos[2] += 5.0f;
			m_coords->push_back(rootUpPos);
			m_coords->push_back(thispos);
			waypointRoot->drawlink(m_coords,m_zoffset);
			waypointRoot->enddraw();
		}
	}
}
void crWaypointLinkDrawMethod::releaseObjects(crState* statte)
{
}
void crWaypointLinkDrawMethod::swapBuffers(int frameNumber)
{
	if(m_init)
	{
		*m_coords_buf = *m_coords;
		m_drawArrays->setCount(m_coords_buf->getNumElements());
		m_rectGeo->dirtyBound();
	}
}
/////////////////////////////////////////
//
//crWaypointPannedMethod
//
/////////////////////////////////////////
crWaypointPannedMethod::crWaypointPannedMethod()
{
}
crWaypointPannedMethod::crWaypointPannedMethod(const crWaypointPannedMethod& handle):
	crMethod(handle)
{
}
void crWaypointPannedMethod::inputParam(int i, void *param)
{
}
void crWaypointPannedMethod::addParam(int i, const std::string& str)
{
}
void crWaypointPannedMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	crCamera *camera = crCameraManager::getInstance()->getMainCamera();
	if(layer && camera)
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		if(cameraData)
		{
			void *param;
			cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			cameraData->getParam(WCHDATA_WaypointNodeMap,param);
			WaypointNodeMap *waypointNodeMap = (WaypointNodeMap *)param;
			if(waypointNodeMap)
			{
				//cameraData->getParam(WCHDATA_WaypointRoot,param);
				crWaypoint *waypointRoot = layer->getWaypointRoot();

				crScene *scene = crMyPlayerData::getInstance()->getScene();
				crViewMatterObject *body = crSceneManager::getInstance()->getPlayer();
				crGameBodyInfo *bodyInfo = body->getGameBodyInfo();
				crData *infoData = bodyInfo->getDataClass();
				ref_ptr<crMatrixTransform> matnode;
				crVector3 pos;
				crVector2s point;
				crSetObjectColorVisitor setcolor;
				crGameBodyInfo::SelectNodeVec& selectNodeVec = bodyInfo->getSelectNodeVec();
				for( crGameBodyInfo::SelectNodeVec::iterator itr = selectNodeVec.begin();
					itr != selectNodeVec.end();
					++itr )
				{
					matnode = dynamic_cast<crMatrixTransform *>(itr->get());
					if(matnode.valid() && matnode->getName().compare("#Waypoint") == 0)
					{
						pos = matnode->getTrans();
						pos[2] = scene->getPosZ(0,pos[0],pos[1],0.0f);
						matnode->setPosition(pos);
						ref_ptr<crWaypoint> &waypoint = (*waypointNodeMap)[matnode];
						if(!waypoint.valid())
						{
							waypoint = new crWaypoint;
							if(!waypointRoot)
							{
								waypointRoot = waypoint.get();
								//cameraData->inputParam(WCHDATA_WaypointRoot,waypointRoot);
								layer->setWaypointRoot(waypointRoot);
							}
						}
						point = layer->getCoord(pos[0],pos[1]);
						waypoint->setPoint(point);
						if(!layer->walkability(point[0],point[1]))
						{
							setcolor.setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
						}
						else
						{
							setcolor.setColor(crVector4(0.0f,0.0f,1.0f,1.0f));
						}
						matnode->accept(setcolor);
					}
				}
			}
			cameraData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crWaypointDeleteMethod
//
/////////////////////////////////////////
crWaypointDeleteMethod::crWaypointDeleteMethod()
{
}
crWaypointDeleteMethod::crWaypointDeleteMethod(const crWaypointDeleteMethod& handle):
	crMethod(handle)
{
}
void crWaypointDeleteMethod::inputParam(int i, void *param)
{
}
void crWaypointDeleteMethod::addParam(int i, const std::string& str)
{
}
void crWaypointDeleteMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	crCamera *camera = crCameraManager::getInstance()->getMainCamera();
	if(layer && camera)
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		if(cameraData)
		{
			void *param;
			cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			cameraData->getParam(WCHDATA_WaypointNodeMap,param);
			WaypointNodeMap *waypointNodeMap = (WaypointNodeMap *)param;
			if(waypointNodeMap)
			{
				//cameraData->getParam(WCHDATA_WaypointRoot,param);
				crWaypoint *waypointRoot = layer->getWaypointRoot();
				ref_ptr<crWaypoint> waypoint;
				bool rootdeled = false;
				crScene *scene = crMyPlayerData::getInstance()->getScene();
				crViewMatterObject *body = crSceneManager::getInstance()->getPlayer();
				crGameBodyInfo *bodyInfo = body->getGameBodyInfo();
				crData *infoData = bodyInfo->getDataClass();
				ref_ptr<crMatrixTransform> matnode;
				crVector3 pos;
				WaypointNodeMap::iterator wpitr;
				crGameBodyInfo::SelectNodeVec& selectNodeVec = bodyInfo->getSelectNodeVec();
				for( crGameBodyInfo::SelectNodeVec::iterator itr = selectNodeVec.begin();
					itr != selectNodeVec.end();
					++itr )
				{
					matnode = dynamic_cast<crMatrixTransform *>(itr->get());
					if(matnode.valid() && matnode->getName().compare("#Waypoint") == 0)
					{
						wpitr = waypointNodeMap->find(matnode);
						if(wpitr != waypointNodeMap->end())
						{
							waypoint = wpitr->second;
							waypoint->disconnectAll();
							waypointNodeMap->erase(wpitr);
							if(waypoint == waypointRoot)
								rootdeled = true;
						}
					}
				}
				if(rootdeled)
				{
					if(waypointNodeMap->empty())
					{
						//cameraData->inputParam(WCHDATA_WaypointRoot,NULL);
						layer->setWaypointRoot(NULL);
					}
					else
					{
						waypointRoot = waypointNodeMap->begin()->second.get();
						//cameraData->inputParam(WCHDATA_WaypointRoot,waypointRoot);
						layer->setWaypointRoot(waypointRoot);
					}
				}
			}
			cameraData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crSetWaypointMethod
//
/////////////////////////////////////////
crSetWaypointMethod::crSetWaypointMethod()
{
}
crSetWaypointMethod::crSetWaypointMethod(const crSetWaypointMethod& handle):
	crMethod(handle)
{
}
void crSetWaypointMethod::inputParam(int i, void *param)
{
}
void crSetWaypointMethod::addParam(int i, const std::string& str)
{
}
void crSetWaypointMethod::operator()(crHandle &handle)
{
	crSceneLayer *layer = crMyPlayerData::getInstance()->getScene()->getSceneLayer(0);
	crCamera *camera = crCameraManager::getInstance()->getMainCamera();
	if(layer && camera)
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		if(cameraData)
		{
			void *param;
			cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			cameraData->getParam(WCHDATA_WaypointNodeMap,param);
			WaypointNodeMap *waypointNodeMap = (WaypointNodeMap *)param;
			if(waypointNodeMap)
			{
				ref_ptr<crWaypoint> waypoint;
				crViewMatterObject *body = crSceneManager::getInstance()->getPlayer();
				crGameBodyInfo *bodyInfo = body->getGameBodyInfo();
				ref_ptr<crMatrixTransform> matnode;
				WaypointNodeMap::iterator wpitr;
				crGameBodyInfo::SelectNodeVec& selectNodeVec = bodyInfo->getSelectNodeVec();
				for( crGameBodyInfo::SelectNodeVec::iterator itr = selectNodeVec.begin();
					itr != selectNodeVec.end();
					++itr )
				{
					matnode = dynamic_cast<crMatrixTransform *>(itr->get());
					if(matnode.valid() && matnode->getName().compare("#Waypoint") == 0)
					{
						wpitr = waypointNodeMap->find(matnode);
						if(wpitr != waypointNodeMap->end())
						{
							waypoint = wpitr->second;
							layer->setWaypointRoot(waypoint.get());
							break;
						}
					}
				}
			}
			cameraData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crCameraFocusMethod
//
/////////////////////////////////////////
crCameraFocusMethod::crCameraFocusMethod():
	m_inputPos(true){}
crCameraFocusMethod::crCameraFocusMethod(const crCameraFocusMethod& handle):
	crMethod(handle),
	m_inputPos(handle.m_inputPos),
	m_targetPos(handle.m_targetPos)
{
}
void crCameraFocusMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(m_inputPos && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetPos = *(crVector3*)(LOINT64(param64));
		}
		break;
	}
}
void crCameraFocusMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_targetPos);
		m_inputPos = false;
		break;
	}
}
void crCameraFocusMethod::operator()(crHandle &handle)
{
	//相机聚焦
	crMatrix camMatrix = m_this->getMatrix();
	crVector3 camPos = camMatrix.getTrans();
	camMatrix.setTrans(0.0f,0.0f,0.0f);
	crVector3 camDir = (Y_AXIS * camMatrix).normalize();
	if(camDir[2]!=0.0f)
	{
		float l = (camPos[2] - m_targetPos[2])/camDir[2];
		camPos[0] = l*camDir[0] + m_targetPos[0];
		camPos[1] = l*camDir[1] + m_targetPos[1];
		m_this->setPosition(camPos);
	}
}
/////////////////////////////////////////
//
//crCreateSightMethod
//
/////////////////////////////////////////
crCreateSightMethod::crCreateSightMethod()
{
}
crCreateSightMethod::crCreateSightMethod(const crCreateSightMethod& handle):
	crMethod(handle)
{
}
void crCreateSightMethod::inputParam(int i, void *param)
{
}
void crCreateSightMethod::addParam(int i, const std::string& str)
{
}
void crCreateSightMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crPlayerDataSceneEventPacket packet;
		crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_RecvCreateSight,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvCreateSightMethod
//
/////////////////////////////////////////
crRecvCreateSightMethod::crRecvCreateSightMethod():
	m_netType(GameClient_Game){}
crRecvCreateSightMethod::crRecvCreateSightMethod(const crRecvCreateSightMethod& handle):
	crMethod(handle)
{
}
void crRecvCreateSightMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvCreateSightMethod::addParam(int i, const std::string& str)
{
}

void crRecvCreateSightMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && playerData->getSceneID() != 0)
			{
				crNetDataManager *netDataManager = sceneServer->getNetDataManager();
				crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				crScene *scene = callback->findScene(playerData->getSceneID());
				if(scene)
				{
					ref_ptr<crSightInfo> sightInfo;
					if(playerData->getRoomID()!=0)
					{
						CRNetApp::crRoom* room = callback->findRoom(playerData->getRoomID());
						if(room)
						{
							crRoomPlayer *member = room->getMember(playerid);
							if(member)
							{
								sightInfo = room->getOrCreateSightInfo(member->getGroupID());
								if(sightInfo.valid())
								{
									//if(room->getShareSight())
									//{
									//	int birthPointIndex = member->getBirthPointIndex();
									//	if(birthPointIndex >= 0)
									//	{//出生点视野
									//		int layerid = playerData->getLayerid();
									//		crSceneLayer *layer = scene->getSceneLayer(layerid);
									//		const crSceneLayer::BirthPointArray &birthPointArray = layer->getBirthPointArray();
									//		if(birthPointIndex < birthPointArray.size())
									//		{
									//			crVector3i birth = birthPointArray[birthPointIndex];
									//			crVector2i birthEye(birth[0], birth[1]);
									//			sightInfo->insertEyePoint(birthEye);
									//		}
									//	}
									//}
									playerData->setSightInfo(sightInfo.get());
									//需要保证创建SightInfo后才能将role添加到场景里。
									crSceneServerPlayerData::RoleMap &roleMap = playerData->getRoleMap();
									for( crSceneServerPlayerData::RoleMap::iterator itr = roleMap.begin();
										itr != roleMap.end();
										++itr )
									{
										scene->insertRoomRole(itr->second.get());
									}
								}
							}
						}
					}
					//if(!sightInfo.valid())
					//{
					//	sightInfo = new crSightInfo;
					//	playerData->setSightInfo(sightInfo.get());
					//}
					//scene->insertSightInfo(sightInfo.get());
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crSightFogUpdateMethod
////
///////////////////////////////////////////
//crSightFogUpdateMethod::crSightFogUpdateMethod():
//	m_init(false)
//{
//}
//crSightFogUpdateMethod::crSightFogUpdateMethod(const crSightFogUpdateMethod& handle):
//	crMethod(handle),
//	m_canvas(handle.m_canvas),
//	m_imageBox(handle.m_imageBox),
//	m_texSize(handle.m_texSize),
//	m_updInterval(handle.m_updInterval),
//	m_clearColor(handle.m_clearColor),
//	m_textureFile(handle.m_textureFile),
//	m_heightOffset(handle.m_heightOffset),
//	m_init(false)
//{
//}
//void crSightFogUpdateMethod::inputParam(int i, void *param)
//{
//}
//void crSightFogUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvas = str;
//		break;
//	case 1:
//		m_imageBox = str;
//		break;
//	case 2:
//		crArgumentParser::appAtoVec(str,m_texSize);
//		break;
//	case 3:
//		m_updInterval = atof(str.c_str());
//		break;
//	case 4:
//		crArgumentParser::appAtoVec(str,m_clearColor);
//		m_clearColor /= 255.0f;
//		break;
//	case 5:
//		m_textureFile = str;
//		break;
//	case 6:
//		m_heightOffset = atof(str.c_str());
//		break;
//	}
//}
//void crSightFogUpdateMethod::init()
//{
//	crCanvasNode *canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
//	if(canvas)
//	{
//		crImageBoxWidgetNode *imageBox = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_imageBox));
//		if(imageBox)
//		{
//			imageBox->setVisiable(false);
//
//	ref_ptr<crRenderToTexture> rtt = new crRenderToTexture;
//	rtt->setName("SightFogRTT");
//	rtt->setMode(crRenderToTexture::RenderToTextureMode(crRenderToTexture::RenderToTexture|crRenderToTexture::RenderColorMap|crRenderToTexture::RealTimeUpd|crRenderToTexture::ExternMVP));
//	rtt->setMapSize(m_texSize[0],m_texSize[1]);
//	rtt->setUpdateInterval(m_updInterval);
//	//rtt->addTexturedNode(imageBox->getImageObject());
//	ref_ptr<crHeightField> heightField = new crHeightField;
//	crSceneLayer *layer = crMyPlayerData::getInstance()->getSceneLayer();
//	float dx = layer->getXInterval();
//	float dy = layer->getYInterval();
//	short numColumns = layer->getNumColumns();
//	short numRows = layer->getNumRows();
//	heightField->allocate(numColumns,numRows);
//	heightField->setXInterval(dx);
//	heightField->setYInterval(dy);
//	crVector2 origin = layer->getOrigin();
//	heightField->setOrigin(crVector3(origin[0],origin[1],0.0f));
//	for(int s = 0; s<numColumns; ++s)
//	{
//		for(int t=0;t<numRows;++t)
//		{
//			heightField->setHeight(s,t,layer->getHeight(s,t)+m_heightOffset);
//		}
//	}
//	ref_ptr<crShapeDrawable> shapeDrawable = new crShapeDrawable(heightField.get());
//	ref_ptr<crObject> object = new crObject;
//	object->addDrawable(shapeDrawable.get());
//	object->setCollideMode(crNode::CollideNone);
//	object->setName("#SightFog");
//	object->setEnableIntersect(false);
//	object->setEffectByShadow(false);
//	object->setCalcShadow(false);
//	crStateSet *stateset = object->getOrCreateStateSet();
//	crBlendFunc *blendFunc = new crBlendFunc(crBlendFunc::SRC_ALPHA,crBlendFunc::ONE_MINUS_SRC_ALPHA);
//	stateset->setAttributeAndModes(blendFunc,crStateAttribute::ON);
//	stateset->setRenderingHint(crStateSet::OUTLINE_BIN);
//	ref_ptr<CRCore::crTraverseStringNode> tsNode = new CRCore::crTraverseStringNode;
//	tsNode->setName("NoLight");
//	tsNode->addChild(object.get());
//	CRIOManager::crLoadManager::getInstance()->requestAddNode(crSceneManager::getInstance()->getStaticRoot(),tsNode.get(),true);
//	rtt->addTexturedNode(object.get());
//
//	m_object = new crObject;
//	m_object->setCollideMode(crNode::CollideNone);
//	m_object->setEnableIntersect(false);
//	m_object->setEffectByShadow(false);
//	m_object->setCalcShadow(false);
//	//ref_ptr<CRCore::crTraverseStringNode> tsNode = new CRCore::crTraverseStringNode;
//	//tsNode->setName("NoShader");
//	//tsNode->addChild(m_object.get());
//	rtt->addRenderNode(m_object.get());
//	const crVector3i& worldSize = crBrain::getInstance()->getWorldSize();
//	rtt->setProjectionMatrix(CRCore::crMatrix::ortho(-worldSize[0]*0.5f,worldSize[0]*0.5f,-worldSize[1]*0.5f,worldSize[1]*0.5f,-worldSize[2],worldSize[2]));
//	rtt->setViewMatrix(crMatrix::identity());
//	rtt->init(1.0f);
//	rtt->getTexture()->setInternalFormat(GL_RGBA8);
//	rtt->getCameraNode()->setClearColor(m_clearColor);
//	crRenderToTextureManager::getInstance()->addRenderToTexture(rtt.get());
//
//	//stateset = m_object->getOrCreateStateSet();
//	//crTexture2D *tex2d = new crTexture2D;
//	//tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
//	//tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
//	//tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_EDGE);
//	//tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_EDGE);
//	//tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_EDGE);
//	//tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(m_textureFile));
//	//stateset->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
//	//blendFunc = new crBlendFunc(crBlendFunc::SRC_ALPHA,crBlendFunc::ONE);
//	//stateset->setAttributeAndModes(blendFunc,crStateAttribute::ON);
//	m_init = true;
//		}
//	}
//}
//void crSightFogUpdateMethod::operator()(crHandle &handle)
//{
//	if(!m_init)
//	{
//		init();
//		m_hints = new crTessellationHints;
//		m_hints->setCreateBody(false);
//		m_hints->setCreateBottom(false);
//		m_hints->setCreateNormals(false);
//		m_hints->setCreateTextureCoords(true);
//		m_hints->setDetailRatio(1.0f);
//	}
//	float scale = crGlobalHandle::gData()->gUnitScale();
//	std::vector<CRCore::crVector3i> eyeVec;
//	crMyPlayerData::getInstance()->getEyes(eyeVec);
//	crVector3i eye;
//	ref_ptr<crShapeDrawable> shape;
//	ref_ptr<crSphere> box;
//	//ref_ptr<crTessellationHints> hints = new crTessellationHints;
//	//hints->setCreateBody(false);
//	//hints->setCreateBottom(false);
//	//hints->setCreateNormals(false);
//	//hints->setCreateTextureCoords(true);
//	crObject::DrawableList &drawableList = m_object->getDrawableList();
//	int dcount = drawableList.size();
//	int eyeCount = eyeVec.size();
//	int i = 0;
//	float r;
//	for( ; i<dcount && i<eyeCount; i++)
//	{
//		shape = dynamic_cast<crShapeDrawable *>(drawableList[i].get());
//		box = dynamic_cast<crSphere *>(shape->getShape());
//		eye = eyeVec[i];
//		box->setCenter(crVector3((float)eye[0]*scale,(float)eye[1]*scale,0.0f));
//		r = (float)eye[2]*scale;
//		//box->setHalfLengths(crVector3(r,r,r));
//		box->setRadius(r);
//		shape->setVisiable(true);
//	}
//	if(dcount>eyeCount)
//	{
//		for( ;i<dcount;i++)
//		{
//			shape = dynamic_cast<crShapeDrawable *>(drawableList[i].get());
//			shape->setVisiable(false);
//		}
//	}
//	else if(dcount<eyeCount)
//	{
//		for( ;i<eyeCount;i++)
//		{
//			eye = eyeVec[i];
//			shape = new crShapeDrawable;
//			shape->setUseDisplayList(false);
//			shape->setUseVertexBufferObjects(false);
//			shape->setUseIndexBufferObjects(false);
//			box = new crSphere;
//			shape->setShape(box.get());
//			shape->setTessellationHints(m_hints.get());
//			shape->setColor(crVector4(0.0f,0.0f,0.0f,0.0f));
//			box->setCenter(crVector3((float)eye[0]*scale,(float)eye[1]*scale,0.0f));
//			r = (float)eye[2]*scale;
//			//box->setHalfLengths(crVector3(r,r,r));
//			box->setRadius(r);
//			m_object->addDrawable(shape.get());
//		}
//	}
//}
/////////////////////////////////////////
//
//crSightFogInitMethod
//
/////////////////////////////////////////
crSightFogInitMethod::crSightFogInitMethod():
	m_updInterval(0.0f),
	m_precision(1.0f)
{
	m_texSize.set(512,512);
}
crSightFogInitMethod::crSightFogInitMethod(const crSightFogInitMethod& handle):
	crMethod(handle),
	m_texSize(handle.m_texSize),
	m_updInterval(handle.m_updInterval),
	m_clearColor(handle.m_clearColor),
	m_precision(handle.m_precision),
	m_canvasName(handle.m_canvasName),
	m_mapWidgetName(handle.m_mapWidgetName)
{
}
void crSightFogInitMethod::inputParam(int i, void *param)
{
}
void crSightFogInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_texSize);
		break;
	case 1:
		m_updInterval = atof(str.c_str());
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_clearColor);
		m_clearColor /= 255.0f;
		break;
	case 3:
		m_precision = atof(str.c_str());
		break;
	case 4:
		m_canvasName = str;
		break;
	case 5:
		m_mapWidgetName = str;
		break;
	}
}
void crSightFogInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crRenderToTexture> rtt = crRenderToTextureManager::getInstance()->findRenderToTexture("LightMapTexture");
	if(!rtt.valid())
	{
		rtt = new crRenderToTexture;
		rtt->setName("LightMapTexture");
		rtt->setMode(crRenderToTexture::RenderToTextureMode(crRenderToTexture::RenderToTexture|
			crRenderToTexture::RenderColorMap|crRenderToTexture::RealTimeUpd|crRenderToTexture::ExternMVP|crRenderToTexture::NeedBlur));
		const crVector2i &mapSize = crBrain::getInstance()->getMapSize();
		rtt->setMapSize(mapSize);
		rtt->init(1.0f);
		const crVector3i &worldSize = crBrain::getInstance()->getWorldSize();
		rtt->setProjectionMatrix(CRCore::crMatrix::ortho(-worldSize[0]*0.5f,worldSize[0]*0.5f,-worldSize[1]*0.5f,worldSize[1]*0.5f,-worldSize[2],worldSize[2]));
		rtt->setViewMatrix(crMatrix::identity());
		//crShaderManager::getInstance()->setUpperSkyTexture(rtt->getTexture());
		crShaderManager::getInstance()->setLightMapTexture(rtt->getBlurTexture());
		crShaderManager::getInstance()->setGIParam(crVector4(worldSize[0]*0.5f,worldSize[1]*0.5f,1.0f/float(worldSize[0]),1.0f/float(worldSize[1])));
		//crShaderManager::getInstance()->setGIMVP(rtt->getView() * rtt->getProjection());
		crStateSet *camerass = rtt->getCameraNode()->getOrCreateStateSet();
		crStateSet *shader = crShaderManager::getInstance()->getShaderStateSet("warfog");
		crUniform *uniform = camerass->getOrCreateUniform("clearColor",CRCore::crUniform::FLOAT_VEC4);
		uniform->setDataVariance(crBase::STATIC);
		uniform->set(m_clearColor);
		uniform = camerass->getOrCreateUniform("coordParam",CRCore::crUniform::FLOAT_VEC4);
		uniform->setDataVariance(crBase::STATIC);
		uniform->set(crVector4f(worldSize[0]*0.5f,worldSize[1]*0.5f,1.0f/float(worldSize[0]),1.0f/float(worldSize[1])));
		uniform = camerass->getOrCreateUniform("maxheight",CRCore::crUniform::FLOAT);
		uniform->setDataVariance(crBase::STATIC);
		uniform->set(worldSize[2]);
		ref_ptr<crTexture2D>tex2d = new crTexture2D;
		tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
		tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
		tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP);
		tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP);
		tex2d->setImage(0,crMyPlayerData::getInstance()->getSceneLayer()->getCollideMap());
		crShaderManager::getInstance()->setHeightMapTexture(tex2d.get());
		camerass->setTextureAttributeAndModes(0,tex2d.get(),crStateAttribute::ON);
		camerass->merge(*shader);
		crRenderToTextureManager::getInstance()->addRenderToTexture(rtt.get());

		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
		if(canvas.valid())
		{
			ref_ptr<crImageBoxWidgetNode>widget = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_mapWidgetName));
			if(widget.valid())
			{
				crStateSet *stateset = widget->getImageStateSet();
				crTexture *lm = crShaderManager::getInstance()->getLightMapTexture();
				stateset->setTextureAttributeAndModes(1,lm,crStateAttribute::ON);
				widget->setImageName("RTT",1);
			}
		}
	}
	rtt->setUpdateInterval(m_updInterval);
	rtt->getCameraNode()->setClearColor(m_clearColor);
	//rtt->getCameraNode()->setCullingActive(false);
	//rtt->getCameraNode()->setEnableIntersect(false);
}
/////////////////////////////////////////
//
//crSightFogUpdateMethod
//
/////////////////////////////////////////
crSightFogUpdateMethod::crSightFogUpdateMethod():
	m_init(false)
{
}
crSightFogUpdateMethod::crSightFogUpdateMethod(const crSightFogUpdateMethod& handle):
	crMethod(handle),
	m_sightColor(handle.m_sightColor),
	m_init(false)
{
}
void crSightFogUpdateMethod::inputParam(int i, void *param)
{
}
void crSightFogUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_sightColor);
		m_sightColor /= 255.0f;
		break;
	}
}
void crSightFogUpdateMethod::init()
{
	crRenderToTexture *rtt = crRenderToTextureManager::getInstance()->findRenderToTexture("LightMapTexture");
	if(rtt)
	{
		m_object = new crObject;
		m_object->setCollideMode(crNode::CollideNone);
		m_object->setEnableIntersect(false);
		m_object->setEffectByShadow(false);
		m_object->setCalcShadow(false);
		rtt->addRenderNode(m_object.get());
		m_hints = new crTessellationHints;
		m_hints->setCreateBody(false);
		m_hints->setCreateBottom(false);
		m_hints->setCreateNormals(false);
	}
	m_init = true;
}
//void crSightFogUpdateMethod::setEyeField(CRCore::crVector4f &eye,crHeightField *eyeField,CRCore::crVector2 &origin)
//{
//	crVector2 pos;
//	int c_2,r_2,s1,t1,s,t;
//	float r,r1;
//	float dx = eyeField->getXInterval();
//	float dy = eyeField->getYInterval();
//	int numColumns = eyeField->getNumColumns();
//	int numRows = eyeField->getNumRows();
//	r1 = numColumns;//crVector2i(numColumns,numRows).length();
//	c_2 = numColumns>>1;
//	r_2 = numRows>>1;
//	pos.set(eye[0],eye[1]);
//	eyeField->setOrigin(crVector3(pos[0]-c_2*dx,pos[1]-r_2*dy,0.0f));
//	pos -= origin;
//	pos[0] /= dx;
//	pos[1] /= dy;
//	for(s = 0; s<numColumns; ++s)
//	{
//		for(t=0;t<numRows;++t)
//		{
//			//s1 = s + pos[0] - c_2;
//			//t1 = t + pos[1] - r_2;
//			//eyeBody->setHeight(s,t,layer->getHeight(s1,t1));
//			if(crVector2i(s-c_2,t-c_2).length()<r1)
//			{
//				eyeField->setColor(s,t,m_sightColor);
//			}
//			else
//			{
//				eyeField->setColor(s,t,m_clearColor);
//			}
//		}
//	}
//}
void crSightFogUpdateMethod::operator()(crHandle &handle)
{
	if(!m_init)
	{
		init();
	}
	if(m_object.valid())
	{
		//crSceneLayer *layer = crMyPlayerData::getInstance()->getSceneLayer();
		//crVector2 origin = layer->getOrigin();
		//float dx = layer->getXInterval();
		//float dy = layer->getYInterval();
		//int numColumns,numRows;
		crStateSet *circless;
		crUniform *uniform;
		float scale = crGlobalHandle::gData()->gUnitScale(); 
		std::vector<CRCore::crVector4i> eyeVec;
		crMyPlayerData::getInstance()->getEyes(eyeVec);
		crVector4f seye;
		ref_ptr<crShapeDrawable> shape;
		ref_ptr<crCylinder> cylinder;
		crObject::DrawableList &drawableList = m_object->getDrawableList();
		int dcount = drawableList.size();
		int eyeCount = eyeVec.size();
		int i = 0;
		for( ; i<dcount && i<eyeCount; i++)
		{
			shape = dynamic_cast<crShapeDrawable *>(drawableList[i].get());
			cylinder = dynamic_cast<crCylinder *>(shape->getShape());
			seye = eyeVec[i];
			seye *= scale;
			//setEyeField(seye,eyeField.get(),origin);
			cylinder->setCenter(crVector3(seye[0],seye[1],seye[2]));
			cylinder->setRadius(seye[3]);
			circless = shape->getOrCreateStateSet();
			uniform = circless->getUniform("centerPos");
			if(uniform) uniform->set(crVector3(seye[0],seye[1],seye[2]));
			shape->setVisiable(true);
		}
		if(dcount>eyeCount)
		{
			for( ;i<dcount;i++)
			{
				shape = dynamic_cast<crShapeDrawable *>(drawableList[i].get());
				shape->setVisiable(false);
			}
		}
		else if(dcount<eyeCount)
		{
			for( ;i<eyeCount;i++)
			{
				seye = eyeVec[i];
				seye *= scale;
				shape = new crShapeDrawable;
				shape->setTessellationHints(m_hints.get());
				shape->setUseDisplayList(false);
				shape->setUseVertexBufferObjects(false);
				shape->setUseIndexBufferObjects(false);
				cylinder = new crCylinder;
				shape->setShape(cylinder.get());
				//numColumns = seye[3] / dx *2.0f;
				//numRows = seye[3] / dy * 2.0f;
				//if(numColumns<2) numColumns = 2;
				//if(numRows<2) numRows = 2;
				//eyeField->allocate(numColumns,numRows);
				//eyeField->allocateColor();
				//eyeField->setXInterval(dx);
				//eyeField->setYInterval(dy);
				//setEyeField(seye,eyeField.get(),origin);
				shape->setColor(m_sightColor);
				cylinder->setCenter(crVector3(seye[0],seye[1],seye[2]));
				cylinder->setRadius(seye[3]);
				circless = shape->getOrCreateStateSet();
				uniform = circless->getOrCreateUniform("centerPos",CRCore::crUniform::FLOAT_VEC3);
				uniform->setDataVariance(crBase::DYNAMIC);
				uniform->set(crVector3(seye[0],seye[1],seye[2]));

				m_object->addDrawable(shape.get());
			}
		}
	}
}
///////////////////////////////////////////
////
////crRecvPathFindingMethod
////
///////////////////////////////////////////
//crRecvPathFindingMethod::crRecvPathFindingMethod():
//	m_netType(GameClient_Game){}
//crRecvPathFindingMethod::crRecvPathFindingMethod(const crRecvPathFindingMethod& handle):
//	crMethod(handle)
//{
//}
//void crRecvPathFindingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crRecvPathFindingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRecvPathFindingMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->getParam(WCHDATA_ItemState,param);
//		unsigned char lastitemstate = *(unsigned char *)param;
//		if(lastitemstate == IS_ItemLoad || lastitemstate == IS_Dead)
//		{
//			return;
//		}
//		data->getParam(WCHDATA_GuiseState,param);
//		unsigned char guisestate = *(unsigned char *)param;
//		if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
//		{
//			return;
//		}
//
//		unsigned char itemstate = m_stream->_readUChar();
//		//crVector3 pos;
//		//pos[0] = m_stream->_readInt();
//		//pos[1] = m_stream->_readInt();
//		//pos[2] = m_stream->_readInt();
//		//crVector3 myPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
//		//if((myPos-pos).length2()>10.0f)
//		//{
//		//	m_this->setPosx(pos[0]);
//		//	m_this->setPosy(pos[1]);
//		//	m_this->setPosz(pos[2]);
//		//}
//		crVector3 targetPos = m_stream->_readVec3();
//		short delay = m_stream->_readShort();
//		//CRCore::notify(CRCore::ALWAYS)<<"crRecvPathFindingMethod delay:"<<delay<<std::endl;
//		m_this->setDelayTime((float)delay * 0.001f);
//		data->inputParam(WCHDATA_ItemState,&itemstate);
//		data->inputParam(WCHDATA_TargetPos,&targetPos);
//
//		if(m_netType == GameClient_Game)
//		{
//			crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->recvPathFindRequest(m_this);
//		}
//		else if(m_netType == SceneServer)
//		{
//			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//			crScene *scene = netCallback->findScene(m_this->getSceneID());
//			scene->getPathFindingManager()->recvPathFindRequest(m_this);
//		}
//	}
//}
/////////////////////////////////////////
//
//crCheckPlayerDelayTimeMethod
//
/////////////////////////////////////////
crCheckPlayerDelayTimeMethod::crCheckPlayerDelayTimeMethod(){}
crCheckPlayerDelayTimeMethod::crCheckPlayerDelayTimeMethod(const crCheckPlayerDelayTimeMethod& handle):
	crMethod(handle)
{
}
void crCheckPlayerDelayTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crCheckPlayerDelayTimeMethod::addParam(int i, const std::string& str)
{
}

void crCheckPlayerDelayTimeMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
	if(sceneServer)
	{
		int playerid = m_this->getPlayerID();
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			crCheckPlayerDelayTimePacket packet;
			crCheckPlayerDelayTimePacket::buildReplyPacket(packet,playerid);
			sceneServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
		}
	}
}
/////////////////////////////////////////
//
//crPositionSyncMethod
//
/////////////////////////////////////////
crPositionSyncMethod::crPositionSyncMethod():
	m_dt(0.0f),
	m_interval(2.0f),
	m_time(0.0f){}
crPositionSyncMethod::crPositionSyncMethod(const crPositionSyncMethod& handle):
	crMethod(handle),
	m_dt(0.0f),
	m_interval(handle.m_interval),
	m_time(0.0f)
{
}
void crPositionSyncMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}
void crPositionSyncMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crPositionSyncMethod::operator()(crHandle &handle)
{
	m_time += m_dt;
	if(m_time>m_interval)
	{
		crVector3 pos = m_this->getPosition();
		if((pos-m_lastSyncPos).length()>0.5f)
		{
			m_time = 0.0f;
			m_lastSyncPos = pos;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(8);
			stream->_writeFloat(pos[0]);
			stream->_writeFloat(pos[1]);
			if(crGlobalHandle::isClient())
			{
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvPositionSync,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			else
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvPositionSync,stream.get());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crRecvPositionSyncMethod
//
/////////////////////////////////////////
crRecvPositionSyncMethod::crRecvPositionSyncMethod():
	m_netType(GameClient_Game){}
crRecvPositionSyncMethod::crRecvPositionSyncMethod(const crRecvPositionSyncMethod& handle):
	crMethod(handle)
{
}
void crRecvPositionSyncMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvPositionSyncMethod::addParam(int i, const std::string& str)
{
}

void crRecvPositionSyncMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//crData *data = m_this->getDataClass();
		//void *param;
		//data->getParam(WCHDATA_ItemState,param);
		//unsigned char itemstate = *(unsigned char*)param;
		//if(itemstate!=IS_Dead && itemstate != IS_Relive)
		//{
			crVector2 pos = m_stream->_readVec2();
			float scale = crGlobalHandle::gData()->gUnitScale();
			crVector2 curPos(m_this->getPosx(),m_this->getPosy());
			curPos *= scale;
			if(curPos != pos)
			{
				m_this->addSyncPos(pos);
				//if(crGlobalHandle::isClient())
				//	m_this->addSyncPos(pos);
				//else if(m_this->getItemtype() == crInstanceItem::Role)
				//{
				//	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				//	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				//	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				//	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				//	if(scene)
				//	{
				//		crSceneLayer *sceneLayer = scene->getSceneLayer(m_this->getLayerID());
				//		if(sceneLayer)
				//		{
				//			CRCore::crVector2s coord = sceneLayer->getCoord(pos[0],pos[1]);
				//			if(sceneLayer->walkability(coord[0],coord[1]))
				//			{
				//				m_this->addSyncPos(pos);
				//			}
				//			else
				//			{//非法位置,记录，并将客户端踢下线
				//				ref_ptr<crSceneServerPlayerData> player = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(m_this->getID()));
				//				if(player.valid())
				//				{
				//					crKickoffPlayerPacket kpacket;
				//					crKickoffPlayerPacket::buildReplyPacket(kpacket,m_this->getID());
				//					sceneServerConductor->getNetManager()->sendPacket(player->getPlayerConnectServerAddress(),kpacket);
				//				}
				//			}
				//		}
				//	}
				//}
				//else
				//{
				//	m_this->addSyncPos(pos);
				//}
			}
		//}
	}
}
/////////////////////////////////////////
//
//crUseItemRecordMapUpdateMethod
//
/////////////////////////////////////////
crUseItemRecordMapUpdateMethod::crUseItemRecordMapUpdateMethod():
	m_this(NULL),
	m_dt(NULL),
	m_delay(1.0f){}
crUseItemRecordMapUpdateMethod::crUseItemRecordMapUpdateMethod(const crUseItemRecordMapUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL),
	m_delay(handle.m_delay)
{
}
void crUseItemRecordMapUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			if(lparam)
				m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crUseItemRecordMapUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_delay = atof(str.c_str());
		break;
	}
}

void crUseItemRecordMapUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_UseItemRecordMap,param);
	UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
	for( UseItemRecordMap::iterator itr = useItemRecordMap->begin();
		 itr != useItemRecordMap->end(); )
	{
		itr->second->duration() -= *m_dt;
		if(itr->second->duration()<-m_delay)
		{
			itr = useItemRecordMap->erase(itr);
		}
		else
		{
			++itr;
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
///////////////////////////////////////////
////
////crRecvStopPositionMethod
////
///////////////////////////////////////////
//crRecvStopPositionMethod::crRecvStopPositionMethod():
//	m_netType(GameClient_Game){}
//crRecvStopPositionMethod::crRecvStopPositionMethod(const crRecvStopPositionMethod& handle):
//	crMethod(handle)
//{
//}
//void crRecvStopPositionMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crRecvStopPositionMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crRecvStopPositionMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->getParam(WCHDATA_ItemState,param);
//		unsigned char lastitemstate = *(unsigned char *)param;
//		if(lastitemstate == IS_ItemLoad || lastitemstate == IS_Dead)
//		{
//			return;
//		}
//		data->getParam(WCHDATA_GuiseState,param);
//		unsigned char guisestate = *(unsigned char *)param;
//		if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
//		{
//			return;
//		}
//		m_this->getOrCreatePathFinder()->dirty();
//		m_this->setPosx(m_stream->_readFloat());
//		m_this->setPosy(m_stream->_readFloat());
//		m_this->setPosz(m_stream->_readFloat());
//		if(m_netType == GameClient_Game)
//		{
//			//pos *= crGlobalHandle::gData()->gUnitScale();
//			//if((pos - m_this->getPosition()).length2()>4.0f)
//			//{
//			//	data->inputParam(WCHDATA_TargetPos,&pos);
//			//	lastitemstate = IS_Move;
//			//	data->inputParam(WCHDATA_ItemState,&lastitemstate);
//			//	crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->recvPathFindRequest(m_this);
//			//}
//			crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
//			if(bot)
//			{
//				m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
//			}
//		}
//		//CRCore::notify(CRCore::ALWAYS)<<"crRecvStopPositionMethod"<<std::endl;
//	}
//}
/////////////////////////////////////////
//
//crIsMainAIMethod
//
/////////////////////////////////////////
crIsMainAIMethod::crIsMainAIMethod(){}
crIsMainAIMethod::crIsMainAIMethod(const crIsMainAIMethod& handle):
	crMethod(handle)
{
}
void crIsMainAIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crIsMainAIMethod::addParam(int i, const std::string& str)
{
}
void crIsMainAIMethod::operator()(crHandle &handle)
{
	bool isMainAI = m_this->isMainAI();
	handle.outputParam(0,&isMainAI);
}
/////////////////////////////////////////
//
//crStopMyRolesMethod
//
/////////////////////////////////////////
crStopMyRolesMethod::crStopMyRolesMethod(){}
crStopMyRolesMethod::crStopMyRolesMethod(const crStopMyRolesMethod& handle):
	crMethod(handle)
{
}
void crStopMyRolesMethod::inputParam(int i, void *param)
{
}
void crStopMyRolesMethod::addParam(int i, const std::string& str)
{
}
void crStopMyRolesMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data;
	unsigned char itemstate;
	unsigned char stopstate = IS_Stop;
	crMyPlayerData::getInstance()->lockMyRoleNpcMap();
	crMyPlayerData::MyRoleNpcMap &myRoleNpcMap = crMyPlayerData::getInstance()->getMyRoleNpcMap();
	crRole *role;
	for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoleNpcMap.begin();
		 itr != myRoleNpcMap.end();
		 ++itr )
	{
		role = itr->second.first.get();
		data = role->getDataClass();
		data->getParam(WCHDATA_ItemState,param);
		itemstate = *(unsigned char*)param;
		if(itemstate != IS_Dead)
		{
			data->inputParam(WCHDATA_ItemState,&stopstate);
		}
	}
	crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crStopMyRolesPacket packet;
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crInitRoomProgressMethod
//
/////////////////////////////////////////
crInitRoomProgressMethod::crInitRoomProgressMethod(){}
crInitRoomProgressMethod::crInitRoomProgressMethod(const crInitRoomProgressMethod& handle):
crMethod(handle)
{
}
void crInitRoomProgressMethod::addParam(int i, const std::string& str)
{
}
void crInitRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crInitRoomProgressMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_RoomProgress,0);
}
/////////////////////////////////////////
//
//crGetRoomProgressMethod
//
/////////////////////////////////////////
crGetRoomProgressMethod::crGetRoomProgressMethod(){}
crGetRoomProgressMethod::crGetRoomProgressMethod(const crGetRoomProgressMethod& handle):
	crMethod(handle)
{
}
void crGetRoomProgressMethod::addParam(int i, const std::string& str)
{
}
void crGetRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crGetRoomProgressMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_RoomProgress,param);
	short progress = *(short *)param;
	int code = progress;
	handle.outputParam(0,&code);
}
/////////////////////////////////////////
//
//crAdvanceRoomProgressMethod
//
/////////////////////////////////////////
crAdvanceRoomProgressMethod::crAdvanceRoomProgressMethod(){}
crAdvanceRoomProgressMethod::crAdvanceRoomProgressMethod(const crAdvanceRoomProgressMethod& handle):
	crMethod(handle)
{
}
void crAdvanceRoomProgressMethod::addParam(int i, const std::string& str)
{
}
void crAdvanceRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}
void crAdvanceRoomProgressMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crPlayerServerEventPacket packet;
		crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvAdvanceRoomProgress,m_this,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvAdvanceRoomProgressMethod
//
/////////////////////////////////////////
crRecvAdvanceRoomProgressMethod::crRecvAdvanceRoomProgressMethod():
	m_netType(GameClient_Game){}
crRecvAdvanceRoomProgressMethod::crRecvAdvanceRoomProgressMethod(const crRecvAdvanceRoomProgressMethod& handle):
	crMethod(handle)
{
}
void crRecvAdvanceRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvAdvanceRoomProgressMethod::addParam(int i, const std::string& str)
{
}

void crRecvAdvanceRoomProgressMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crRoom *room = netCallback->findRoom(m_this->getRoomID());
		if(room && room->getGameRunning())
		{
			void *param;
			crData *data = room->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_RoomProgress,param);
			short *progress = (short *)param;
			(*progress)++;
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crSetRoomProgressMethod
//
/////////////////////////////////////////
crSetRoomProgressMethod::crSetRoomProgressMethod():
	m_progress(0){}
crSetRoomProgressMethod::crSetRoomProgressMethod(const crSetRoomProgressMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crSetRoomProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = atoi(str.c_str());
		break;
	}
}
void crSetRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}
void crSetRoomProgressMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	crRoom *room = netCallback->findRoom(m_this->getRoomID());
	if(room && room->getGameRunning())
	{
		crData *data = room->getDataClass();
		data->inputParam(WCHDATA_RoomProgress,&m_progress);
	}
}
/////////////////////////////////////////
//
//crReliveItemsMethod
//
/////////////////////////////////////////
crReliveItemsMethod::crReliveItemsMethod(){}
crReliveItemsMethod::crReliveItemsMethod(const crReliveItemsMethod& handle):
crMethod(handle),
m_itemidVec(handle.m_itemidVec)
{
}
void crReliveItemsMethod::addParam(int i, const std::string& str)
{
	int id = atoi(str.c_str());
	if(id > 0)
	{
		m_itemidVec.push_back(id);
	}
}
void crReliveItemsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crReliveItemsMethod::operator()(crHandle &handle)
{
	if(!m_itemidVec.empty())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			crInstanceItem *item;
			int roomid = m_this->getRoomID();
			//unsigned char itemstate = IS_Relive;
			void *param;
			crData *thisData;
			PatrolPointVec* patrolPointVec;
			int count;
			char idx;
			crVector2i coord;
			float coordz;
			float scale = crGlobalHandle::gData()->gUnitScale();
			for( IDVec::iterator itr = m_itemidVec.begin();
				 itr != m_itemidVec.end();
				 ++itr )
			{
				item = scene->findRoomItem(roomid,*itr);
				if(item)
				{
					thisData = item->getDataClass();
					thisData->excHandle(MAKEINT64(WCH_InitData,item));

					//thisData->inputParam(WCHDATA_ItemState, &itemstate);

					thisData->excHandle(MAKEINT64(WCH_LockData,1));
					thisData->getParam(WCHDATA_PatrolPointVec,param);
					patrolPointVec = (PatrolPointVec*)param;
					if(patrolPointVec && !patrolPointVec->empty())
					{
						thisData->getParam(WCHDATA_PatrolLoopMode,param);
						unsigned char loopmode = *(unsigned char *)param;
						if(loopmode == PL_NoLoop)
						{
							idx = 0;
						}
						else
						{
							count = patrolPointVec->size();
							idx = rangei(0,count).get_random();
							thisData->inputParam(WCHDATA_PatrolIndex,&idx);
						}
						coord = (*patrolPointVec)[idx];
						coordz = scene->getPosZ(item->getLayerID(), (float)coord[0]*scale, (float)coord[1]*scale, (float)(item->getZoffset()) * scale);
						item->setPosxy(coord[0],coord[1]);
						item->setPosz(coordz / scale);
					}
					thisData->excHandle(MAKEINT64(WCH_LockData,0));
					scene->itemRelive(item);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crKillItemsMethod
//
/////////////////////////////////////////
crKillItemsMethod::crKillItemsMethod(){}
crKillItemsMethod::crKillItemsMethod(const crKillItemsMethod& handle):
	crMethod(handle),
	m_itemidVec(handle.m_itemidVec)
{
}
void crKillItemsMethod::addParam(int i, const std::string& str)
{
	int id = atoi(str.c_str());
	if(id > 0)
	{
		m_itemidVec.push_back(id);
	}
}
void crKillItemsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crKillItemsMethod::operator()(crHandle &handle)
{
	if(!m_itemidVec.empty())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			crInstanceItem *item;
			crData *thisData;
			unsigned char itemstate = IS_Dead;
			for( IDVec::iterator itr = m_itemidVec.begin();
				itr != m_itemidVec.end();
				++itr )
			{
				item = scene->findRoomItem(m_this->getRoomID(),*itr);
				if(item)
				{		
					thisData = item->getDataClass();	
					thisData->inputParam(WCHDATA_ItemState, &itemstate);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crNextRoomProgressMethod
//
/////////////////////////////////////////
crNextRoomProgressMethod::crNextRoomProgressMethod():
m_this(NULL){}
crNextRoomProgressMethod::crNextRoomProgressMethod(const crNextRoomProgressMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crNextRoomProgressMethod::addParam(int i, const std::string& str)
{
}
void crNextRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crNextRoomProgressMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_RoomProgress,param);
	short *progress = (short *)param;
	(*progress)++;
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crRoomSetRoomProgressMethod
//
/////////////////////////////////////////
crRoomSetRoomProgressMethod::crRoomSetRoomProgressMethod():
m_this(NULL),
m_progress(0){}
crRoomSetRoomProgressMethod::crRoomSetRoomProgressMethod(const crRoomSetRoomProgressMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_progress(handle.m_progress)
{
}
void crRoomSetRoomProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = atoi(str.c_str());
		break;
	}
}
void crRoomSetRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crRoomSetRoomProgressMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_RoomProgress,&m_progress);
}
/////////////////////////////////////////
//
//crTriggerSetRoomProgressMethod
//
/////////////////////////////////////////
crTriggerSetRoomProgressMethod::crTriggerSetRoomProgressMethod():
	m_progress(0){}
crTriggerSetRoomProgressMethod::crTriggerSetRoomProgressMethod(const crTriggerSetRoomProgressMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crTriggerSetRoomProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = atoi(str.c_str());
		break;
	}
}
void crTriggerSetRoomProgressMethod::inputParam(int i, void *param)
{
}
void crTriggerSetRoomProgressMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && room && room->getGameRunning())
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(2);
		stream->_writeShort(m_progress);
		crRoomEventPacket packet;
		crRoomEventPacket::buildRequestPacket(packet,WCH_RecvTriggerSetRoomProgress,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crRecvTriggerSetRoomProgressMethod
//
/////////////////////////////////////////
crRecvTriggerSetRoomProgressMethod::crRecvTriggerSetRoomProgressMethod(){}
crRecvTriggerSetRoomProgressMethod::crRecvTriggerSetRoomProgressMethod(const crRecvTriggerSetRoomProgressMethod& handle):
	crMethod(handle)
{
}
void crRecvTriggerSetRoomProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvTriggerSetRoomProgressMethod::addParam(int i, const std::string& str)
{
}

void crRecvTriggerSetRoomProgressMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		short progress = m_stream->_readShort();
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_RoomProgress,&progress);
	}
}
/////////////////////////////////////////
//
//crRoomProgressEventMethod
//
/////////////////////////////////////////
crRoomProgressEventMethod::crRoomProgressEventMethod():
	m_this(NULL){}
crRoomProgressEventMethod::crRoomProgressEventMethod(const crRoomProgressEventMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crRoomProgressEventMethod::addParam(int i, const std::string& str)
{
}
void crRoomProgressEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crRoomProgressEventMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_RoomProgress,param);
	short progress = *(short *)param;
	crRoomEventPacket packet;
	crRoomEventPacket::buildRequestPacket(packet,0,MAKEINT64(WCH_RecvRoomProgressEvent,progress));
	m_this->sendPacketToAll(packet);
}
/////////////////////////////////////////
//
//crScenarioEventMethod
//
/////////////////////////////////////////
crScenarioEventMethod::crScenarioEventMethod():
	m_this(NULL),
m_msgid(0){}
crScenarioEventMethod::crScenarioEventMethod(const crScenarioEventMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msgid(handle.m_msgid)
{
}
void crScenarioEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgid = atoi(str.c_str());
		break;
	}
}
void crScenarioEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crScenarioEventMethod::operator()(crHandle &handle)
{
	ref_ptr<crRoomEventPacket> packet = new crRoomEventPacket;
	crRoomEventPacket::buildRequestPacket(*packet,0,MAKEINT64(WCH_RecvScenarioEvent,m_msgid));
	m_this->sendRoomMessage(packet.get());
}
/////////////////////////////////////////
//
//crIFItemsDeadMethod
//
/////////////////////////////////////////
crIFItemsDeadMethod::crIFItemsDeadMethod(){}
crIFItemsDeadMethod::crIFItemsDeadMethod(const crIFItemsDeadMethod& handle):
	crMethod(handle),
	m_itemidVec(handle.m_itemidVec)
{
}
void crIFItemsDeadMethod::addParam(int i, const std::string& str)
{
	int id = atoi(str.c_str());
	if(id > 0)
	{
		m_itemidVec.push_back(id);
	}
}
void crIFItemsDeadMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crIFItemsDeadMethod::operator()(crHandle &handle)
{
	bool condition = true;
	if(!m_itemidVec.empty())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			crInstanceItem *item;
			void *param;
			crData *itemData;
			unsigned char itemstate;
			for( IDVec::iterator itr = m_itemidVec.begin();
				itr != m_itemidVec.end();
				++itr )
			{
				item = scene->findRoomItem(m_this->getRoomID(),*itr);
				if(item)
				{	
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate != IS_Dead)
					{
						condition = false;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crShowSceneNodesMethod
//
/////////////////////////////////////////
crShowSceneNodesMethod::crShowSceneNodesMethod():
m_show(true),
m_nodetype(MATRIXTRANSFORM){}
crShowSceneNodesMethod::crShowSceneNodesMethod(const crShowSceneNodesMethod& handle):
	crMethod(handle),
	m_show(handle.m_show),
	m_nodetype(handle.m_nodetype)
{
}
void crShowSceneNodesMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_show = atoi(str.c_str());
		break;
	case 1:
		m_nodetype = atoi(str.c_str());
		break;
	default:
		m_nodeNameVec.push_back(str);
	}
}
void crShowSceneNodesMethod::inputParam(int i, void *param)
{
}
void crShowSceneNodesMethod::operator()(crHandle &handle)
{
	crGroup *root = crSceneManager::getInstance()->getStaticRoot();
	if(root)
	{
		crCollectNodeBYNameVisitor collector((SearchNodeType)m_nodetype);
		for( StrVec::iterator itr = m_nodeNameVec.begin();
			itr != m_nodeNameVec.end();
			++itr )
		{
			collector.insertNodeNameId(*itr);
		}
		root->accept(collector);
		NodeArray &nodeArray = collector.getResult();
		for( NodeArray::iterator itr = nodeArray.begin();
			 itr != nodeArray.end();
			 ++itr )
		{
			(*itr)->setVisiable(m_show);
		}
	}
}
/////////////////////////////////////////
//
//crClientAddEyePointsMethod
//
/////////////////////////////////////////
crClientAddEyePointsMethod::crClientAddEyePointsMethod(){}
crClientAddEyePointsMethod::crClientAddEyePointsMethod(const crClientAddEyePointsMethod& handle):
	crMethod(handle),
	m_coordVec(handle.m_coordVec)
{
}
void crClientAddEyePointsMethod::addParam(int i, const std::string& str)
{
	crVector2 vec;
	crArgumentParser::appAtoVec(str,vec);
	vec /= crGlobalHandle::gData()->gUnitScale();
	crVector2i coord(vec[0],vec[1]);
	m_coordVec.push_back(coord);
}
void crClientAddEyePointsMethod::inputParam(int i, void *param)
{
}
void crClientAddEyePointsMethod::operator()(crHandle &handle)
{
	for( CoordVec::iterator itr = m_coordVec.begin();
		 itr != m_coordVec.end();
		 ++itr )
	{
		crMyPlayerData::getInstance()->insertEyePoint(*itr);
	}
}
/////////////////////////////////////////
//
//crClientRemoveEyePointsMethod
//
/////////////////////////////////////////
crClientRemoveEyePointsMethod::crClientRemoveEyePointsMethod(){}
crClientRemoveEyePointsMethod::crClientRemoveEyePointsMethod(const crClientRemoveEyePointsMethod& handle):
	crMethod(handle),
	m_coordVec(handle.m_coordVec)
{
}
void crClientRemoveEyePointsMethod::addParam(int i, const std::string& str)
{
	crVector2 vec;
	crArgumentParser::appAtoVec(str,vec);
	vec /= crGlobalHandle::gData()->gUnitScale();
	crVector2i coord(vec[0],vec[1]);
	m_coordVec.push_back(coord);
}
void crClientRemoveEyePointsMethod::inputParam(int i, void *param)
{
}
void crClientRemoveEyePointsMethod::operator()(crHandle &handle)
{
	for( CoordVec::iterator itr = m_coordVec.begin();
		itr != m_coordVec.end();
		++itr )
	{
		crMyPlayerData::getInstance()->removeEyePoint(*itr);
	}
}
/////////////////////////////////////////
//
//crSetRoomAutoStartMethod
//
/////////////////////////////////////////
crSetRoomAutoStartMethod::crSetRoomAutoStartMethod():
	m_autoStart(false),
	m_autoStartTime(0.0f),
	m_removeTime(0.0f){}
crSetRoomAutoStartMethod::crSetRoomAutoStartMethod(const crSetRoomAutoStartMethod& handle):
	crMethod(handle),
	m_autoStart(handle.m_autoStart),
	m_autoStartTime(handle.m_autoStartTime),
	m_removeTime(handle.m_removeTime)
{
}
void crSetRoomAutoStartMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crSetRoomAutoStartMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_autoStart = (bool)(atoi(str.c_str()));
		break;
	case 1:
		m_autoStartTime = atof(str.c_str());
		break;
	case 2:
		m_removeTime = atof(str.c_str());
		break;
	}
}

void crSetRoomAutoStartMethod::operator()(crHandle &handle)
{
	m_this->setAutoStart(m_autoStart,m_autoStartTime);
	if(m_removeTime>0.0f)
		m_this->setRemoveTime(m_removeTime);
}
///////////////////////////////////////////
////
////crDynamicCollideCheckMethod
////
///////////////////////////////////////////
//crDynamicCollideCheckMethod::crDynamicCollideCheckMethod():
//m_guisestate(GS_Normal),
//m_dt(0.0f),
//m_noneblockInterval(1.0f),
//m_timer(0.0f){}
//crDynamicCollideCheckMethod::crDynamicCollideCheckMethod(const crDynamicCollideCheckMethod& handle):
//	crMethod(handle),
//	m_guisestate(handle.m_guisestate),
//	m_dt(0.0f),
//	m_noneblockInterval(handle.m_noneblockInterval),
//	m_timer(0.0f)
//{
//}
//void crDynamicCollideCheckMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem *)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((float*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0.0f;
//		}
//		break;
//	}
//}
//
//void crDynamicCollideCheckMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_noneblockInterval = atof(str.c_str());
//		break;
//	}
//}
//
//void crDynamicCollideCheckMethod::operator()(crHandle &handle)
//{
//	crScene *scene = crMyPlayerData::getInstance()->getScene();
//	if(scene)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->getParam(WCHDATA_GuiseState,param);
//		unsigned char guisestate = *(unsigned char *)param;
//		if(guisestate == GS_NoneBlock)
//		{
//			m_timer-=m_dt;
//			if(m_timer<0.0f)
//			{
//				data->inputParam(WCHDATA_GuiseState,&m_guisestate);
//				m_timer = 0.0f;
//			}
//		}
//		else
//		{
//			crVector2 pos(m_this->getPosx(),m_this->getPosy());
//			float scale = crGlobalHandle::gData()->gUnitScale();
//			pos *= scale;
//			crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
//			crInstanceItem *item = scene->dynamicCollideTest(pos,m_this,scenelayer);
//			if(item)
//			{
//				m_guisestate = guisestate;
//				guisestate = GS_NoneBlock;
//				data->inputParam(WCHDATA_GuiseState,&guisestate);
//				m_timer = m_noneblockInterval;
//			}
//		}
//			//crVector3 newPos;
//			//if(scene->findNonblockPos(m_this,pos,10,newPos))
//			//{
//			//	m_this->addSyncPos(crVector2(newPos[0],newPos[1]));
//			//}
//				//crVector2 itempos(item->getPosx(),item->getPosy());
//				//crVector2 dir = pos - itempos;
//				//dir.normalize();
//				//crVector2s dirs;
//				//if(dir[0]>=0.5f)
//				//	dirs[0] = 1;
//				//else if(dir[0]<=-0.5f)
//				//	dirs[0] = -1;
//				//else
//				//	dirs[0] = 0;
//				//if(dir[1]>=0.5f)
//				//	dirs[1] = 1;
//				//else if(dir[1]<=-0.5f)
//				//	dirs[1] = -1;
//				//else
//				//	dirs[1] = 0;
//				//if(dirs == crVector2s(0,0))
//				//	dirs[1] = 1;
//				//crVector2s pathCoord = scenelayer->getCoord(pos);
//				//short search = 1;
//				//short x,y;
//				//crVector2 newPos;
//				//crVector2s test;
//				//bool found = false;
//				//do
//				//{
//				//	test = pathCoord + dirs * search;
//				//	x = test[0];
//				//	y = test[1];
//				//	newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//	if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//	{
//				//		found = true;
//				//		break;
//				//	}
//				//	if(dirs != crVector2s(0,1))
//				//	{
//				//		x = pathCoord[0];
//				//		y = pathCoord[1] + search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs != crVector2s(0,-1))
//				//	{
//				//		x = pathCoord[0];
//				//		y = pathCoord[1] - search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(1,0))
//				//	{
//				//		x = pathCoord[0] + search;
//				//		y = pathCoord[1];
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(-1,0))
//				//	{
//				//		x = pathCoord[0] - search;
//				//		y = pathCoord[1];
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(-1,-1))
//				//	{
//				//		x = pathCoord[0] - search;
//				//		y = pathCoord[1] - search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(-1,1))
//				//	{
//				//		x = pathCoord[0] - search;
//				//		y = pathCoord[1] + search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(1,1))
//				//	{
//				//		x = pathCoord[0] + search;
//				//		y = pathCoord[1] + search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	if(dirs!=crVector2s(1,-1))
//				//	{
//				//		x = pathCoord[0] + search;
//				//		y = pathCoord[1] - search;
//				//		newPos = scenelayer->getPosXY(crVector2s(x,y));
//				//		if(scenelayer->walkability(x,y) && !scene->dynamicCollideTest(newPos,m_this,scenelayer))
//				//		{
//				//			found = true;
//				//			break;
//				//		}
//				//	}
//				//	search++;
//				//} while (search<=20);
//				//if(found)
//				//	m_this->addSyncPos(newPos);
//				//else
//				//{//将item暂时设置为不可碰撞？
//
//				//}
//		//}
//	}
//}
/////////////////////////////////////////
//
//crSyncPosEmptyMethod
//
/////////////////////////////////////////
crSyncPosEmptyMethod::crSyncPosEmptyMethod(){}
crSyncPosEmptyMethod::crSyncPosEmptyMethod(const crSyncPosEmptyMethod& handle):
	crMethod(handle)
{
}
void crSyncPosEmptyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}

void crSyncPosEmptyMethod::addParam(int i, const std::string& str)
{
}

void crSyncPosEmptyMethod::operator()(crHandle &handle)
{
	bool empty = !m_this->hasSyncPos();
	handle.outputParam(0,&empty);
}
/////////////////////////////////////////
//
//crDynamicChangePathMethod
//
/////////////////////////////////////////
crDynamicChangePathMethod::crDynamicChangePathMethod(){}
crDynamicChangePathMethod::crDynamicChangePathMethod(const crDynamicChangePathMethod& handle):
	crMethod(handle)
{
}
void crDynamicChangePathMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}

void crDynamicChangePathMethod::addParam(int i, const std::string& str)
{
}

void crDynamicChangePathMethod::operator()(crHandle &handle)
{
	crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(scene)
		m_this->getOrCreatePathFinder()->dynamicChangePath(m_this,scene);
}
/////////////////////////////////////////
//
//crSetRemainTimeMethod
//
/////////////////////////////////////////
crSetRemainTimeMethod::crSetRemainTimeMethod():
	m_remainTime(0.0f){}
crSetRemainTimeMethod::crSetRemainTimeMethod(const crSetRemainTimeMethod& handle):
	crMethod(handle),
	m_remainTime(handle.m_remainTime)
{
}
void crSetRemainTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crSetRemainTimeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_remainTime = atof(str.c_str());
		break;
	}
}

void crSetRemainTimeMethod::operator()(crHandle &handle)
{
	m_this->timeRemain() = m_remainTime;
}
/////////////////////////////////////////
//
//crIsRoomPlayerEmptyMethod
//
/////////////////////////////////////////
crIsRoomPlayerEmptyMethod::crIsRoomPlayerEmptyMethod(){}
crIsRoomPlayerEmptyMethod::crIsRoomPlayerEmptyMethod(const crIsRoomPlayerEmptyMethod& handle):
	crMethod(handle)
{
}
void crIsRoomPlayerEmptyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crIsRoomPlayerEmptyMethod::addParam(int i, const std::string& str)
{
}

void crIsRoomPlayerEmptyMethod::operator()(crHandle &handle)
{
	bool empty = m_this->getPlayerCount() == 0;
	//if(empty)
	//	CRCore::notify(CRCore::NOTICE)<<"RoomPlayerEmpty, roomid = "<<m_this->getRoomID()<<std::endl;
	handle.outputParam(0,&empty);
}
/////////////////////////////////////////
//
//crQueryServerListMethod
//
/////////////////////////////////////////
crQueryServerListMethod::crQueryServerListMethod(){}
crQueryServerListMethod::crQueryServerListMethod(const crQueryServerListMethod& handle):
	crMethod(handle)
{
}
void crQueryServerListMethod::inputParam(int i, void *param)
{
}

void crQueryServerListMethod::addParam(int i, const std::string& str)
{
}

void crQueryServerListMethod::operator()(crHandle &handle)
{
	crServerListQueryPacket packet;
	crServerListQueryPacket::buildRequestPacket(packet,crGlobalHandle::gData()->gGameID(),crMyPlayerData::getInstance()->getPlayerID());
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crRecvConnectServerMethod
//
/////////////////////////////////////////
crRecvConnectServerMethod::crRecvConnectServerMethod(){}
crRecvConnectServerMethod::crRecvConnectServerMethod(const crRecvConnectServerMethod& handle):
	crMethod(handle)
{
}
void crRecvConnectServerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crRecvConnectServerMethod::addParam(int i, const std::string& str)
{
}

void crRecvConnectServerMethod::operator()(crHandle &handle)
{
	bool code = false;
	if(m_stream.valid())
	{
		code = m_stream->_readBool();
		if(code)
		{
			ref_ptr<crQueryConnectServerData> connectServerData = new crQueryConnectServerData;
			connectServerData->setIP(m_stream->_readString());
			connectServerData->setIP2(m_stream->_readString());
			connectServerData->setIP3(m_stream->_readString());
			connectServerData->setPort(m_stream->_readUShort());
			crMyPlayerData::getInstance()->setConnectServerData(connectServerData.get());
		}
	}
	handle.outputParam(0,&code);
}
/////////////////////////////////////////
//
//crLoginGameNewMethod
//
/////////////////////////////////////////
crLoginGameNewMethod::crLoginGameNewMethod(){}
crLoginGameNewMethod::crLoginGameNewMethod(const crLoginGameNewMethod& handle):
	crMethod(handle),
	m_callback(handle.m_callback),
	m_servername(handle.m_servername),
	m_password(handle.m_password)
{
}
void crLoginGameNewMethod::inputParam(int i, void *param)
{
}

void crLoginGameNewMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_callback = str;
		break;
	case 1:
		m_servername = str;
		break;
	case 2:
		m_password = str;
		break;
	}
}
void crLoginGameNewMethod::operator()(crHandle &handle)
{
	bool sucess = false;
	crQueryConnectServerData *connectServerData = crMyPlayerData::getInstance()->getConnectServerData();
	if(connectServerData)
	{
		CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
		netConductor->init(connectServerData->getPort());
		netConductor->setNetType(CRNetApp::GameClient_Game);
		netConductor->setName("GameClient_Game");
		netConductor->setEnableCook(true);
		int playerid = crMyPlayerData::getInstance()->getPlayerID();
		CRCore::notify(CRCore::ALWAYS)<<"连接到游戏服务器:"<<connectServerData->getIP()<<":"<<connectServerData->getPort()<<std::endl;
		crBlockDetectThread::getInstance()->pause();
		int code = 0;
		if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
			code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0);
		else
			code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,10);
		//int code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,5);
		crBlockDetectThread::getInstance()->resume();
		if(code<=0)
		{
			switch (code)
			{
			case 0:
				//无法创建客户端
				CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
				break;
			case -1:
				//超出服务器连接人数限制
				CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
				break;
			case -2:
				//同名客户端已经存在
				CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
				break;
			case -3:
				//要求连接的服务端名字与本服务器名不同
				CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
				break;
			case -4:
				//服务器密码不正确
				CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
				break;
			default:
				CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器"<<std::endl;
			}
		}
		else
		{
			CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
			//CRCore::notify(CRCore::ALWAYS)<<"已经与游戏服务器建立连接"<<std::endl;
			if(crMyPlayerData::getInstance()->getSelectedGame())
			{
				crLoginGamePacket packet;
				crLoginGamePacket::buildRequestPacket(packet);
				netConductor->getNetManager()->sendPacket("all",packet);

				sucess = true;
			}
		}
	}
	handle.outputParam(0,&sucess);
}
/////////////////////////////////////////
//
//crInitDownloadMethod
//
/////////////////////////////////////////
crInitDownloadMethod::crInitDownloadMethod(){}
crInitDownloadMethod::crInitDownloadMethod(const crInitDownloadMethod& handle):
	crMethod(handle)
{
}
void crInitDownloadMethod::inputParam(int i, void *param)
{
}

void crInitDownloadMethod::addParam(int i, const std::string& str)
{
}

void crInitDownloadMethod::operator()(crHandle &handle)
{
	char gbuf[256];
	std::string file = "Client.cfg";
	rcfg::ConfigScript cfg_script;
	if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,file))
	{
		//CRCore::notify(CRCore::FATAL)<<"crInitDownloadMethod(): file open error,"<<file<<std::endl;
		sprintf(gbuf,"crInitDownloadMethod(): file open error,%s\n\0",file.c_str());
		gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
		return;
	}
	std::string host,host1,hostdir,root;
	cfg_script.Get("HttpHost", host);
	cfg_script.Get("HttpHost1", host1);
	cfg_script.Get("HostDir", hostdir);
	cfg_script.Get("FileRoot", root);
	crDownloadManager::getInstance()->setHostDir(hostdir);
	crDownloadManager::getInstance()->setFileRootDir(root);
	crDownloadManager::getInstance()->setHost(host);
	if(host1.empty())
		host1 = host;
	crDownloadManager::getInstance()->setHost1(host1);
	sprintf(gbuf,"HttpHost:%s,HostDir:%s,FileRoot:%s\n\0",host.c_str(),hostdir.c_str(),root.c_str());
	gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
	//crDownloadManager::getInstance()->start(1);
	ref_ptr<crTableIO> dynamictable = crTableIO::openFile(crDownloadManager::getInstance()->getFileRootDir()+"/"+crGlobalHandle::gData()->gDynamicDownloadTabName());
	CRNetApp::crGlobalHandle::gData()->inputParam(WCHDATA_gNewDynamicDownloadTab,dynamictable.get());
}
/////////////////////////////////////////
//
//crSetDownloadThreadCountMethod
//
/////////////////////////////////////////
crSetDownloadThreadCountMethod::crSetDownloadThreadCountMethod():
m_threadcount(1){}
crSetDownloadThreadCountMethod::crSetDownloadThreadCountMethod(const crSetDownloadThreadCountMethod& handle):
	crMethod(handle),
	m_threadcount(handle.m_threadcount)
{
}
void crSetDownloadThreadCountMethod::inputParam(int i, void *param)
{
}

void crSetDownloadThreadCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_threadcount = atoi(str.c_str());
		break;
	}
}

void crSetDownloadThreadCountMethod::operator()(crHandle &handle)
{
	crDownloadManager::getInstance()->start(m_threadcount);
}
/////////////////////////////////////////
//
//crFiniDownloadMethod
//
/////////////////////////////////////////
crFiniDownloadMethod::crFiniDownloadMethod(){}
crFiniDownloadMethod::crFiniDownloadMethod(const crFiniDownloadMethod& handle):
	crMethod(handle)
{
}
void crFiniDownloadMethod::inputParam(int i, void *param)
{
}

void crFiniDownloadMethod::addParam(int i, const std::string& str)
{
}

void crFiniDownloadMethod::operator()(crHandle &handle)
{
	crDownloadManager::getInstance()->clear();
}
/////////////////////////////////////////
//
//crDownloadFilesMethod
//
/////////////////////////////////////////
crDownloadFilesMethod::crDownloadFilesMethod(){}
crDownloadFilesMethod::crDownloadFilesMethod(const crDownloadFilesMethod& handle):
	crMethod(handle),
	m_fileList(handle.m_fileList)
{
}
void crDownloadFilesMethod::inputParam(int i, void *param)
{
}
void crDownloadFilesMethod::addParam(int i, const std::string& str)
{
	m_fileList.push_back(str);
}
void crDownloadFilesMethod::operator()(crHandle &handle)
{
	ref_ptr<crDownload> download;
	for( StrVec::iterator itr = m_fileList.begin();
		 itr != m_fileList.end();
		 ++itr )
	{
		download = new crDownload(*itr);
		crDownloadManager::getInstance()->addImmediatelyDownloadRequest(download.get());
	}
}
/////////////////////////////////////////
//
//crCreRestartMethod
//
/////////////////////////////////////////
crCreRestartMethod::crCreRestartMethod():
	m_code(0){}
crCreRestartMethod::crCreRestartMethod(const crCreRestartMethod& handle):
	crMethod(handle),
	m_code(handle.m_code)
{
}
void crCreRestartMethod::inputParam(int i, void *param)
{
}
void crCreRestartMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_code = atoi(str.c_str());
		break;
	}
}
void crCreRestartMethod::operator()(crHandle &handle)
{
	char buf[16];
	memset(buf,0,16);
	sprintf(buf,"CRE_RESTART=%d\0",m_code);
	_putenv(buf);
}
/////////////////////////////////////////
//
//crCloseRunProtectedHandleMethod
//
/////////////////////////////////////////
crCloseRunProtectedHandleMethod::crCloseRunProtectedHandleMethod(){}
crCloseRunProtectedHandleMethod::crCloseRunProtectedHandleMethod(const crCloseRunProtectedHandleMethod& handle):
	crMethod(handle)
{
}
void crCloseRunProtectedHandleMethod::inputParam(int i, void *param)
{
}
void crCloseRunProtectedHandleMethod::addParam(int i, const std::string& str)
{
}
void crCloseRunProtectedHandleMethod::operator()(crHandle &handle)
{
	if(crGlobalHandle::getRunProtectHandle())
	{
		CloseHandle(crGlobalHandle::getRunProtectHandle());
		crGlobalHandle::setRunProtectHandle(NULL);
	}
}
/////////////////////////////////////////
//
//crDownloadUpdateMethod
//
/////////////////////////////////////////
crDownloadUpdateMethod::crDownloadUpdateMethod(){}
crDownloadUpdateMethod::crDownloadUpdateMethod(const crDownloadUpdateMethod& handle):
	crMethod(handle)
{
}
void crDownloadUpdateMethod::inputParam(int i, void *param)
{
}
void crDownloadUpdateMethod::addParam(int i, const std::string& str)
{
}
void crDownloadUpdateMethod::operator()(crHandle &handle)
{
	crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
	if(data) data->downloadUpdate();
}
/////////////////////////////////////////
//
//crLoadingProgressMethod
//
/////////////////////////////////////////
crLoadingProgressMethod::crLoadingProgressMethod():
m_speed(10.0f){}
crLoadingProgressMethod::crLoadingProgressMethod(const crLoadingProgressMethod& handle):
	crMethod(handle),
	m_speed(handle.m_speed)
{
}
void crLoadingProgressMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_this = (CRGUI::crProgressElement*)param;
	else if(i == -3)
		m_dt = *(float*)param;
}

void crLoadingProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_speed = atof(str.c_str());
		break;
	}
}

void crLoadingProgressMethod::operator()(crHandle &handle)
{
	float progress = crRunGameHandle::getInstance()->getLoadingProgress();
	float& curProgress = crRunGameHandle::getInstance()->curLoadingProgress();
	if(curProgress<progress)
	{
		curProgress += m_dt * m_speed;
		if(curProgress>progress)
			curProgress = progress;
		m_this->setProgress(curProgress);
	}
}
/////////////////////////////////////////
//
//crSetFocusNodeMethod
//
/////////////////////////////////////////
crSetFocusNodeMethod::crSetFocusNodeMethod(){}
crSetFocusNodeMethod::crSetFocusNodeMethod(const crSetFocusNodeMethod& handle):
	crMethod(handle),
	m_focusWidget(handle.m_focusWidget)
{
}
void crSetFocusNodeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crSetFocusNodeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_focusWidget = str;
		break;
	}
}

void crSetFocusNodeMethod::operator()(crHandle &handle)
{
	ref_ptr<crWidgetNode> widget = m_this->getWidget(m_focusWidget);
	crFilterRenderManager::getInstance()->setFocusNode(widget.get());
	if (widget->getEnable())
	{
		if(widget->getCanCaptureMouse())
			crFilterRenderManager::getInstance()->setMouseCapturer(widget.get());
		if(widget->getCanCaptureInput())
			crFilterRenderManager::getInstance()->setInputCapturer(widget.get());
		else
			crFilterRenderManager::getInstance()->setInputCapturer(NULL);
	}
}
/////////////////////////////////////////
//
//crSetDefFocusIndexMethod
//
/////////////////////////////////////////
crSetDefFocusIndexMethod::crSetDefFocusIndexMethod(){}
crSetDefFocusIndexMethod::crSetDefFocusIndexMethod(const crSetDefFocusIndexMethod& handle):
	crMethod(handle),
	m_index(handle.m_index)
{
}
void crSetDefFocusIndexMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crSetDefFocusIndexMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	}
}

void crSetDefFocusIndexMethod::operator()(crHandle &handle)
{
	m_this->setDefFocusIndex(m_index);
}
/////////////////////////////////////////
//
//crSendRoomTimeRemainMethod
//
/////////////////////////////////////////
crSendRoomTimeRemainMethod::crSendRoomTimeRemainMethod(){}
crSendRoomTimeRemainMethod::crSendRoomTimeRemainMethod(const crSendRoomTimeRemainMethod& handle):
	crMethod(handle)
{
}
void crSendRoomTimeRemainMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crSendRoomTimeRemainMethod::addParam(int i, const std::string& str)
{
}

void crSendRoomTimeRemainMethod::operator()(crHandle &handle)
{
	crRoomGameTimePacket packet;
	crRoomGameTimePacket::buildReplyPacket(packet,0,m_this->timeRemain());
	m_this->sendPacketToAll(packet);
}
/////////////////////////////////////////
//
//crRoomUpdate2Method
//
/////////////////////////////////////////
crRoomUpdate2Method::crRoomUpdate2Method():
m_this(NULL),
m_dt(NULL),
m_sc(NULL){}
crRoomUpdate2Method::crRoomUpdate2Method(const crRoomUpdate2Method& handle):
crMethod(handle),
m_this(NULL),
m_dt(NULL),
m_sc(NULL)
{
}
void crRoomUpdate2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
			m_sc = (crSceneServerCallback*)(HIINT64(param64));
		}
		else
		{
			m_dt = NULL;
			m_sc = NULL;
		}
		break;
	}
}

void crRoomUpdate2Method::addParam(int i, const std::string& str)
{
}

void crRoomUpdate2Method::operator()(crHandle &handle)
{
	m_this->doEvent(WCH_RoomUpdate2,MAKEINT64(m_dt,m_sc));
}
/////////////////////////////////////////
//
//crDynamicCollideExtraMethod
//
/////////////////////////////////////////
crDynamicCollideExtraMethod::crDynamicCollideExtraMethod():
	m_this(NULL),
	m_dt(NULL),
m_timer(0.0f),
m_interval(0.5f){}
crDynamicCollideExtraMethod::crDynamicCollideExtraMethod(const crDynamicCollideExtraMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL),
	m_timer(0.0f),
	m_interval(handle.m_interval)
{
}
void crDynamicCollideExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crDynamicCollideExtraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crDynamicCollideExtraMethod::operator()(crHandle &handle)
{
	bool notcollided = true;
	m_timer+=*m_dt;
	if(m_timer<=m_interval)
	{
		handle.outputParam(0,&notcollided);
		return;
	}
	m_timer = 0.0f;
	void *param;
	crData* data = m_this->getDataClass();
	//data->getParam(WCHDATA_TargetType,param);
	//unsigned char targettype = *(unsigned char *)param;
	crInstanceItem *item = NULL;
	data->getParam(WCHDATA_ItemState,param);
	unsigned char itemstate = *((unsigned char*)param);
	if(itemstate < IS_Move || itemstate>=IS_Defend)
	//if(/*targettype <= Target_Coord && */m_this->getOrCreatePathFinder()->isBestPathEmpty()/* && crMyPlayerData::getInstance()->getScene()*/)
	{
		crScene *scene = crMyPlayerData::getInstance()->getScene();
		crVector2 pos(m_this->getPosx(),m_this->getPosy());
		float scale = crGlobalHandle::gData()->gUnitScale();
		pos *= scale;		
		crSceneLayer *scenelayer = scene->getSceneLayer(m_this->getLayerID());
		crVector2s coord = scenelayer->getCoord(pos[0],pos[1]);
		if(!scenelayer->walkability(coord[0],coord[1]) || scene->dynamicCollideTest(pos,m_this,scenelayer))
		//item = scene->dynamicCollideTest(pos,m_this,scenelayer);
		//if(item)
		{
			//data->getParam(WCHDATA_ItemState,param);
			//unsigned char itemstate = *(unsigned char *)param;
			//char isEnemy = 0;
			//item->doEvent(WCH_EnemyCheck,MAKEINT64(m_this,&isEnemy));
			//if(isEnemy == 1 && itemstate != IS_Stop)
			//{
			//	short extid = Ext_Block;
			//	crHandle *handle = data->getHandle(MAKEINT64(WCH_ExtraHandle,extid));
			//	if(handle)
			//	{
			//		//data->excHandle(MAKEINT64(WCH_LockData,1));
			//		data->getParam(WCHDATA_ExtraData,param);
			//		crData *extraData = (crData *)param;
			//		if(extraData)
			//		{
			//			extraData->excHandle(MAKEINT64(WCH_LockData,1));
			//			extraData->getParam(WCHDATA_ExtraIDMap,param);
			//			ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
			//			if(extraData && extraIDMap->find(extid) == extraIDMap->end())
			//			{
			//				crHandle *cloneHandle = handle->clone();
			//				extraData->insertHandle(MAKEINT64(WCH_DoExtra,extid),cloneHandle);
			//				(*extraIDMap)[extid] = 0;
			//			}
			//			extraData->excHandle(MAKEINT64(WCH_LockData,0));
			//		}
			//		//data->excHandle(MAKEINT64(WCH_LockData,0));
			//	}
			//}
			//else
			//{
				crVector3 newPos;
				if(scene->findNonblockPos(m_this,pos,10,newPos))
				{
					//newPos /= scale;
					m_this->addSyncPos(crVector2(newPos[0],newPos[1]));
					/*m_this->setPosxy(newPos[0],newPos[1]);
					m_this->setPosz(newPos[2]);
					crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
					if(bot)
					{
					m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
					}*/
				}
			//}
			notcollided = false;
		}
	}
	//if(!item)
	//	m_timer = 0.0f;
	handle.outputParam(0,&notcollided);
}
/////////////////////////////////////////
//
//crItemDeadCheckMethod
//
/////////////////////////////////////////
crItemDeadCheckMethod::crItemDeadCheckMethod():
m_this(NULL){}
crItemDeadCheckMethod::crItemDeadCheckMethod(const crItemDeadCheckMethod& handle):
crMethod(handle),
m_this(NULL)
{
}
void crItemDeadCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crItemDeadCheckMethod::addParam(int i, const std::string& str)
{
}
void crItemDeadCheckMethod::operator()(crHandle &handle)
{
	bool itemdead = false;
	void *param;
	crData *thisData = m_this->getDataClass();
	thisData->getParam(WCHDATA_ItemState,param);
	unsigned char itemstate = *((unsigned char*)param);
	if(itemstate == IS_Dead)
		itemdead = true;
	handle.outputParam(0,&itemdead);
}
/////////////////////////////////////////
//
//crRobotLoginGameMethod
//
/////////////////////////////////////////
crRobotLoginGameMethod::crRobotLoginGameMethod():
	m_count(10),
m_threadcount(1){}
crRobotLoginGameMethod::crRobotLoginGameMethod(const crRobotLoginGameMethod& handle):
	crMethod(handle),
	m_callback(handle.m_callback),
	m_servername(handle.m_servername),
	m_password(handle.m_password),
	m_count(handle.m_count),
	m_threadcount(1)
{
}
void crRobotLoginGameMethod::inputParam(int i, void *param)
{
}

void crRobotLoginGameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_callback = str;
		break;
	case 1:
		m_servername = str;
		break;
	case 2:
		m_password = str;
		break;
	case 3:
		m_count = atoi(str.c_str());
		break;
	case 4:
		m_threadcount = atoi(str.c_str());
		break;
	}
}
class crRobotConnectThread: public CRCore::crThread, public CRCore::Referenced
{
public:
	crRobotConnectThread(crRobotLoginGameMethod *handle){m_handle=handle;}
	virtual void run(){m_handle->doConnect();}
protected:
	crRobotLoginGameMethod *m_handle;
};
void crRobotLoginGameMethod::operator()(crHandle &handle)
{
	if(m_threadcount>1)
	{
		ref_ptr<crRobotConnectThread> robotThread;
		std::vector< ref_ptr<crRobotConnectThread> >RobotThreadVec;
		for(int i = 0; i<m_threadcount; i++)
		{
			robotThread = new crRobotConnectThread(this);
			robotThread->startThread();
			RobotThreadVec.push_back(robotThread.get());
		}
	}
	else
	{
		doConnect();
	}
}
void crRobotLoginGameMethod::doConnect()
{
	static int s_robot = 0;
	crQueryConnectServerData *connectServerData = crMyPlayerData::getInstance()->getConnectServerData();
	if(connectServerData)
	{
		for(int i = 0; i<m_count;i++)
		{
			CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
			netConductor->init(connectServerData->getPort());
			netConductor->setNetType(CRNetApp::GameClient_Game);
			netConductor->setName("GameClient_Game");
			netConductor->setEnableCook(true);
			int playerid = crMyPlayerData::getInstance()->getPlayerID();
			//CRCore::notify(CRCore::ALWAYS)<<"连接到游戏服务器:"<<connectServerData->getIP()<<":"<<connectServerData->getPort()<<std::endl;
			crBlockDetectThread::getInstance()->pause();
			int code = 0;
			if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
				code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0);
			else
				code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,10);
			//int code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,5);
			crBlockDetectThread::getInstance()->resume();
			if(code<=0)
			{
				switch (code)
				{
				case 0:
					//无法创建客户端
					CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器，请检查服务器IP地址，端口或者ConnectServer是否启动"<<std::endl;
					break;
				case -1:
					//超出服务器连接人数限制
					CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
					break;
				case -2:
					//同名客户端已经存在
					CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
					break;
				case -3:
					//要求连接的服务端名字与本服务器名不同
					CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
					break;
				case -4:
					//服务器密码不正确
					CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
					break;
				default:
					CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器"<<std::endl;
				}
			}
			else
			{
				CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
				CRCore::notify(CRCore::ALWAYS)<<"机器人"<<++s_robot<<"已连接"<<std::endl;
				//crLoginGamePacket packet;
				//crLoginGamePacket::buildRequestPacket(packet);
				//netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crRegisterTestAccountMethod
//
/////////////////////////////////////////
crRegisterTestAccountMethod::crRegisterTestAccountMethod():
	m_start(1),
	m_end(1000)
{
	m_password = "1";
}
crRegisterTestAccountMethod::crRegisterTestAccountMethod(const crRegisterTestAccountMethod& handle):
	crMethod(handle),
	m_preName(handle.m_preName),
	m_end(handle.m_end),
	m_password(handle.m_password)
{
}
void crRegisterTestAccountMethod::inputParam(int i, void *param)
{
}
void crRegisterTestAccountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_preName = str;
		break;
	case 1:
		m_start = atoi(str.c_str());
		break;
	case 2:
		m_end = atoi(str.c_str());
		break;
	case 3:
		m_password = str;
		break;
	}
}
void crRegisterTestAccountMethod::operator()(crHandle &handle)
{
	std::string tmp;
	crRegisterAccountPacket packet;
	CRNet::crNetConductor* netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	for( int i = m_start; i<=m_end; i++)
	{
		crRegisterAccountPacket::buildRequestPacket(packet,m_preName+crArgumentParser::appItoa(i),m_password,tmp,tmp,tmp,0,tmp);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crWriteServerInfoMethod
//
/////////////////////////////////////////
crWriteServerInfoMethod::crWriteServerInfoMethod():
	m_minCount(100),
	m_writeCount(20),
	m_init(false)
{
}
crWriteServerInfoMethod::crWriteServerInfoMethod(const crWriteServerInfoMethod& handle):
	crMethod(handle),
	m_minCount(handle.m_minCount),
	m_writeCount(handle.m_writeCount),
	m_filepath(handle.m_filepath),
	m_init(handle.m_init)
{
}
void crWriteServerInfoMethod::inputParam(int i, void *param)
{
}
void crWriteServerInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_minCount = atoi(str.c_str());
		break;
	case 1:
		m_writeCount = atoi(str.c_str());
		break;
	case 2:
		m_filepath = str;
		break;
	}
}
/// 时间转换
static time_t file_time_2_utc(const FILETIME* ftime)
{
	LARGE_INTEGER li;
	assert(ftime);
	li.LowPart = ftime->dwLowDateTime;
	li.HighPart = ftime->dwHighDateTime;
	return li.QuadPart;
}
/// 获得CPU的核数
static int get_processor_number()
{
	SYSTEM_INFO info;
	GetSystemInfo(&info);
	return (int)info.dwNumberOfProcessors;
}
int crWriteServerInfoMethod::get_cpu_usage()
{
	//cpu数量
	static int processor_count_ = -1;
	//上一次的时间
	static time_t last_time_ = 0;
	static time_t last_system_time_ = 0;

	FILETIME now;
	FILETIME creation_time;
	FILETIME exit_time;
	FILETIME kernel_time;
	FILETIME user_time;
	time_t system_time;
	time_t time;
	time_t system_time_delta;
	time_t time_delta;

	int cpu = -1;

	if(processor_count_ == -1)
	{
		processor_count_ = get_processor_number();
	}

	GetSystemTimeAsFileTime(&now);

	if (!GetProcessTimes(GetCurrentProcess(), &creation_time, &exit_time,
		&kernel_time, &user_time))
	{
		// We don't assert here because in some cases (such as in the Task Manager)
		// we may call this function on a process that has just exited but we have
		// not yet received the notification.
		return -1;
	}
	system_time = (file_time_2_utc(&kernel_time) + file_time_2_utc(&user_time))/processor_count_;
	time = file_time_2_utc(&now);

	if ((last_system_time_ == 0) || (last_time_ == 0))
	{
		// First call, just set the last values.
		last_system_time_ = system_time;
		last_time_ = time;
		return -1;
	}

	system_time_delta = system_time - last_system_time_;
	time_delta = time - last_time_;

	assert(time_delta != 0);

	if (time_delta == 0)
		return -1;

	// We add time_delta / 2 so the result is rounded.
	cpu = (int)((system_time_delta * 100 + time_delta / 2) / time_delta);
	last_system_time_ = system_time;
	last_time_ = time;
	return cpu;
}
int crWriteServerInfoMethod::get_memory_usage()
{
	PROCESS_MEMORY_COUNTERS pmc;
	GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));
	//在任务管理器中显示为：内存（专用工作集） //这是任务管理器的默认显示项！
	return pmc.WorkingSetSize/1024;
}
void crWriteServerInfoMethod::operator()(crHandle &handle)
{
	crNetConductor *mainConductor = crNetContainer::getInstance()->getNetConductor(crNetContainer::getInstance()->getMainNetType());
	if(!m_init)
	{
		crNetDataManager *netDataManager = mainConductor->getNetDataManager();
		if(dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback()))
		{
			std::string servercname = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback())->getServerName();
			m_filename = m_filepath+servercname+"/"+servercname+".tab";
		}
		else if(dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback()))
		{
			m_filename = m_filepath+dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback())->getServerName()+"/"+netDataManager->getServerName() + ".tab";
		}
		else
			m_filename = m_filepath+netDataManager->getServerName() + ".tab";
		makeDirectoryForFile(m_filename);
		crTableIO::StrVec titleVec;
		titleVec.push_back("时间");
		titleVec.push_back("在线玩家数量");
		titleVec.push_back("CPU使用率");
		titleVec.push_back("内存占用");
		titleVec.push_back("房间数量");
		m_columncount = titleVec.size();
		if(!CRIOManager::fileExists(m_filename))
		{
			std::ofstream fout(m_filename.c_str(), std::ios::out);
			char tab = 9;
			char n = '\n';
			int i;
			for(i = 0; i<m_columncount-1; ++i)
			{
				fout.write(titleVec[i].c_str(),titleVec[i].length());
				fout.write(&tab,1);
			}
			fout.write(titleVec[i].c_str(),titleVec[i].length());
			fout.write(&n,1);
			fout.close();
		}
		m_serverInfoData.reserve(m_writeCount);
		m_init = true;
	}
	int playercount = mainConductor->getNetDataManager()->getPlayerCount();
	if(playercount>=m_minCount)
	{
		time_t t = time( 0 ); 
		char tmp[20];
		strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t) );
		crTableIO::StrVec record;
		record.resize(m_columncount);
		record[0] = tmp;
		record[1] = crArgumentParser::appItoa(playercount);
		record[2] = crArgumentParser::appItoa(get_cpu_usage());
		record[3] = crArgumentParser::appItoa(get_memory_usage());
		crNetDataManager *netDataManager = mainConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		if(netCallback)
			record[4] = crArgumentParser::appItoa(netCallback->getRoomCount());
		m_serverInfoData.push_back(record);
		int infosize = m_serverInfoData.size();
		if(infosize>=m_writeCount)
		{
			std::ofstream fout(m_filename.c_str(), std::ios::binary|std::ios::app);
			if(fout)
			{
				char tab = 9;
				char n = '\n';
				int i,j;
				for(i = 0; i<infosize;++i)
				{
					for(j=0; j<m_columncount-1; ++j)
					{
						fout.write(m_serverInfoData[i][j].c_str(),m_serverInfoData[i][j].length());
						fout.write(&tab,1); 
					}
					fout.write(m_serverInfoData[i][j].c_str(),m_serverInfoData[i][j].length());
					fout.write(&n,1);
				}
				fout.close();
			}
			m_serverInfoData.resize(0);
		}
		//char strbuf[64];
		//sprintf(strbuf," 在线玩家数量：%d  CPU使用率: %d\0",playercount,get_cpu_usage());
		//std::string str = tmp;
		//str += strbuf;
		//m_serverInfo.push_back(str);
		//if(m_serverInfo.size()>=m_writeCount)
		//{
		//	std::ofstream fout(m_filename.c_str(), std::ios::binary|std::ios::app);
		//	if(fout)
		//	{
		//		for( ServerInfoVec::iterator itr = m_serverInfo.begin();
		//			itr != m_serverInfo.end();
		//			++itr )
		//		{
		//			fout<<*itr<<std::endl;
		//		}
		//		fout.close();
		//	}
		//	m_serverInfo.resize(0);
		//}
	}
}
/////////////////////////////////////////
//
//crSetGamelogPathMethod
//
/////////////////////////////////////////
crSetGamelogPathMethod::crSetGamelogPathMethod()
{
}
crSetGamelogPathMethod::crSetGamelogPathMethod(const crSetGamelogPathMethod& handle):
	crMethod(handle),
	m_filepath(handle.m_filepath)
{
}
void crSetGamelogPathMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_serverName = *(std::string*)lparam;
		}
		break;
	}
}
void crSetGamelogPathMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_filepath = str;
		break;
	}
}
void crSetGamelogPathMethod::operator()(crHandle &handle)
{
	crNetConductor *dbserver = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbserver)
	{
		crSetGamelogPathPacket packet;
		crSetGamelogPathPacket::buildRequestPacket(packet,m_filepath+m_serverName);
		dbserver->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crGameTaskUpdateMethod
//
/////////////////////////////////////////
crGameTaskUpdateMethod::crGameTaskUpdateMethod():
	m_dt(NULL)
{
}
crGameTaskUpdateMethod::crGameTaskUpdateMethod(const crGameTaskUpdateMethod& handle):
	crMethod(handle),
	m_dt(NULL)
{
}
void crGameTaskUpdateMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crGameTaskUpdateMethod::addParam(int i, const std::string& str)
{
}
void crGameTaskUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && myPlayer->getMainRole())
	{
		crData *data = myPlayer->getMainRole()->getMetierDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_GameTaskMap,param);
		GameTaskMap *gameTaskMap = (GameTaskMap *)param;
		if(gameTaskMap)
		{
			for (GameTaskMap::iterator itr = gameTaskMap->begin(); itr != gameTaskMap->end(); ++itr)
			{
				if (itr->second!=NULL && itr->second->getActivation() && !itr->second->isComplete())
				{
					itr->second->doEvent(WCH_UPDATE,MAKEINT64((int)(m_dt),NULL));
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crShellExecuteMethod
//
/////////////////////////////////////////
crShellExecuteMethod::crShellExecuteMethod():
	m_show(SW_SHOW)
{
}
crShellExecuteMethod::crShellExecuteMethod(const crShellExecuteMethod& handle):
	crMethod(handle),
	m_url(handle.m_url),
	m_show(handle.m_show)
{
}
void crShellExecuteMethod::inputParam(int i, void *param)
{
}
void crShellExecuteMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_url = str;
		break;
	case 1:
		m_show = atoi(str.c_str());
		break;
	}
}
void crShellExecuteMethod::operator()(crHandle &handle)
{
	if(m_url == "Login.exe" && !CRIOManager::fileExists(m_url))
	{
		m_url = "登录器.exe";
	}
	ShellExecute(NULL,"open",m_url.c_str(),NULL,NULL,m_show);
}
/////////////////////////////////////////
//
//crClipCursorMethod
//
/////////////////////////////////////////
crClipCursorMethod::crClipCursorMethod():
	m_lock(true)
{
}
crClipCursorMethod::crClipCursorMethod(const crClipCursorMethod& handle):
	crMethod(handle),
	m_lock(handle.m_lock)
{
}
void crClipCursorMethod::inputParam(int i, void *param)
{
}
void crClipCursorMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_lock = (bool)(atoi(str.c_str()));
		break;
	}
}
void crClipCursorMethod::operator()(crHandle &handle)
{
	HWND rndwnd = crStartHandler::getInstance()->getWindowHandle();
	if(m_lock && ::GetForegroundWindow()==rndwnd)
	{
		RECT rect;
		GetWindowRect(rndwnd, &rect);
		if(!crDisplaySettings::instance()->getFullScreen() && crDisplaySettings::instance()->getRunMode() != crDisplaySettings::WebGame)
		{
			int h = GetSystemMetrics(SM_CYCAPTION);//SM_CYSIZE
			int xFrame = GetSystemMetrics(SM_CXFRAME);
			int yFrame = GetSystemMetrics(SM_CYFRAME);
#if(_MSC_VER <= 1600)
			xFrame *= 0.5f;
			yFrame *= 0.5f;
#endif
#if(_WIN32_WINNT >= 0x0600)
			yFrame += GetSystemMetrics(SM_CXPADDEDBORDER);
			xFrame += GetSystemMetrics(SM_CXPADDEDBORDER);
#endif
			rect.top += h + yFrame;
			rect.bottom -= yFrame;
			rect.left += xFrame;
			rect.right -= xFrame;
#if(_MSC_VER <= 1600)
			//rect.top -= 1.0f;
			//rect.bottom += 1.0f;
			//rect.left -= 1.0f;
			//rect.right += 1.0f;
			rect.top += 1.0f;
			//rect.bottom -= 1.0f;
			rect.left += 1.0f;
			//rect.right -= 1.0f;
#endif
		}
		ClipCursor(&rect);
	}
	else
	{
		ClipCursor(NULL);
	}
}
/////////////////////////////////////////
//
//crIsStartupLoadingMethod
//
/////////////////////////////////////////
crIsStartupLoadingMethod::crIsStartupLoadingMethod(){}
crIsStartupLoadingMethod::crIsStartupLoadingMethod(const crIsStartupLoadingMethod& handle):
	crMethod(handle)
{
}
void crIsStartupLoadingMethod::inputParam(int i, void *param)
{
}
void crIsStartupLoadingMethod::addParam(int i, const std::string& str)
{
}
void crIsStartupLoadingMethod::operator()(crHandle &handle)
{
	bool instartup = crGlobalHandle::getInstance()->curStartupLoadingProgress()<1.0f;
	handle.outputParam(0,&instartup);
}
/////////////////////////////////////////
//
//crStartupLoadingInitMethod
//
/////////////////////////////////////////
crStartupLoadingInitMethod::crStartupLoadingInitMethod()
{
}
crStartupLoadingInitMethod::crStartupLoadingInitMethod(const crStartupLoadingInitMethod& handle):
	crMethod(handle),
	m_progressTextWidget(handle.m_progressTextWidget),
	m_progressWidget(handle.m_progressWidget)
{
}
void crStartupLoadingInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crStartupLoadingInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progressTextWidget = str;
		break;
	case 1:
		m_progressWidget = str;
		break;
	}
}
void crStartupLoadingInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crStaticTextWidgetNode>progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_progressTextWidget));
	if(progressTextWidget.valid()) progressTextWidget->clearString();
	ref_ptr<crProgressWidgetNode> progress = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progressWidget));
	if(progress.valid())progress->setProgress(0);
}
/////////////////////////////////////////
//
//crStartupLoadingProgressMethod
//
/////////////////////////////////////////
crStartupLoadingProgressMethod::crStartupLoadingProgressMethod():
	m_dt(0.0f),
	m_speed(1.0f)
{
}
crStartupLoadingProgressMethod::crStartupLoadingProgressMethod(const crStartupLoadingProgressMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt),
	m_canvasName(handle.m_canvasName),
	m_progressTextWidget(handle.m_progressTextWidget),
	m_progressWidget(handle.m_progressWidget),
	m_speed(handle.m_speed)
{
}
void crStartupLoadingProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *(float *)(LOINT64(param64));
		}
		break;
	}
}
void crStartupLoadingProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_progressTextWidget = str;
		break;
	case 2:
		m_progressWidget = str;
		break;
	case 3:
		m_speed = atof(str.c_str());
		break;
	}
}
void crStartupLoadingProgressMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvas.valid() && canvas->getVisiable())
	{
		ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
		ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
		if(progressTextWidget.valid())
		{
			progressTextWidget->setString(L"正在加载资源...");
		}
		float progress = crGlobalHandle::getInstance()->getStartupLoadingProgress();
		float& curProgress = crGlobalHandle::getInstance()->curStartupLoadingProgress();
		if(curProgress<progress)
		{
			curProgress += m_dt * m_speed;
			if(curProgress>progress)
				curProgress = progress;
			progressWidget->setProgress(curProgress);
		}
	}
}
/////////////////////////////////////////
//
//crSetFpsControlMethod
//
/////////////////////////////////////////
crSetFpsControlMethod::crSetFpsControlMethod():
	m_fps(-1)
{
}
crSetFpsControlMethod::crSetFpsControlMethod(const crSetFpsControlMethod& handle):
	crMethod(handle),
	m_fps(handle.m_fps)
{
}
void crSetFpsControlMethod::inputParam(int i, void *param)
{
}
void crSetFpsControlMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_fps = atoi(str.c_str());
		break;
	}
}
void crSetFpsControlMethod::operator()(crHandle &handle)
{
	if(m_fps == -1)
	{
		CRCore::crDisplaySettings::instance()->restoreFpsControl();
	}
	else
	{
		CRCore::crDisplaySettings::instance()->setFpsControl(m_fps);
	}
}
/////////////////////////////////////////
//
//crStartupSceneDownloadMethod
//
/////////////////////////////////////////
crStartupSceneDownloadMethod::crStartupSceneDownloadMethod():
m_step(0){}
crStartupSceneDownloadMethod::crStartupSceneDownloadMethod(const crStartupSceneDownloadMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_frontname(handle.m_frontname)
{
}
void crStartupSceneDownloadMethod::inputParam(int i, void *param)
{
}

void crStartupSceneDownloadMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		m_frontname = str;
		break;
	}
}
void crStartupSceneDownloadMethod::operator()(crHandle &handle)
{
	bool needDownload = false;
	int downloadCount = 0;
	std::string filename;

	ref_ptr<crTableIO>scenetable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
	crData *data = crRunGameHandle::getInstance()->getDataClass();
	void *param;
	data->getParam(WCHDATA_SceneID,param);
	short sceneid = *(short *)param;
	crDownloadManager::getInstance()->setCompleteCount(0);
	crTableIO::StrVec record;
	if(scenetable.valid() && scenetable->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
	{
		std::string sceneFile = record[2];
		std::string uifile = crGlobalHandle::getInstance()->getUISceneDir()+record[3];
		ref_ptr<crTableIO> table;
		int rowcount;
		std::string str = crArgumentParser::getFileNameEliminateExt(sceneFile) + ".crb";
		if(m_step == 0)
		{
			filename = str;
			CRIOManager::GetCookedFileName(filename);
			if(!CRIOManager::fileExists(filename))
			{
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
				downloadCount++;
			}
		}
		else
		{
			table = crTableIO::openFile(str);
			if(table.valid())
			{
				rowcount = table->getRowCount();
				for (int i = 0; i < rowcount; i++)
				{
					filename = (*table)(i,0);
					CRIOManager::GetCookedFileName(filename);
					if(!CRIOManager::fileExists(filename))
					{
						crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
						downloadCount++;
					}
				}
			}
			filename = sceneFile;
			CRIOManager::GetCookedFileName(filename);
			if(!CRIOManager::fileExists(filename))
			{
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
				downloadCount++;
			}
			if(!m_frontname.empty())
			{
				std::string foundFile = CRText::findFontFile(m_frontname);
				if(foundFile.empty())
				{
					ref_ptr<crDownload> download = new crDownload("media/fonts/"+m_frontname);
					crDownloadManager::getInstance()->addImmediatelyDownloadRequest(download.get());
					downloadCount++;
				}
			}
		}
		str = crArgumentParser::getFileNameEliminateExt(uifile) + ".crb";
		if(m_step == 0)
		{
			filename = str;
			CRIOManager::GetCookedFileName(filename);
			if(!CRIOManager::fileExists(filename))
			{
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
				downloadCount++;
			}
		}
		else
		{
			table = crTableIO::openFile(str);
			if(table.valid())
			{
				rowcount = table->getRowCount();
				for (int i = 0; i < rowcount; i++)
				{
					filename = (*table)(i,0);
					CRIOManager::GetCookedFileName(filename);
					if(!CRIOManager::fileExists(filename))
					{
						crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
						downloadCount++;
					}
				}
			}
			filename = uifile;
			CRIOManager::GetCookedFileName(filename);
			if(!CRIOManager::fileExists(filename))
			{
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(filename));
				downloadCount++;
			}
		}
	}
	CRCore::notify(CRCore::ALWAYS)<<"StartupSceneDownload "<<m_step<<std::endl;
	needDownload = downloadCount>0;
	crDownloadManager::getInstance()->setTaskCount(downloadCount);
	handle.outputParam(0,&needDownload);
}
/////////////////////////////////////////
//
//crIsStartupSceneDownloadingMethod
//
/////////////////////////////////////////
crIsStartupSceneDownloadingMethod::crIsStartupSceneDownloadingMethod():
m_step(0){}
crIsStartupSceneDownloadingMethod::crIsStartupSceneDownloadingMethod(const crIsStartupSceneDownloadingMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crIsStartupSceneDownloadingMethod::inputParam(int i, void *param)
{
}

void crIsStartupSceneDownloadingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	}
}
void crIsStartupSceneDownloadingMethod::operator()(crHandle &handle)
{
	bool downloading = true;
	float progress = crDownloadManager::getInstance()->getProgress();
	if(crDownloadManager::getInstance()->isComplete())
	{
		downloading = false;
		crDownloadManager::getInstance()->lockDownloadMap();
		crDownloadManager::DownloadMap &downloadMap = crDownloadManager::getInstance()->getDownloadMap();
		for( crDownloadManager::DownloadMap::iterator itr = downloadMap.begin();
			itr != downloadMap.end(); )
		{
			if(itr->second->getDownloadState() == crDownload::Done)
			{
				itr->second->moveFileToDirectory();
				crRunGameHandle::getInstance()->addStartupDownloadFile(itr->first);
			}
			itr = downloadMap.erase(itr);
		}
		crDownloadManager::getInstance()->unlockDownloadMap();
	}
	crThread::yieldCurrentThread();
	if(m_step==1)
	{
		crRunGameHandle::getInstance()->setLoadingProgress(progress*0.5f);
	}
	handle.outputParam(0,&downloading);
}
/////////////////////////////////////////
//
//crBeginRunGameMethod
//
/////////////////////////////////////////
crBeginRunGameMethod::crBeginRunGameMethod(){}
crBeginRunGameMethod::crBeginRunGameMethod(const crBeginRunGameMethod& handle):
	crMethod(handle)
{
}
void crBeginRunGameMethod::inputParam(int i, void *param)
{
}

void crBeginRunGameMethod::addParam(int i, const std::string& str)
{
}
void crBeginRunGameMethod::operator()(crHandle &handle)
{
	crRunGameHandle::getInstance()->setRunning(true);
	crRunGameHandle::getInstance()->setRunCode(0);
	crRunGameHandle::getInstance()->doEvent(WCH_RunGame);
}
///////////////////////////////////////////
////
////crRechargeDisposeMethod
////
///////////////////////////////////////////
//crRechargeDisposeMethod::crRechargeDisposeMethod():
//m_count(50){}
//crRechargeDisposeMethod::crRechargeDisposeMethod(const crRechargeDisposeMethod& handle):
//	crMethod(handle),
//	m_count(handle.m_count)
//{
//}
//void crRechargeDisposeMethod::inputParam(int i, void *param)
//{
//}
//void crRechargeDisposeMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_count = atoi(str.c_str());
//		break;
//	}
//}
//void crRechargeDisposeMethod::operator()(crHandle &handle)
//{//提取充值变成元宝
//	const float c_moneyScale = 10.0f;
//	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//	crNetManager *netManager = gameServer->getNetManager();
//	crNetDataManager *netDataManager = gameServer->getNetDataManager();
//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
//	int serverid = callback->getServerID();
//	crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
//	ref_ptr<crDataBase> globalSession = db->beginSession();
//	ref_ptr<crRechargerecordQueryData> rechargerecordQuery = new crRechargerecordQueryData;
//	rechargerecordQuery->buildQuerySql(serverid,m_count);
//	globalSession->executeQuery(rechargerecordQuery.get());
//	crDataBase::QueryResultVec rechargerecordQueryResultVec = globalSession->getQueryResult();
//	globalSession->releaseQuery();
//	if(!rechargerecordQueryResultVec.empty())
//	{
//		bool success = false;
//		ref_ptr<crGameServerPlayerData> playerData;
//		crPlayerDataEventPacket packet;
//		ref_ptr<crStreamBuf>stream;
//		ref_ptr<crPlayerMoneyQueryData> playerMoneyQuery = new crPlayerMoneyQueryData;
//		ref_ptr<crUpdatePlayerMoney> updatePlayerMoney = new crUpdatePlayerMoney;
//		ref_ptr<crInsertPlayerMoney> insertPlayerMoney = new crInsertPlayerMoney;
//		//ref_ptr<crUpdateRechargerecord> updateRechargerecord = new crUpdateRechargerecord;
//		ref_ptr<crRemoveRechargerecord> removeRechargerecord = new crRemoveRechargerecord;
//		ref_ptr<crInsertMoneyrecord> insertMoneyrecord = new crInsertMoneyrecord;
//		for( crDataBase::QueryResultVec::iterator itr = rechargerecordQueryResultVec.begin();
//			itr != rechargerecordQueryResultVec.end();
//			++itr )
//		{
//			success = false;
//			rechargerecordQuery = dynamic_cast<crRechargerecordQueryData *>(itr->get());
//			int money = rechargerecordQuery->getMoney() * c_moneyScale;
//			int playerid = rechargerecordQuery->getPlayerID();
//			int id = rechargerecordQuery->getID();
//			insertMoneyrecord->buildUpdateSql(playerid,serverid,money,"充值");
//			playerMoneyQuery->buildQuerySql(playerid,serverid);
//			globalSession->executeQuery(playerMoneyQuery.get());
//			int dbmoney = 0;
//			crDataBase::QueryResultVec &playerMoneyQueryResultVec = globalSession->getQueryResult();
//			if(!playerMoneyQueryResultVec.empty())
//			{
//				playerMoneyQuery = dynamic_cast<crPlayerMoneyQueryData *>(playerMoneyQueryResultVec[0].get());
//				dbmoney = playerMoneyQuery->getMoney();
//				globalSession->releaseQuery();
//				updatePlayerMoney->buildUpdateSql(playerid,serverid,money);
//				removeRechargerecord->buildUpdateSql(id);
//				if(globalSession->executeUpdate(updatePlayerMoney.get()) && globalSession->executeUpdate(insertMoneyrecord.get()) && globalSession->executeUpdate(removeRechargerecord.get()))
//				{//插入成功
//					globalSession->commit();
//					success = true;
//				}
//				else
//				{
//					globalSession->rollback();
//				}
//			}
//			else
//			{
//				globalSession->releaseQuery();
//				insertPlayerMoney->buildUpdateSql(playerid,serverid,money);
//				removeRechargerecord->buildUpdateSql(id);
//				if(globalSession->executeUpdate(insertPlayerMoney.get()) && globalSession->executeUpdate(insertMoneyrecord.get()) && globalSession->executeUpdate(removeRechargerecord.get()))
//				{//插入成功
//					globalSession->commit();
//					success = true;
//				}
//				else
//				{
//					globalSession->rollback();
//				}
//			}
//			if(success)
//			{//充值成功
//				//playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
//				//if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
//				//{//玩家在线
//				//	data = playerData->getPlayerGameData()->getDataClass();
//				//	data->excHandle(MAKEINT64(WCH_LockData,1));
//				//	data->getParam(WCHDATA_Money,param);
//				//	int *curmoney = (int *)param;
//				//	*curmoney = dbmoney+money;
//				//	stream = new crStreamBuf;
//				//	stream->createBuf(4);
//				//	stream->_writeInt(*curmoney);
//				//	crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvMoneyChange,stream.get());
//				//	netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				//	data->excHandle(MAKEINT64(WCH_LockData,0));
//				//}
//			}
//		}
//	}
//	db->endSession(globalSession.get());
//}
/////////////////////////////////////////
//
//crMoneyChangeMethod
//
/////////////////////////////////////////
crMoneyChangeMethod::crMoneyChangeMethod():
m_this(NULL),
m_output(NULL)
{
	m_moneydata = MoneyChangeData(0,"");
}
crMoneyChangeMethod::crMoneyChangeMethod(const crMoneyChangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
	m_moneydata = MoneyChangeData(0,"");
}
void crMoneyChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_moneydata = *(MoneyChangeData *)(LOINT64(param64));
			m_output = (bool *)HIINT64(param64);
		}
		else
		{
			m_moneydata = MoneyChangeData(0,"");
			m_output = NULL;
		}
		break;
	}
}
void crMoneyChangeMethod::addParam(int i, const std::string& str)
{
}
void crMoneyChangeMethod::operator()(crHandle &handle)
{
	if(m_moneydata.first != 0 && m_output)
	{
		*m_output = false;
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_Money,param);
		int *money = (int *)param;
		if(*money+m_moneydata.first>=0)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
			int serverid = callback->getServerID();
			ref_ptr<crInsertMoneyrecord> insertMoneyrecord = new crInsertMoneyrecord;
			insertMoneyrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_moneydata.first,*money,m_moneydata.second);

			crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
			ref_ptr<crDataBase> globalSession = db->beginSession();
			ref_ptr<crPlayerMoneyQueryData> playerMoneyQuery = new crPlayerMoneyQueryData;
			playerMoneyQuery->buildQuerySql(m_this->getPlayerID(),serverid);
			globalSession->executeQuery(playerMoneyQuery.get());
			int dbmoney = 0;
			crDataBase::QueryResultVec &playerMoneyQueryResultVec = globalSession->getQueryResult();
			if(!playerMoneyQueryResultVec.empty())
			{
				playerMoneyQuery = dynamic_cast<crPlayerMoneyQueryData *>(playerMoneyQueryResultVec[0].get());
				dbmoney = playerMoneyQuery->getMoney();
				globalSession->releaseQuery();
				ref_ptr<crUpdatePlayerMoney> updatePlayerMoney = new crUpdatePlayerMoney;
				updatePlayerMoney->buildUpdateSql(m_this->getPlayerID(),serverid,m_moneydata.first);
				if(globalSession->executeUpdate(updatePlayerMoney.get()) && globalSession->executeUpdate(insertMoneyrecord.get()))
				{//插入成功
					globalSession->commit();
					*m_output = true;
				}
				else
				{
					globalSession->rollback();
				}
			}
			else
			{
				globalSession->releaseQuery();
				ref_ptr<crInsertPlayerMoney> insertPlayerMoney = new crInsertPlayerMoney;
				insertPlayerMoney->buildUpdateSql(m_this->getPlayerID(),serverid,m_moneydata.first);
				if(globalSession->executeUpdate(insertPlayerMoney.get()) && globalSession->executeUpdate(insertMoneyrecord.get()))
				{//插入成功
					globalSession->commit();
					*m_output = true;
				}
				else
				{
					globalSession->rollback();
				}
			}
			db->endSession(globalSession.get());
			if(*m_output)
			{
				*money = dbmoney + m_moneydata.first;
				//放在外部逻辑做了
				//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				//crNetManager *netManager = gameServer->getNetManager();
				//crNetDataManager *netDataManager = gameServer->getNetDataManager();
				//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(m_this->getPlayerID()));
				//if(playerData.valid())
				//{//玩家在线
				//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//	stream->createBuf(4);
				//	stream->_writeInt(*money);
				//	crPlayerDataEventPacket packet;
				//	crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvMoneyChange,stream.get());
				//	netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crIsWebLoginMethod
//
/////////////////////////////////////////
crIsWebLoginMethod::crIsWebLoginMethod(){}
crIsWebLoginMethod::crIsWebLoginMethod(const crIsWebLoginMethod& handle):
	crMethod(handle)
{
}
void crIsWebLoginMethod::inputParam(int i, void *param)
{
}

void crIsWebLoginMethod::addParam(int i, const std::string& str)
{
}
void crIsWebLoginMethod::operator()(crHandle &handle)
{
	bool weblogin = false;
	char *webloginStr = getenv("WebLogin");
	if(webloginStr && strlen(webloginStr)>0)
	{
		weblogin = true;
	}
	handle.outputParam(0,&weblogin);
}
/////////////////////////////////////////
//
//crDoWebLoginMethod
//
/////////////////////////////////////////
crDoWebLoginMethod::crDoWebLoginMethod(){}
crDoWebLoginMethod::crDoWebLoginMethod(const crDoWebLoginMethod& handle):
	crMethod(handle)
{
}
void crDoWebLoginMethod::inputParam(int i, void *param)
{
}

void crDoWebLoginMethod::addParam(int i, const std::string& str)
{
}
void crDoWebLoginMethod::operator()(crHandle &handle)
{
	char *webloginStr = getenv("WebLogin");
	if(webloginStr)
	{
		std::string str = webloginStr;
		std::string key;
		std::string::size_type comma = str.find_first_of('|');
		key = std::string(str.begin(),str.begin()+comma);
		str = std::string(str.begin()+comma + 1,str.end());
		crVector3i vec3;
		if(crArgumentParser::appAtoVec(str,vec3))
		{
			crMyPlayerData *myPlayerData = crMyPlayerData::getInstance();
			myPlayerData->setKey(key);
			myPlayerData->setPlayerID(vec3[0]);
			myPlayerData->setLastServerID(vec3[1]);
			myPlayerData->setISP(vec3[2]);
			crGlobalHandle::getInstance()->doEvent(WCH_LoginReturn,MAKEINT64(1,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crSetVolumeEnableMethod
//
/////////////////////////////////////////
crSetVolumeEnableMethod::crSetVolumeEnableMethod():
	m_enable(false){}
crSetVolumeEnableMethod::crSetVolumeEnableMethod(const crSetVolumeEnableMethod& handle):
	crMethod(handle),
	m_name(handle.m_name),
	m_enable(false)
{
}
void crSetVolumeEnableMethod::inputParam(int i, void *param)
{
}
void crSetVolumeEnableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_name = str;
		break;
	case 1:
		m_enable = (bool)(atoi(str.c_str()));
		break;
	}
}
void crSetVolumeEnableMethod::operator()(crHandle &handle)
{
	crVolumeNode *volumeNode = crVolumeNodeManager::getInstance()->getVolumeNode(m_name);
	if(volumeNode)
	{
		volumeNode->setEnable(m_enable);
	}
}
/////////////////////////////////////////
//
//crIsAlphaShadowDisabledMethod
//
/////////////////////////////////////////
crIsAlphaShadowDisabledMethod::crIsAlphaShadowDisabledMethod(){}
crIsAlphaShadowDisabledMethod::crIsAlphaShadowDisabledMethod(const crIsAlphaShadowDisabledMethod& handle):
	crMethod(handle)
{
}
void crIsAlphaShadowDisabledMethod::inputParam(int i, void *param)
{
}
void crIsAlphaShadowDisabledMethod::addParam(int i, const std::string& str)
{
}
void crIsAlphaShadowDisabledMethod::operator()(crHandle &handle)
{
	bool disabled = !crDisplaySettings::instance()->getEnableAlphaShadow();
	handle.outputParam(0,&disabled);
}
/////////////////////////////////////////
//
//crStopAllSceneFxMethod
//
/////////////////////////////////////////
crStopAllSceneFxMethod::crStopAllSceneFxMethod(){}
crStopAllSceneFxMethod::crStopAllSceneFxMethod(const crStopAllSceneFxMethod& handle):
	crMethod(handle)
{
}
void crStopAllSceneFxMethod::addParam(int i, const std::string& str)
{
}
void crStopAllSceneFxMethod::inputParam(int i, void *param)
{
}
class StopFXVisitor : public CRCore::crNodeVisitor
{
public:
	StopFXVisitor():crNodeVisitor(NODE_VISITOR,TRAVERSE_ALL_CHILDREN){}
	virtual ~StopFXVisitor(){}

	virtual void apply(CRPhysics::crBulletMatterObject& node){ return; }
	virtual void apply(CRPhysics::crWeaponMatterObject& node){ return; }
	virtual void apply(CRPhysics::crViewMatterObject& node){ return; }
	virtual void apply(CRParticle::crParticleEffect& node){ node.stopEffect(); }
};
void crStopAllSceneFxMethod::operator()(crHandle &handle)
{
	//crGroup *root = crSceneManager::getInstance()->getStaticRoot();
	//if(root)
	//{
		StopFXVisitor visitor;
		crBrain::getInstance()->accept(visitor);
	//}
}
/////////////////////////////////////////
//
//crGainBirthPointMethod
//
/////////////////////////////////////////
crGainBirthPointMethod::crGainBirthPointMethod():
m_this(NULL),
m_role(NULL),
m_index(0){}
crGainBirthPointMethod::crGainBirthPointMethod(const crGainBirthPointMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_role(NULL),
	m_index(0)
{
}
void crGainBirthPointMethod::addParam(int i, const std::string& str)
{
}
void crGainBirthPointMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_role = (crRole *)(LOINT64(param64));
			m_index = HIINT64(param64);
		}
		else
		{
			m_role = NULL;
			m_index = 0;
		}
		break;
	}
}
void crGainBirthPointMethod::operator()(crHandle &handle)
{
	crScene *scene = m_this->getScene();
	if(scene && m_role)
	{
		scene->gainBirthPoint(m_role,m_index);
	}
}
/////////////////////////////////////////
//
//crLockKeyboardMouseMethod
//
/////////////////////////////////////////
crLockKeyboardMouseMethod::crLockKeyboardMouseMethod():
m_lock(false){}
crLockKeyboardMouseMethod::crLockKeyboardMouseMethod(const crLockKeyboardMouseMethod& handle):
	crMethod(handle),
	m_lock(handle.m_lock)
{
}
void crLockKeyboardMouseMethod::inputParam(int i, void *param)
{
}

void crLockKeyboardMouseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_lock = (bool)(atoi(str.c_str()));
		break;
	}
}

void crLockKeyboardMouseMethod::operator()(crHandle &handle)
{
 	if(m_lock)
		crKeyboardMouseHandle::getInstance()->lockInput();
	else
		crKeyboardMouseHandle::getInstance()->unlockInput();
}
/////////////////////////////////////////
//
//crSetLightValidDistanceMethod
//
/////////////////////////////////////////
crSetLightValidDistanceMethod::crSetLightValidDistanceMethod():
	m_dist(100.0f){}
crSetLightValidDistanceMethod::crSetLightValidDistanceMethod(const crSetLightValidDistanceMethod& handle):
	crMethod(handle),
	m_dist(handle.m_dist)
{
}
void crSetLightValidDistanceMethod::inputParam(int i, void *param)
{
}

void crSetLightValidDistanceMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dist = atof(str.c_str());
		break;
	}
}

void crSetLightValidDistanceMethod::operator()(crHandle &handle)
{
	crLightSourceManager::getInstance()->setLightValidDistance(m_dist);
}
/////////////////////////////////////////
//
//crShowEnginStatsMethod
//
/////////////////////////////////////////
crShowEnginStatsMethod::crShowEnginStatsMethod():
m_init(false)
{
	m_pos.set(50,180);
}
crShowEnginStatsMethod::crShowEnginStatsMethod(const crShowEnginStatsMethod& handle):
	crMethod(handle),
	m_init(false),
	m_pos(handle.m_pos)
{
}
void crShowEnginStatsMethod::inputParam(int i, void *param)
{
}

void crShowEnginStatsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_pos);
		break;
	}
}
void crShowEnginStatsMethod::init()
{
	m_init = true;
	float leftPos = m_pos[0];
	float characterSize = 15.0f;
	float screenHeight = crDisplaySettings::instance()->getViewHeight();

	CRCore::crVector3 pos(leftPos,screenHeight - m_pos[1],0.0f);

	CRCore::crVector4 rcolor(1.0f,0.0f,0.0f,1.0f);
	CRCore::crVector4 gcolor(0.0f,1.0f,0.0f,1.0f);
	CRCore::crVector4 bcolor(0.0f,0.0f,1.0f,1.0f);
	CRCore::crVector4 ycolor(1.0f,1.0f,0.0f,1.0f);
	//////////////////////////
	//FPS
	/////////////////////////
	m_fps = new CRText::crText;
	m_fps->setName("FPS");
	m_fps->setFont("arial.ttf");
	m_fps->setColor(rcolor);
	m_fps->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_fps->setCharacterSize(characterSize);
	m_fps->setPosition(pos);
	m_fps->setAlignment(CRText::crText::BASE_LINE);
	m_fps->setText("FPS: ");
	m_fps->setVisiable(false);
	//m_fps->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_fps.get(),true);

	//////////////////////////
	//m_fpsTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_fpsTime = new CRText::crText;
	m_fpsTime->setName("FrameTime");
	m_fpsTime->setFont("arial.ttf");
	m_fpsTime->setColor(rcolor);
	m_fpsTime->setFontResolution((unsigned int)characterSize, (unsigned int)characterSize);
	m_fpsTime->setCharacterSize(characterSize);
	m_fpsTime->setPosition(pos);
	m_fpsTime->setAlignment(CRText::crText::BASE_LINE);
	m_fpsTime->setText("FrameTime: ");
	m_fpsTime->setVisiable(false);
	//m_fpsTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_fpsTime.get(), true);

	//////////////////////////
	//m_drawTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_drawTime = new CRText::crText;
	m_drawTime->setName("DrawTime");
	m_drawTime->setFont("arial.ttf");
	m_drawTime->setColor(rcolor);
	m_drawTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_drawTime->setCharacterSize(characterSize);
	m_drawTime->setPosition(pos);
	m_drawTime->setAlignment(CRText::crText::BASE_LINE);
	m_drawTime->setText("DrawTime: ");
	m_drawTime->setVisiable(false);
	//m_drawTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_drawTime.get(),true);

	//////////////////////////
	//m_updTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_updTime = new CRText::crText;
	m_updTime->setName("UpdTime");
	m_updTime->setFont("arial.ttf");
	m_updTime->setColor(gcolor);
	m_updTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_updTime->setCharacterSize(characterSize);
	m_updTime->setPosition(pos);
	m_updTime->setAlignment(CRText::crText::BASE_LINE);
	m_updTime->setText("UpdTime: ");
	m_updTime->setVisiable(false);
	//m_updTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_updTime.get(),true);

	//////////////////////////
	//m_cullTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_cullTime = new CRText::crText;
	m_cullTime->setName("CullTime");
	m_cullTime->setFont("arial.ttf");
	m_cullTime->setColor(bcolor);
	m_cullTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_cullTime->setCharacterSize(characterSize);
	m_cullTime->setPosition(pos);
	m_cullTime->setAlignment(CRText::crText::BASE_LINE);
	m_cullTime->setText("CullTime: ");
	m_cullTime->setVisiable(false);
	//m_cullTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_cullTime.get(),true);

	//////////////////////////
	//m_phyUpdTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_phyUpdTime = new CRText::crText;
	m_phyUpdTime->setName("PhyTime");
	m_phyUpdTime->setFont("arial.ttf");
	m_phyUpdTime->setColor(bcolor);
	m_phyUpdTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_phyUpdTime->setCharacterSize(characterSize);
	m_phyUpdTime->setPosition(pos);
	m_phyUpdTime->setAlignment(CRText::crText::BASE_LINE);
	m_phyUpdTime->setText("PhyTime: ");
	m_phyUpdTime->setVisiable(false);
	//m_phyUpdTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_phyUpdTime.get(),true);

	//////////////////////////
	//m_characterUpdTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_characterUpdTime = new CRText::crText;
	m_characterUpdTime->setName("CharacterTime");
	m_characterUpdTime->setFont("arial.ttf");
	m_characterUpdTime->setColor(bcolor);
	m_characterUpdTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_characterUpdTime->setCharacterSize(characterSize);
	m_characterUpdTime->setPosition(pos);
	m_characterUpdTime->setAlignment(CRText::crText::BASE_LINE);
	m_characterUpdTime->setText("CharacterTime: ");
	m_characterUpdTime->setVisiable(false);
	//m_characterUpdTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_characterUpdTime.get(),true);

	//////////////////////////
	//m_particleUpdTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_particleUpdTime = new CRText::crText;
	m_particleUpdTime->setName("ParticleTime");
	m_particleUpdTime->setFont("arial.ttf");
	m_particleUpdTime->setColor(bcolor);
	m_particleUpdTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_particleUpdTime->setCharacterSize(characterSize);
	m_particleUpdTime->setPosition(pos);
	m_particleUpdTime->setAlignment(CRText::crText::BASE_LINE);
	m_particleUpdTime->setText("ParticleTime: ");
	m_particleUpdTime->setVisiable(false);
	//m_particleUpdTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_particleUpdTime.get(),true);

	//////////////////////////
	//m_keyboardMouseTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_keyboardMouseTime = new CRText::crText;
	m_keyboardMouseTime->setName("KeyboardMouseTime");
	m_keyboardMouseTime->setFont("arial.ttf");
	m_keyboardMouseTime->setColor(gcolor);
	m_keyboardMouseTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_keyboardMouseTime->setCharacterSize(characterSize);
	m_keyboardMouseTime->setPosition(pos);
	m_keyboardMouseTime->setAlignment(CRText::crText::BASE_LINE);
	m_keyboardMouseTime->setText("KeyboardMouseTime: ");
	m_keyboardMouseTime->setVisiable(false);
	//m_keyboardMouseTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_keyboardMouseTime.get(),true);

	//////////////////////////
	//m_swapTime
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_swapTime = new CRText::crText;
	m_swapTime->setName("SwapTime");
	m_swapTime->setFont("arial.ttf");
	m_swapTime->setColor(ycolor);
	m_swapTime->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_swapTime->setCharacterSize(characterSize);
	m_swapTime->setPosition(pos);
	m_swapTime->setAlignment(CRText::crText::BASE_LINE);
	m_swapTime->setText("SwapTime: ");
	m_swapTime->setVisiable(false);
	//m_swapTime->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_swapTime.get(),true);

	//////////////////////////
	//m_numStates
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_numStates = new CRText::crText;
	m_numStates->setName("NumStates");
	m_numStates->setFont("arial.ttf");
	m_numStates->setColor(rcolor);
	m_numStates->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_numStates->setCharacterSize(characterSize);
	m_numStates->setPosition(pos);
	m_numStates->setAlignment(CRText::crText::BASE_LINE);
	m_numStates->setText("NumStates: ");
	m_numStates->setVisiable(false);
	//m_numStates->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_numStates.get(),true);

	//////////////////////////
	//m_numDrawables
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_numDrawables = new CRText::crText;
	m_numDrawables->setName("NumDrawable");
	m_numDrawables->setFont("arial.ttf");
	m_numDrawables->setColor(rcolor);
	m_numDrawables->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_numDrawables->setCharacterSize(characterSize);
	m_numDrawables->setPosition(pos);
	m_numDrawables->setAlignment(CRText::crText::BASE_LINE);
	m_numDrawables->setText("NumDrawable: ");
	m_numDrawables->setVisiable(false);
	//m_numDrawables->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_numDrawables.get(),true);

	//////////////////////////
	//m_primCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_primCount = new CRText::crText;
	m_primCount->setName("PrimCount");
	m_primCount->setFont("arial.ttf");
	m_primCount->setColor(rcolor);
	m_primCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_primCount->setCharacterSize(characterSize);
	m_primCount->setPosition(pos);
	m_primCount->setAlignment(CRText::crText::BASE_LINE);
	m_primCount->setText("PrimCount: ");
	m_primCount->setVisiable(false);
	//m_primCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_primCount.get(),true);

	//////////////////////////
	//m_vtxCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_vtxCount = new CRText::crText;
	m_vtxCount->setName("VtxCount");
	m_vtxCount->setFont("arial.ttf");
	m_vtxCount->setColor(rcolor);
	m_vtxCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_vtxCount->setCharacterSize(characterSize);
	m_vtxCount->setPosition(pos);
	m_vtxCount->setAlignment(CRText::crText::BASE_LINE);
	m_vtxCount->setText("VtxCount: ");
	m_vtxCount->setVisiable(false);
	//m_vtxCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_vtxCount.get(),true);

	//////////////////////////
	//m_particleCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_particleCount = new CRText::crText;
	m_particleCount->setName("ParticleCount");
	m_particleCount->setFont("arial.ttf");
	m_particleCount->setColor(rcolor);
	m_particleCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_particleCount->setCharacterSize(characterSize);
	m_particleCount->setPosition(pos);
	m_particleCount->setAlignment(CRText::crText::BASE_LINE);
	m_particleCount->setText("ParticleCount: ");
	m_particleCount->setVisiable(false);
	//m_particleCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_particleCount.get(),true);

	//////////////////////////
	//m_lightCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_lightCount = new CRText::crText;
	m_lightCount->setName("LightCount");
	m_lightCount->setFont("arial.ttf");
	m_lightCount->setColor(rcolor);
	m_lightCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_lightCount->setCharacterSize(characterSize);
	m_lightCount->setPosition(pos);
	m_lightCount->setAlignment(CRText::crText::BASE_LINE);
	m_lightCount->setText("LightCount: ");
	m_lightCount->setVisiable(false);
	//m_lightCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_lightCount.get(),true);

	//////////////////////////
	//m_phyCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_phyCount = new CRText::crText;
	m_phyCount->setName("PhyCount");
	m_phyCount->setFont("arial.ttf");
	m_phyCount->setColor(rcolor);
	m_phyCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_phyCount->setCharacterSize(characterSize);
	m_phyCount->setPosition(pos);
	m_phyCount->setAlignment(CRText::crText::BASE_LINE);
	m_phyCount->setText("PhyCount: ");
	m_phyCount->setVisiable(false);
	//m_phyCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_phyCount.get(),true);

	//////////////////////////
	//m_textureCount
	/////////////////////////
	pos.x() = leftPos;
	pos.y() -= characterSize;
	m_textureCount = new CRText::crText;
	m_textureCount->setName("PhyCount");
	m_textureCount->setFont("arial.ttf");
	m_textureCount->setColor(rcolor);
	m_textureCount->setFontResolution((unsigned int)characterSize,(unsigned int)characterSize);
	m_textureCount->setCharacterSize(characterSize);
	m_textureCount->setPosition(pos);
	m_textureCount->setAlignment(CRText::crText::BASE_LINE);
	m_textureCount->setText("PhyCount: ");
	m_textureCount->setVisiable(false);
	//m_textureCount->swapBuffers();//为获得正确的BoundBox
	crFilterRenderManager::getInstance()->addDrawable(m_textureCount.get(),true);
}
void crShowEnginStatsMethod::operator()(crHandle &handle)
{
	bool show = crStatistics::getInstance()->getStat();
	if(show)
	{
		if(!m_init)
		{
			init();
		}
		m_fps->setText("FPS: "+crArgumentParser::appItoa(crFrameStamp::getInstance()->getFPS()));
		m_fpsTime->setText("FPSTime: " + crArgumentParser::appItoa(crFrameStamp::getInstance()->getLength()*1e3));
		m_drawTime->setText("DrawTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getDrawTime()));
		m_updTime->setText("UpdTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getUpdTime()));
		m_cullTime->setText("CullTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getCullTime()));
		m_phyUpdTime->setText("PhyTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getPhyUpdTime()));
		m_characterUpdTime->setText("CharacterTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getCharacterUpdTime()));
		m_particleUpdTime->setText("ParticleTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getParticleUpdTime()));
		m_keyboardMouseTime->setText("KeyboardMouseTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getKeyboardMouseTime()));
		m_swapTime->setText("SwapTime: "+crArgumentParser::appItoa(crStatistics::getInstance()->getSwapTime()));
		m_numStates->setText("NumStates: "+crArgumentParser::appItoa(crStatistics::getInstance()->getState()));
		m_numDrawables->setText("NumDrawables: "+crArgumentParser::appItoa(crStatistics::getInstance()->getDrawable()));
		m_primCount->setText("PrimCount: "+crArgumentParser::appItoa(crStatistics::getInstance()->getPrimCount()));
		m_vtxCount->setText("VtxCount: "+crArgumentParser::appItoa(crStatistics::getInstance()->getVertexCount()));
		m_particleCount->setText("ParticleCount: "+crArgumentParser::appItoa(crStatistics::getInstance()->getParticleCount()));
		m_lightCount->setText("LightCount: "+crArgumentParser::appItoa(crLightSourceManager::getInstance()->getNumLights()));
		m_phyCount->setText("StaticPhyCount: "+crArgumentParser::appItoa(crOdeWorld::getStaticGeomCount())+" DynamicPhyCount: "+crArgumentParser::appItoa(crOdeWorld::getDynamicGemoCount()));
		m_textureCount->setText("TextureCount: "+crArgumentParser::appItoa(crTexture::s_numberTextures));
	}
	if(m_init)
	{
		m_fps->setVisiable(show);
		m_fpsTime->setVisiable(show);
		m_drawTime->setVisiable(show);
		m_updTime->setVisiable(show);
		m_cullTime->setVisiable(show);
		m_phyUpdTime->setVisiable(show);
		m_characterUpdTime->setVisiable(show);
		m_particleUpdTime->setVisiable(show);
		m_keyboardMouseTime->setVisiable(show);
		m_swapTime->setVisiable(show);
		m_numStates->setVisiable(show);
		m_numDrawables->setVisiable(show);
		m_primCount->setVisiable(show);
		m_vtxCount->setVisiable(show);
		m_particleCount->setVisiable(show);
		m_lightCount->setVisiable(show);
		m_phyCount->setVisiable(show);
		m_textureCount->setVisiable(show);
	}
}